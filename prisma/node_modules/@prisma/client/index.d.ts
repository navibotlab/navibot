
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model Plan
 * 
 */
export type Plan = $Result.DefaultSelection<Prisma.$PlanPayload>
/**
 * Model SystemConfig
 * 
 */
export type SystemConfig = $Result.DefaultSelection<Prisma.$SystemConfigPayload>
/**
 * Model AdminUser
 * 
 */
export type AdminUser = $Result.DefaultSelection<Prisma.$AdminUserPayload>
/**
 * Model Integration
 * 
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>
/**
 * Model VectorStore
 * 
 */
export type VectorStore = $Result.DefaultSelection<Prisma.$VectorStorePayload>
/**
 * Model ContactField
 * 
 */
export type ContactField = $Result.DefaultSelection<Prisma.$ContactFieldPayload>
/**
 * Model DisparaJaConnection
 * 
 */
export type DisparaJaConnection = $Result.DefaultSelection<Prisma.$DisparaJaConnectionPayload>
/**
 * Model DisparaJaLog
 * 
 */
export type DisparaJaLog = $Result.DefaultSelection<Prisma.$DisparaJaLogPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model WhatsAppCloudConnection
 * 
 */
export type WhatsAppCloudConnection = $Result.DefaultSelection<Prisma.$WhatsAppCloudConnectionPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model AccessToken
 * 
 */
export type AccessToken = $Result.DefaultSelection<Prisma.$AccessTokenPayload>
/**
 * Model PasswordResetToken
 * 
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MessageType: {
  text: 'text',
  image: 'image',
  audio: 'audio'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]

}

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Workspaces
 * const workspaces = await prisma.workspace.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Workspaces
   * const workspaces = await prisma.workspace.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plan`: Exposes CRUD operations for the **Plan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plans
    * const plans = await prisma.plan.findMany()
    * ```
    */
  get plan(): Prisma.PlanDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemConfig`: Exposes CRUD operations for the **SystemConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemConfigs
    * const systemConfigs = await prisma.systemConfig.findMany()
    * ```
    */
  get systemConfig(): Prisma.SystemConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.adminUser`: Exposes CRUD operations for the **AdminUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminUsers
    * const adminUsers = await prisma.adminUser.findMany()
    * ```
    */
  get adminUser(): Prisma.AdminUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vectorStore`: Exposes CRUD operations for the **VectorStore** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VectorStores
    * const vectorStores = await prisma.vectorStore.findMany()
    * ```
    */
  get vectorStore(): Prisma.VectorStoreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactField`: Exposes CRUD operations for the **ContactField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactFields
    * const contactFields = await prisma.contactField.findMany()
    * ```
    */
  get contactField(): Prisma.ContactFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disparaJaConnection`: Exposes CRUD operations for the **DisparaJaConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisparaJaConnections
    * const disparaJaConnections = await prisma.disparaJaConnection.findMany()
    * ```
    */
  get disparaJaConnection(): Prisma.DisparaJaConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.disparaJaLog`: Exposes CRUD operations for the **DisparaJaLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DisparaJaLogs
    * const disparaJaLogs = await prisma.disparaJaLog.findMany()
    * ```
    */
  get disparaJaLog(): Prisma.DisparaJaLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsAppCloudConnection`: Exposes CRUD operations for the **WhatsAppCloudConnection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhatsAppCloudConnections
    * const whatsAppCloudConnections = await prisma.whatsAppCloudConnection.findMany()
    * ```
    */
  get whatsAppCloudConnection(): Prisma.WhatsAppCloudConnectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessToken`: Exposes CRUD operations for the **AccessToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessTokens
    * const accessTokens = await prisma.accessToken.findMany()
    * ```
    */
  get accessToken(): Prisma.AccessTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Workspace: 'Workspace',
    users: 'users',
    Plan: 'Plan',
    SystemConfig: 'SystemConfig',
    AdminUser: 'AdminUser',
    Integration: 'Integration',
    Agent: 'Agent',
    File: 'File',
    VectorStore: 'VectorStore',
    ContactField: 'ContactField',
    DisparaJaConnection: 'DisparaJaConnection',
    DisparaJaLog: 'DisparaJaLog',
    Lead: 'Lead',
    Conversation: 'Conversation',
    Message: 'Message',
    WhatsAppCloudConnection: 'WhatsAppCloudConnection',
    VerificationToken: 'VerificationToken',
    AccessToken: 'AccessToken',
    PasswordResetToken: 'PasswordResetToken'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "workspace" | "users" | "plan" | "systemConfig" | "adminUser" | "integration" | "agent" | "file" | "vectorStore" | "contactField" | "disparaJaConnection" | "disparaJaLog" | "lead" | "conversation" | "message" | "whatsAppCloudConnection" | "verificationToken" | "accessToken" | "passwordResetToken"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkspaceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      Plan: {
        payload: Prisma.$PlanPayload<ExtArgs>
        fields: Prisma.PlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findFirst: {
            args: Prisma.PlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          findMany: {
            args: Prisma.PlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          create: {
            args: Prisma.PlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          createMany: {
            args: Prisma.PlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          delete: {
            args: Prisma.PlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          update: {
            args: Prisma.PlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          deleteMany: {
            args: Prisma.PlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlanUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>[]
          }
          upsert: {
            args: Prisma.PlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlanPayload>
          }
          aggregate: {
            args: Prisma.PlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlan>
          }
          groupBy: {
            args: Prisma.PlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlanCountArgs<ExtArgs>
            result: $Utils.Optional<PlanCountAggregateOutputType> | number
          }
        }
      }
      SystemConfig: {
        payload: Prisma.$SystemConfigPayload<ExtArgs>
        fields: Prisma.SystemConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findFirst: {
            args: Prisma.SystemConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          findMany: {
            args: Prisma.SystemConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          create: {
            args: Prisma.SystemConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          createMany: {
            args: Prisma.SystemConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          delete: {
            args: Prisma.SystemConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          update: {
            args: Prisma.SystemConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          deleteMany: {
            args: Prisma.SystemConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>[]
          }
          upsert: {
            args: Prisma.SystemConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemConfigPayload>
          }
          aggregate: {
            args: Prisma.SystemConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemConfig>
          }
          groupBy: {
            args: Prisma.SystemConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemConfigCountArgs<ExtArgs>
            result: $Utils.Optional<SystemConfigCountAggregateOutputType> | number
          }
        }
      }
      AdminUser: {
        payload: Prisma.$AdminUserPayload<ExtArgs>
        fields: Prisma.AdminUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findFirst: {
            args: Prisma.AdminUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          findMany: {
            args: Prisma.AdminUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          create: {
            args: Prisma.AdminUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          createMany: {
            args: Prisma.AdminUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          delete: {
            args: Prisma.AdminUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          update: {
            args: Prisma.AdminUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          deleteMany: {
            args: Prisma.AdminUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AdminUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>[]
          }
          upsert: {
            args: Prisma.AdminUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminUserPayload>
          }
          aggregate: {
            args: Prisma.AdminUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminUser>
          }
          groupBy: {
            args: Prisma.AdminUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminUserCountArgs<ExtArgs>
            result: $Utils.Optional<AdminUserCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AgentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
      VectorStore: {
        payload: Prisma.$VectorStorePayload<ExtArgs>
        fields: Prisma.VectorStoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VectorStoreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VectorStoreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload>
          }
          findFirst: {
            args: Prisma.VectorStoreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VectorStoreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload>
          }
          findMany: {
            args: Prisma.VectorStoreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload>[]
          }
          create: {
            args: Prisma.VectorStoreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload>
          }
          createMany: {
            args: Prisma.VectorStoreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VectorStoreCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload>[]
          }
          delete: {
            args: Prisma.VectorStoreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload>
          }
          update: {
            args: Prisma.VectorStoreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload>
          }
          deleteMany: {
            args: Prisma.VectorStoreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VectorStoreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VectorStoreUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload>[]
          }
          upsert: {
            args: Prisma.VectorStoreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VectorStorePayload>
          }
          aggregate: {
            args: Prisma.VectorStoreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVectorStore>
          }
          groupBy: {
            args: Prisma.VectorStoreGroupByArgs<ExtArgs>
            result: $Utils.Optional<VectorStoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.VectorStoreCountArgs<ExtArgs>
            result: $Utils.Optional<VectorStoreCountAggregateOutputType> | number
          }
        }
      }
      ContactField: {
        payload: Prisma.$ContactFieldPayload<ExtArgs>
        fields: Prisma.ContactFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload>
          }
          findFirst: {
            args: Prisma.ContactFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload>
          }
          findMany: {
            args: Prisma.ContactFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload>[]
          }
          create: {
            args: Prisma.ContactFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload>
          }
          createMany: {
            args: Prisma.ContactFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload>[]
          }
          delete: {
            args: Prisma.ContactFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload>
          }
          update: {
            args: Prisma.ContactFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload>
          }
          deleteMany: {
            args: Prisma.ContactFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload>[]
          }
          upsert: {
            args: Prisma.ContactFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactFieldPayload>
          }
          aggregate: {
            args: Prisma.ContactFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactField>
          }
          groupBy: {
            args: Prisma.ContactFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactFieldCountArgs<ExtArgs>
            result: $Utils.Optional<ContactFieldCountAggregateOutputType> | number
          }
        }
      }
      DisparaJaConnection: {
        payload: Prisma.$DisparaJaConnectionPayload<ExtArgs>
        fields: Prisma.DisparaJaConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisparaJaConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisparaJaConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload>
          }
          findFirst: {
            args: Prisma.DisparaJaConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisparaJaConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload>
          }
          findMany: {
            args: Prisma.DisparaJaConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload>[]
          }
          create: {
            args: Prisma.DisparaJaConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload>
          }
          createMany: {
            args: Prisma.DisparaJaConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisparaJaConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload>[]
          }
          delete: {
            args: Prisma.DisparaJaConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload>
          }
          update: {
            args: Prisma.DisparaJaConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload>
          }
          deleteMany: {
            args: Prisma.DisparaJaConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisparaJaConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisparaJaConnectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload>[]
          }
          upsert: {
            args: Prisma.DisparaJaConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaConnectionPayload>
          }
          aggregate: {
            args: Prisma.DisparaJaConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisparaJaConnection>
          }
          groupBy: {
            args: Prisma.DisparaJaConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisparaJaConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisparaJaConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<DisparaJaConnectionCountAggregateOutputType> | number
          }
        }
      }
      DisparaJaLog: {
        payload: Prisma.$DisparaJaLogPayload<ExtArgs>
        fields: Prisma.DisparaJaLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DisparaJaLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DisparaJaLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload>
          }
          findFirst: {
            args: Prisma.DisparaJaLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DisparaJaLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload>
          }
          findMany: {
            args: Prisma.DisparaJaLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload>[]
          }
          create: {
            args: Prisma.DisparaJaLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload>
          }
          createMany: {
            args: Prisma.DisparaJaLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DisparaJaLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload>[]
          }
          delete: {
            args: Prisma.DisparaJaLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload>
          }
          update: {
            args: Prisma.DisparaJaLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload>
          }
          deleteMany: {
            args: Prisma.DisparaJaLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DisparaJaLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DisparaJaLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload>[]
          }
          upsert: {
            args: Prisma.DisparaJaLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DisparaJaLogPayload>
          }
          aggregate: {
            args: Prisma.DisparaJaLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDisparaJaLog>
          }
          groupBy: {
            args: Prisma.DisparaJaLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<DisparaJaLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.DisparaJaLogCountArgs<ExtArgs>
            result: $Utils.Optional<DisparaJaLogCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      WhatsAppCloudConnection: {
        payload: Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>
        fields: Prisma.WhatsAppCloudConnectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhatsAppCloudConnectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhatsAppCloudConnectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload>
          }
          findFirst: {
            args: Prisma.WhatsAppCloudConnectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhatsAppCloudConnectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload>
          }
          findMany: {
            args: Prisma.WhatsAppCloudConnectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload>[]
          }
          create: {
            args: Prisma.WhatsAppCloudConnectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload>
          }
          createMany: {
            args: Prisma.WhatsAppCloudConnectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhatsAppCloudConnectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload>[]
          }
          delete: {
            args: Prisma.WhatsAppCloudConnectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload>
          }
          update: {
            args: Prisma.WhatsAppCloudConnectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload>
          }
          deleteMany: {
            args: Prisma.WhatsAppCloudConnectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhatsAppCloudConnectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WhatsAppCloudConnectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload>[]
          }
          upsert: {
            args: Prisma.WhatsAppCloudConnectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhatsAppCloudConnectionPayload>
          }
          aggregate: {
            args: Prisma.WhatsAppCloudConnectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsAppCloudConnection>
          }
          groupBy: {
            args: Prisma.WhatsAppCloudConnectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppCloudConnectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhatsAppCloudConnectionCountArgs<ExtArgs>
            result: $Utils.Optional<WhatsAppCloudConnectionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      AccessToken: {
        payload: Prisma.$AccessTokenPayload<ExtArgs>
        fields: Prisma.AccessTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          findFirst: {
            args: Prisma.AccessTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          findMany: {
            args: Prisma.AccessTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>[]
          }
          create: {
            args: Prisma.AccessTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          createMany: {
            args: Prisma.AccessTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>[]
          }
          delete: {
            args: Prisma.AccessTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          update: {
            args: Prisma.AccessTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          deleteMany: {
            args: Prisma.AccessTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>[]
          }
          upsert: {
            args: Prisma.AccessTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessTokenPayload>
          }
          aggregate: {
            args: Prisma.AccessTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessToken>
          }
          groupBy: {
            args: Prisma.AccessTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessTokenCountArgs<ExtArgs>
            result: $Utils.Optional<AccessTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    workspace?: WorkspaceOmit
    users?: usersOmit
    plan?: PlanOmit
    systemConfig?: SystemConfigOmit
    adminUser?: AdminUserOmit
    integration?: IntegrationOmit
    agent?: AgentOmit
    file?: FileOmit
    vectorStore?: VectorStoreOmit
    contactField?: ContactFieldOmit
    disparaJaConnection?: DisparaJaConnectionOmit
    disparaJaLog?: DisparaJaLogOmit
    lead?: LeadOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    whatsAppCloudConnection?: WhatsAppCloudConnectionOmit
    verificationToken?: VerificationTokenOmit
    accessToken?: AccessTokenOmit
    passwordResetToken?: PasswordResetTokenOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    agents: number
    contact_fields: number
    conversations: number
    disparaJaConnections: number
    dispara_ja_logs: number
    files: number
    integrations: number
    leads: number
    system_configs: number
    users: number
    vector_stores: number
    whatsappCloudConnections: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | WorkspaceCountOutputTypeCountAgentsArgs
    contact_fields?: boolean | WorkspaceCountOutputTypeCountContact_fieldsArgs
    conversations?: boolean | WorkspaceCountOutputTypeCountConversationsArgs
    disparaJaConnections?: boolean | WorkspaceCountOutputTypeCountDisparaJaConnectionsArgs
    dispara_ja_logs?: boolean | WorkspaceCountOutputTypeCountDispara_ja_logsArgs
    files?: boolean | WorkspaceCountOutputTypeCountFilesArgs
    integrations?: boolean | WorkspaceCountOutputTypeCountIntegrationsArgs
    leads?: boolean | WorkspaceCountOutputTypeCountLeadsArgs
    system_configs?: boolean | WorkspaceCountOutputTypeCountSystem_configsArgs
    users?: boolean | WorkspaceCountOutputTypeCountUsersArgs
    vector_stores?: boolean | WorkspaceCountOutputTypeCountVector_storesArgs
    whatsappCloudConnections?: boolean | WorkspaceCountOutputTypeCountWhatsappCloudConnectionsArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountAgentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountContact_fieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactFieldWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountDisparaJaConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisparaJaConnectionWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountDispara_ja_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisparaJaLogWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountSystem_configsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountVector_storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VectorStoreWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountWhatsappCloudConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppCloudConnectionWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    accessTokens: number
    integrations: number
    verificationTokens: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accessTokens?: boolean | UsersCountOutputTypeCountAccessTokensArgs
    integrations?: boolean | UsersCountOutputTypeCountIntegrationsArgs
    verificationTokens?: boolean | UsersCountOutputTypeCountVerificationTokensArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountAccessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessTokenWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountVerificationTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
  }


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    disparaJaConnections: number
    whatsappCloudConnections: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    disparaJaConnections?: boolean | AgentCountOutputTypeCountDisparaJaConnectionsArgs
    whatsappCloudConnections?: boolean | AgentCountOutputTypeCountWhatsappCloudConnectionsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountDisparaJaConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisparaJaConnectionWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountWhatsappCloudConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppCloudConnectionWhereInput
  }


  /**
   * Count Type DisparaJaConnectionCountOutputType
   */

  export type DisparaJaConnectionCountOutputType = {
    logs: number
  }

  export type DisparaJaConnectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | DisparaJaConnectionCountOutputTypeCountLogsArgs
  }

  // Custom InputTypes
  /**
   * DisparaJaConnectionCountOutputType without action
   */
  export type DisparaJaConnectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnectionCountOutputType
     */
    select?: DisparaJaConnectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DisparaJaConnectionCountOutputType without action
   */
  export type DisparaJaConnectionCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisparaJaLogWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    conversations: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | LeadCountOutputTypeCountConversationsArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    subdomain: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    name: number
    subdomain: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    name?: true
    subdomain?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: string
    name: string
    subdomain: string | null
    createdAt: Date
    updatedAt: Date
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agents?: boolean | Workspace$agentsArgs<ExtArgs>
    contact_fields?: boolean | Workspace$contact_fieldsArgs<ExtArgs>
    conversations?: boolean | Workspace$conversationsArgs<ExtArgs>
    disparaJaConnections?: boolean | Workspace$disparaJaConnectionsArgs<ExtArgs>
    dispara_ja_logs?: boolean | Workspace$dispara_ja_logsArgs<ExtArgs>
    files?: boolean | Workspace$filesArgs<ExtArgs>
    integrations?: boolean | Workspace$integrationsArgs<ExtArgs>
    leads?: boolean | Workspace$leadsArgs<ExtArgs>
    system_configs?: boolean | Workspace$system_configsArgs<ExtArgs>
    users?: boolean | Workspace$usersArgs<ExtArgs>
    vector_stores?: boolean | Workspace$vector_storesArgs<ExtArgs>
    whatsappCloudConnections?: boolean | Workspace$whatsappCloudConnectionsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean
    name?: boolean
    subdomain?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WorkspaceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "subdomain" | "createdAt" | "updatedAt", ExtArgs["result"]["workspace"]>
  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agents?: boolean | Workspace$agentsArgs<ExtArgs>
    contact_fields?: boolean | Workspace$contact_fieldsArgs<ExtArgs>
    conversations?: boolean | Workspace$conversationsArgs<ExtArgs>
    disparaJaConnections?: boolean | Workspace$disparaJaConnectionsArgs<ExtArgs>
    dispara_ja_logs?: boolean | Workspace$dispara_ja_logsArgs<ExtArgs>
    files?: boolean | Workspace$filesArgs<ExtArgs>
    integrations?: boolean | Workspace$integrationsArgs<ExtArgs>
    leads?: boolean | Workspace$leadsArgs<ExtArgs>
    system_configs?: boolean | Workspace$system_configsArgs<ExtArgs>
    users?: boolean | Workspace$usersArgs<ExtArgs>
    vector_stores?: boolean | Workspace$vector_storesArgs<ExtArgs>
    whatsappCloudConnections?: boolean | Workspace$whatsappCloudConnectionsArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type WorkspaceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      agents: Prisma.$AgentPayload<ExtArgs>[]
      contact_fields: Prisma.$ContactFieldPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      disparaJaConnections: Prisma.$DisparaJaConnectionPayload<ExtArgs>[]
      dispara_ja_logs: Prisma.$DisparaJaLogPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
      integrations: Prisma.$IntegrationPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      system_configs: Prisma.$SystemConfigPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
      vector_stores: Prisma.$VectorStorePayload<ExtArgs>[]
      whatsappCloudConnections: Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      subdomain: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces and returns the data updated in the database.
     * @param {WorkspaceUpdateManyAndReturnArgs} args - Arguments to update many Workspaces.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkspaceUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkspaceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agents<T extends Workspace$agentsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$agentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contact_fields<T extends Workspace$contact_fieldsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$contact_fieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends Workspace$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    disparaJaConnections<T extends Workspace$disparaJaConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$disparaJaConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dispara_ja_logs<T extends Workspace$dispara_ja_logsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$dispara_ja_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends Workspace$filesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integrations<T extends Workspace$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leads<T extends Workspace$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    system_configs<T extends Workspace$system_configsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$system_configsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Workspace$usersArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vector_stores<T extends Workspace$vector_storesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$vector_storesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappCloudConnections<T extends Workspace$whatsappCloudConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$whatsappCloudConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'String'>
    readonly name: FieldRef<"Workspace", 'String'>
    readonly subdomain: FieldRef<"Workspace", 'String'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly updatedAt: FieldRef<"Workspace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace updateManyAndReturn
   */
  export type WorkspaceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to update.
     */
    limit?: number
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
    /**
     * Limit how many Workspaces to delete.
     */
    limit?: number
  }

  /**
   * Workspace.agents
   */
  export type Workspace$agentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    cursor?: AgentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Workspace.contact_fields
   */
  export type Workspace$contact_fieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
    where?: ContactFieldWhereInput
    orderBy?: ContactFieldOrderByWithRelationInput | ContactFieldOrderByWithRelationInput[]
    cursor?: ContactFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactFieldScalarFieldEnum | ContactFieldScalarFieldEnum[]
  }

  /**
   * Workspace.conversations
   */
  export type Workspace$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Workspace.disparaJaConnections
   */
  export type Workspace$disparaJaConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    where?: DisparaJaConnectionWhereInput
    orderBy?: DisparaJaConnectionOrderByWithRelationInput | DisparaJaConnectionOrderByWithRelationInput[]
    cursor?: DisparaJaConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisparaJaConnectionScalarFieldEnum | DisparaJaConnectionScalarFieldEnum[]
  }

  /**
   * Workspace.dispara_ja_logs
   */
  export type Workspace$dispara_ja_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    where?: DisparaJaLogWhereInput
    orderBy?: DisparaJaLogOrderByWithRelationInput | DisparaJaLogOrderByWithRelationInput[]
    cursor?: DisparaJaLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisparaJaLogScalarFieldEnum | DisparaJaLogScalarFieldEnum[]
  }

  /**
   * Workspace.files
   */
  export type Workspace$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * Workspace.integrations
   */
  export type Workspace$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Workspace.leads
   */
  export type Workspace$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Workspace.system_configs
   */
  export type Workspace$system_configsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    cursor?: SystemConfigWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * Workspace.users
   */
  export type Workspace$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * Workspace.vector_stores
   */
  export type Workspace$vector_storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
    where?: VectorStoreWhereInput
    orderBy?: VectorStoreOrderByWithRelationInput | VectorStoreOrderByWithRelationInput[]
    cursor?: VectorStoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VectorStoreScalarFieldEnum | VectorStoreScalarFieldEnum[]
  }

  /**
   * Workspace.whatsappCloudConnections
   */
  export type Workspace$whatsappCloudConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    where?: WhatsAppCloudConnectionWhereInput
    orderBy?: WhatsAppCloudConnectionOrderByWithRelationInput | WhatsAppCloudConnectionOrderByWithRelationInput[]
    cursor?: WhatsAppCloudConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppCloudConnectionScalarFieldEnum | WhatsAppCloudConnectionScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workspace
     */
    omit?: WorkspaceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    workspaceId: string | null
    emailVerified: Date | null
    verifyToken: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    lastLogin: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    workspaceId: string | null
    emailVerified: Date | null
    verifyToken: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    lastLogin: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    workspaceId: number
    emailVerified: number
    verifyToken: number
    resetToken: number
    resetTokenExpiry: number
    lastLogin: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    workspaceId?: true
    emailVerified?: true
    verifyToken?: true
    resetToken?: true
    resetTokenExpiry?: true
    lastLogin?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    workspaceId?: true
    emailVerified?: true
    verifyToken?: true
    resetToken?: true
    resetTokenExpiry?: true
    lastLogin?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    workspaceId?: true
    emailVerified?: true
    verifyToken?: true
    resetToken?: true
    resetTokenExpiry?: true
    lastLogin?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    email: string
    name: string | null
    password: string
    role: string
    workspaceId: string
    emailVerified: Date | null
    verifyToken: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    lastLogin: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    workspaceId?: boolean
    emailVerified?: boolean
    verifyToken?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLogin?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accessTokens?: boolean | users$accessTokensArgs<ExtArgs>
    integrations?: boolean | users$integrationsArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    verificationTokens?: boolean | users$verificationTokensArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    workspaceId?: boolean
    emailVerified?: boolean
    verifyToken?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLogin?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    workspaceId?: boolean
    emailVerified?: boolean
    verifyToken?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLogin?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    workspaceId?: boolean
    emailVerified?: boolean
    verifyToken?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    lastLogin?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "role" | "workspaceId" | "emailVerified" | "verifyToken" | "resetToken" | "resetTokenExpiry" | "lastLogin" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accessTokens?: boolean | users$accessTokensArgs<ExtArgs>
    integrations?: boolean | users$integrationsArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    verificationTokens?: boolean | users$verificationTokensArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      accessTokens: Prisma.$AccessTokenPayload<ExtArgs>[]
      integrations: Prisma.$IntegrationPayload<ExtArgs>[]
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      verificationTokens: Prisma.$VerificationTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      password: string
      role: string
      workspaceId: string
      emailVerified: Date | null
      verifyToken: string | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      lastLogin: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accessTokens<T extends users$accessTokensArgs<ExtArgs> = {}>(args?: Subset<T, users$accessTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integrations<T extends users$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, users$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    verificationTokens<T extends users$verificationTokensArgs<ExtArgs> = {}>(args?: Subset<T, users$verificationTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly role: FieldRef<"users", 'String'>
    readonly workspaceId: FieldRef<"users", 'String'>
    readonly emailVerified: FieldRef<"users", 'DateTime'>
    readonly verifyToken: FieldRef<"users", 'String'>
    readonly resetToken: FieldRef<"users", 'String'>
    readonly resetTokenExpiry: FieldRef<"users", 'DateTime'>
    readonly lastLogin: FieldRef<"users", 'DateTime'>
    readonly status: FieldRef<"users", 'String'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.accessTokens
   */
  export type users$accessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    where?: AccessTokenWhereInput
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    cursor?: AccessTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
  }

  /**
   * users.integrations
   */
  export type users$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * users.verificationTokens
   */
  export type users$verificationTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    cursor?: VerificationTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model Plan
   */

  export type AggregatePlan = {
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  export type PlanAvgAggregateOutputType = {
    price: number | null
  }

  export type PlanSumAggregateOutputType = {
    price: number | null
  }

  export type PlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlanCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    features: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlanAvgAggregateInputType = {
    price?: true
  }

  export type PlanSumAggregateInputType = {
    price?: true
  }

  export type PlanMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlanCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    features?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plan to aggregate.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plans
    **/
    _count?: true | PlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlanMaxAggregateInputType
  }

  export type GetPlanAggregateType<T extends PlanAggregateArgs> = {
        [P in keyof T & keyof AggregatePlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlan[P]>
      : GetScalarType<T[P], AggregatePlan[P]>
  }




  export type PlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlanWhereInput
    orderBy?: PlanOrderByWithAggregationInput | PlanOrderByWithAggregationInput[]
    by: PlanScalarFieldEnum[] | PlanScalarFieldEnum
    having?: PlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlanCountAggregateInputType | true
    _avg?: PlanAvgAggregateInputType
    _sum?: PlanSumAggregateInputType
    _min?: PlanMinAggregateInputType
    _max?: PlanMaxAggregateInputType
  }

  export type PlanGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    features: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PlanCountAggregateOutputType | null
    _avg: PlanAvgAggregateOutputType | null
    _sum: PlanSumAggregateOutputType | null
    _min: PlanMinAggregateOutputType | null
    _max: PlanMaxAggregateOutputType | null
  }

  type GetPlanGroupByPayload<T extends PlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlanGroupByOutputType[P]>
            : GetScalarType<T[P], PlanGroupByOutputType[P]>
        }
      >
    >


  export type PlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["plan"]>

  export type PlanSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    features?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlanOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "features" | "createdAt" | "updatedAt", ExtArgs["result"]["plan"]>

  export type $PlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plan"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      features: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["plan"]>
    composites: {}
  }

  type PlanGetPayload<S extends boolean | null | undefined | PlanDefaultArgs> = $Result.GetResult<Prisma.$PlanPayload, S>

  type PlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlanFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlanCountAggregateInputType | true
    }

  export interface PlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plan'], meta: { name: 'Plan' } }
    /**
     * Find zero or one Plan that matches the filter.
     * @param {PlanFindUniqueArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlanFindUniqueArgs>(args: SelectSubset<T, PlanFindUniqueArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plan that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlanFindUniqueOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlanFindUniqueOrThrowArgs>(args: SelectSubset<T, PlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlanFindFirstArgs>(args?: SelectSubset<T, PlanFindFirstArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindFirstOrThrowArgs} args - Arguments to find a Plan
     * @example
     * // Get one Plan
     * const plan = await prisma.plan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlanFindFirstOrThrowArgs>(args?: SelectSubset<T, PlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plans
     * const plans = await prisma.plan.findMany()
     * 
     * // Get first 10 Plans
     * const plans = await prisma.plan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const planWithIdOnly = await prisma.plan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlanFindManyArgs>(args?: SelectSubset<T, PlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plan.
     * @param {PlanCreateArgs} args - Arguments to create a Plan.
     * @example
     * // Create one Plan
     * const Plan = await prisma.plan.create({
     *   data: {
     *     // ... data to create a Plan
     *   }
     * })
     * 
     */
    create<T extends PlanCreateArgs>(args: SelectSubset<T, PlanCreateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plans.
     * @param {PlanCreateManyArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlanCreateManyArgs>(args?: SelectSubset<T, PlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plans and returns the data saved in the database.
     * @param {PlanCreateManyAndReturnArgs} args - Arguments to create many Plans.
     * @example
     * // Create many Plans
     * const plan = await prisma.plan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlanCreateManyAndReturnArgs>(args?: SelectSubset<T, PlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plan.
     * @param {PlanDeleteArgs} args - Arguments to delete one Plan.
     * @example
     * // Delete one Plan
     * const Plan = await prisma.plan.delete({
     *   where: {
     *     // ... filter to delete one Plan
     *   }
     * })
     * 
     */
    delete<T extends PlanDeleteArgs>(args: SelectSubset<T, PlanDeleteArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plan.
     * @param {PlanUpdateArgs} args - Arguments to update one Plan.
     * @example
     * // Update one Plan
     * const plan = await prisma.plan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlanUpdateArgs>(args: SelectSubset<T, PlanUpdateArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plans.
     * @param {PlanDeleteManyArgs} args - Arguments to filter Plans to delete.
     * @example
     * // Delete a few Plans
     * const { count } = await prisma.plan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlanDeleteManyArgs>(args?: SelectSubset<T, PlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlanUpdateManyArgs>(args: SelectSubset<T, PlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plans and returns the data updated in the database.
     * @param {PlanUpdateManyAndReturnArgs} args - Arguments to update many Plans.
     * @example
     * // Update many Plans
     * const plan = await prisma.plan.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plans and only return the `id`
     * const planWithIdOnly = await prisma.plan.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlanUpdateManyAndReturnArgs>(args: SelectSubset<T, PlanUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plan.
     * @param {PlanUpsertArgs} args - Arguments to update or create a Plan.
     * @example
     * // Update or create a Plan
     * const plan = await prisma.plan.upsert({
     *   create: {
     *     // ... data to create a Plan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plan we want to update
     *   }
     * })
     */
    upsert<T extends PlanUpsertArgs>(args: SelectSubset<T, PlanUpsertArgs<ExtArgs>>): Prisma__PlanClient<$Result.GetResult<Prisma.$PlanPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanCountArgs} args - Arguments to filter Plans to count.
     * @example
     * // Count the number of Plans
     * const count = await prisma.plan.count({
     *   where: {
     *     // ... the filter for the Plans we want to count
     *   }
     * })
    **/
    count<T extends PlanCountArgs>(
      args?: Subset<T, PlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlanAggregateArgs>(args: Subset<T, PlanAggregateArgs>): Prisma.PrismaPromise<GetPlanAggregateType<T>>

    /**
     * Group by Plan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlanGroupByArgs['orderBy'] }
        : { orderBy?: PlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plan model
   */
  readonly fields: PlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plan model
   */
  interface PlanFieldRefs {
    readonly id: FieldRef<"Plan", 'String'>
    readonly name: FieldRef<"Plan", 'String'>
    readonly description: FieldRef<"Plan", 'String'>
    readonly price: FieldRef<"Plan", 'Float'>
    readonly features: FieldRef<"Plan", 'Json'>
    readonly createdAt: FieldRef<"Plan", 'DateTime'>
    readonly updatedAt: FieldRef<"Plan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plan findUnique
   */
  export type PlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findUniqueOrThrow
   */
  export type PlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan findFirst
   */
  export type PlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findFirstOrThrow
   */
  export type PlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter, which Plan to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plans.
     */
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan findMany
   */
  export type PlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter, which Plans to fetch.
     */
    where?: PlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plans to fetch.
     */
    orderBy?: PlanOrderByWithRelationInput | PlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plans.
     */
    cursor?: PlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Plans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plans.
     */
    skip?: number
    distinct?: PlanScalarFieldEnum | PlanScalarFieldEnum[]
  }

  /**
   * Plan create
   */
  export type PlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data needed to create a Plan.
     */
    data: XOR<PlanCreateInput, PlanUncheckedCreateInput>
  }

  /**
   * Plan createMany
   */
  export type PlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan createManyAndReturn
   */
  export type PlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to create many Plans.
     */
    data: PlanCreateManyInput | PlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plan update
   */
  export type PlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data needed to update a Plan.
     */
    data: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
    /**
     * Choose, which Plan to update.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan updateMany
   */
  export type PlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan updateManyAndReturn
   */
  export type PlanUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The data used to update Plans.
     */
    data: XOR<PlanUpdateManyMutationInput, PlanUncheckedUpdateManyInput>
    /**
     * Filter which Plans to update
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to update.
     */
    limit?: number
  }

  /**
   * Plan upsert
   */
  export type PlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * The filter to search for the Plan to update in case it exists.
     */
    where: PlanWhereUniqueInput
    /**
     * In case the Plan found by the `where` argument doesn't exist, create a new Plan with this data.
     */
    create: XOR<PlanCreateInput, PlanUncheckedCreateInput>
    /**
     * In case the Plan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlanUpdateInput, PlanUncheckedUpdateInput>
  }

  /**
   * Plan delete
   */
  export type PlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
    /**
     * Filter which Plan to delete.
     */
    where: PlanWhereUniqueInput
  }

  /**
   * Plan deleteMany
   */
  export type PlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plans to delete
     */
    where?: PlanWhereInput
    /**
     * Limit how many Plans to delete.
     */
    limit?: number
  }

  /**
   * Plan without action
   */
  export type PlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plan
     */
    select?: PlanSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plan
     */
    omit?: PlanOmit<ExtArgs> | null
  }


  /**
   * Model SystemConfig
   */

  export type AggregateSystemConfig = {
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  export type SystemConfigMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type SystemConfigMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type SystemConfigCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    createdAt: number
    updatedAt: number
    workspaceId: number
    _all: number
  }


  export type SystemConfigMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type SystemConfigMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type SystemConfigCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
    _all?: true
  }

  export type SystemConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfig to aggregate.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemConfigs
    **/
    _count?: true | SystemConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemConfigMaxAggregateInputType
  }

  export type GetSystemConfigAggregateType<T extends SystemConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemConfig[P]>
      : GetScalarType<T[P], AggregateSystemConfig[P]>
  }




  export type SystemConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemConfigWhereInput
    orderBy?: SystemConfigOrderByWithAggregationInput | SystemConfigOrderByWithAggregationInput[]
    by: SystemConfigScalarFieldEnum[] | SystemConfigScalarFieldEnum
    having?: SystemConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemConfigCountAggregateInputType | true
    _min?: SystemConfigMinAggregateInputType
    _max?: SystemConfigMaxAggregateInputType
  }

  export type SystemConfigGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    workspaceId: string
    _count: SystemConfigCountAggregateOutputType | null
    _min: SystemConfigMinAggregateOutputType | null
    _max: SystemConfigMaxAggregateOutputType | null
  }

  type GetSystemConfigGroupByPayload<T extends SystemConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
            : GetScalarType<T[P], SystemConfigGroupByOutputType[P]>
        }
      >
    >


  export type SystemConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["systemConfig"]>

  export type SystemConfigSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
  }

  export type SystemConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "description" | "createdAt" | "updatedAt" | "workspaceId", ExtArgs["result"]["systemConfig"]>
  export type SystemConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type SystemConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type SystemConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $SystemConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemConfig"
    objects: {
      workspaces: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      createdAt: Date
      updatedAt: Date
      workspaceId: string
    }, ExtArgs["result"]["systemConfig"]>
    composites: {}
  }

  type SystemConfigGetPayload<S extends boolean | null | undefined | SystemConfigDefaultArgs> = $Result.GetResult<Prisma.$SystemConfigPayload, S>

  type SystemConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemConfigCountAggregateInputType | true
    }

  export interface SystemConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemConfig'], meta: { name: 'SystemConfig' } }
    /**
     * Find zero or one SystemConfig that matches the filter.
     * @param {SystemConfigFindUniqueArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemConfigFindUniqueArgs>(args: SelectSubset<T, SystemConfigFindUniqueArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemConfigFindUniqueOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemConfigFindFirstArgs>(args?: SelectSubset<T, SystemConfigFindFirstArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindFirstOrThrowArgs} args - Arguments to find a SystemConfig
     * @example
     * // Get one SystemConfig
     * const systemConfig = await prisma.systemConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany()
     * 
     * // Get first 10 SystemConfigs
     * const systemConfigs = await prisma.systemConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemConfigFindManyArgs>(args?: SelectSubset<T, SystemConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemConfig.
     * @param {SystemConfigCreateArgs} args - Arguments to create a SystemConfig.
     * @example
     * // Create one SystemConfig
     * const SystemConfig = await prisma.systemConfig.create({
     *   data: {
     *     // ... data to create a SystemConfig
     *   }
     * })
     * 
     */
    create<T extends SystemConfigCreateArgs>(args: SelectSubset<T, SystemConfigCreateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemConfigs.
     * @param {SystemConfigCreateManyArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemConfigCreateManyArgs>(args?: SelectSubset<T, SystemConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemConfigs and returns the data saved in the database.
     * @param {SystemConfigCreateManyAndReturnArgs} args - Arguments to create many SystemConfigs.
     * @example
     * // Create many SystemConfigs
     * const systemConfig = await prisma.systemConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemConfig.
     * @param {SystemConfigDeleteArgs} args - Arguments to delete one SystemConfig.
     * @example
     * // Delete one SystemConfig
     * const SystemConfig = await prisma.systemConfig.delete({
     *   where: {
     *     // ... filter to delete one SystemConfig
     *   }
     * })
     * 
     */
    delete<T extends SystemConfigDeleteArgs>(args: SelectSubset<T, SystemConfigDeleteArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemConfig.
     * @param {SystemConfigUpdateArgs} args - Arguments to update one SystemConfig.
     * @example
     * // Update one SystemConfig
     * const systemConfig = await prisma.systemConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemConfigUpdateArgs>(args: SelectSubset<T, SystemConfigUpdateArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemConfigs.
     * @param {SystemConfigDeleteManyArgs} args - Arguments to filter SystemConfigs to delete.
     * @example
     * // Delete a few SystemConfigs
     * const { count } = await prisma.systemConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemConfigDeleteManyArgs>(args?: SelectSubset<T, SystemConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemConfigUpdateManyArgs>(args: SelectSubset<T, SystemConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemConfigs and returns the data updated in the database.
     * @param {SystemConfigUpdateManyAndReturnArgs} args - Arguments to update many SystemConfigs.
     * @example
     * // Update many SystemConfigs
     * const systemConfig = await prisma.systemConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemConfigs and only return the `id`
     * const systemConfigWithIdOnly = await prisma.systemConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemConfig.
     * @param {SystemConfigUpsertArgs} args - Arguments to update or create a SystemConfig.
     * @example
     * // Update or create a SystemConfig
     * const systemConfig = await prisma.systemConfig.upsert({
     *   create: {
     *     // ... data to create a SystemConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemConfig we want to update
     *   }
     * })
     */
    upsert<T extends SystemConfigUpsertArgs>(args: SelectSubset<T, SystemConfigUpsertArgs<ExtArgs>>): Prisma__SystemConfigClient<$Result.GetResult<Prisma.$SystemConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigCountArgs} args - Arguments to filter SystemConfigs to count.
     * @example
     * // Count the number of SystemConfigs
     * const count = await prisma.systemConfig.count({
     *   where: {
     *     // ... the filter for the SystemConfigs we want to count
     *   }
     * })
    **/
    count<T extends SystemConfigCountArgs>(
      args?: Subset<T, SystemConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemConfigAggregateArgs>(args: Subset<T, SystemConfigAggregateArgs>): Prisma.PrismaPromise<GetSystemConfigAggregateType<T>>

    /**
     * Group by SystemConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemConfigGroupByArgs['orderBy'] }
        : { orderBy?: SystemConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemConfig model
   */
  readonly fields: SystemConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaces<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemConfig model
   */
  interface SystemConfigFieldRefs {
    readonly id: FieldRef<"SystemConfig", 'String'>
    readonly key: FieldRef<"SystemConfig", 'String'>
    readonly value: FieldRef<"SystemConfig", 'String'>
    readonly description: FieldRef<"SystemConfig", 'String'>
    readonly createdAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemConfig", 'DateTime'>
    readonly workspaceId: FieldRef<"SystemConfig", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SystemConfig findUnique
   */
  export type SystemConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findUniqueOrThrow
   */
  export type SystemConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig findFirst
   */
  export type SystemConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findFirstOrThrow
   */
  export type SystemConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
    /**
     * Filter, which SystemConfig to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemConfigs.
     */
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig findMany
   */
  export type SystemConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
    /**
     * Filter, which SystemConfigs to fetch.
     */
    where?: SystemConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemConfigs to fetch.
     */
    orderBy?: SystemConfigOrderByWithRelationInput | SystemConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemConfigs.
     */
    cursor?: SystemConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemConfigs.
     */
    skip?: number
    distinct?: SystemConfigScalarFieldEnum | SystemConfigScalarFieldEnum[]
  }

  /**
   * SystemConfig create
   */
  export type SystemConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a SystemConfig.
     */
    data: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
  }

  /**
   * SystemConfig createMany
   */
  export type SystemConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemConfig createManyAndReturn
   */
  export type SystemConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to create many SystemConfigs.
     */
    data: SystemConfigCreateManyInput | SystemConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemConfig update
   */
  export type SystemConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a SystemConfig.
     */
    data: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
    /**
     * Choose, which SystemConfig to update.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig updateMany
   */
  export type SystemConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
  }

  /**
   * SystemConfig updateManyAndReturn
   */
  export type SystemConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * The data used to update SystemConfigs.
     */
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyInput>
    /**
     * Filter which SystemConfigs to update
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SystemConfig upsert
   */
  export type SystemConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the SystemConfig to update in case it exists.
     */
    where: SystemConfigWhereUniqueInput
    /**
     * In case the SystemConfig found by the `where` argument doesn't exist, create a new SystemConfig with this data.
     */
    create: XOR<SystemConfigCreateInput, SystemConfigUncheckedCreateInput>
    /**
     * In case the SystemConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemConfigUpdateInput, SystemConfigUncheckedUpdateInput>
  }

  /**
   * SystemConfig delete
   */
  export type SystemConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
    /**
     * Filter which SystemConfig to delete.
     */
    where: SystemConfigWhereUniqueInput
  }

  /**
   * SystemConfig deleteMany
   */
  export type SystemConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemConfigs to delete
     */
    where?: SystemConfigWhereInput
    /**
     * Limit how many SystemConfigs to delete.
     */
    limit?: number
  }

  /**
   * SystemConfig without action
   */
  export type SystemConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemConfig
     */
    select?: SystemConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemConfig
     */
    omit?: SystemConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SystemConfigInclude<ExtArgs> | null
  }


  /**
   * Model AdminUser
   */

  export type AggregateAdminUser = {
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  export type AdminUserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminUserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    password: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AdminUserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AdminUserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminUserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AdminUserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AdminUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUser to aggregate.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminUsers
    **/
    _count?: true | AdminUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminUserMaxAggregateInputType
  }

  export type GetAdminUserAggregateType<T extends AdminUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminUser[P]>
      : GetScalarType<T[P], AggregateAdminUser[P]>
  }




  export type AdminUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminUserWhereInput
    orderBy?: AdminUserOrderByWithAggregationInput | AdminUserOrderByWithAggregationInput[]
    by: AdminUserScalarFieldEnum[] | AdminUserScalarFieldEnum
    having?: AdminUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminUserCountAggregateInputType | true
    _min?: AdminUserMinAggregateInputType
    _max?: AdminUserMaxAggregateInputType
  }

  export type AdminUserGroupByOutputType = {
    id: string
    email: string
    name: string
    password: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: AdminUserCountAggregateOutputType | null
    _min: AdminUserMinAggregateOutputType | null
    _max: AdminUserMaxAggregateOutputType | null
  }

  type GetAdminUserGroupByPayload<T extends AdminUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
            : GetScalarType<T[P], AdminUserGroupByOutputType[P]>
        }
      >
    >


  export type AdminUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["adminUser"]>

  export type AdminUserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AdminUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "password" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["adminUser"]>

  export type $AdminUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminUser"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string
      password: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["adminUser"]>
    composites: {}
  }

  type AdminUserGetPayload<S extends boolean | null | undefined | AdminUserDefaultArgs> = $Result.GetResult<Prisma.$AdminUserPayload, S>

  type AdminUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AdminUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AdminUserCountAggregateInputType | true
    }

  export interface AdminUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminUser'], meta: { name: 'AdminUser' } }
    /**
     * Find zero or one AdminUser that matches the filter.
     * @param {AdminUserFindUniqueArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminUserFindUniqueArgs>(args: SelectSubset<T, AdminUserFindUniqueArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AdminUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AdminUserFindUniqueOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminUserFindFirstArgs>(args?: SelectSubset<T, AdminUserFindFirstArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AdminUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindFirstOrThrowArgs} args - Arguments to find a AdminUser
     * @example
     * // Get one AdminUser
     * const adminUser = await prisma.adminUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AdminUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminUsers
     * const adminUsers = await prisma.adminUser.findMany()
     * 
     * // Get first 10 AdminUsers
     * const adminUsers = await prisma.adminUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminUserFindManyArgs>(args?: SelectSubset<T, AdminUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AdminUser.
     * @param {AdminUserCreateArgs} args - Arguments to create a AdminUser.
     * @example
     * // Create one AdminUser
     * const AdminUser = await prisma.adminUser.create({
     *   data: {
     *     // ... data to create a AdminUser
     *   }
     * })
     * 
     */
    create<T extends AdminUserCreateArgs>(args: SelectSubset<T, AdminUserCreateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AdminUsers.
     * @param {AdminUserCreateManyArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminUserCreateManyArgs>(args?: SelectSubset<T, AdminUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminUsers and returns the data saved in the database.
     * @param {AdminUserCreateManyAndReturnArgs} args - Arguments to create many AdminUsers.
     * @example
     * // Create many AdminUsers
     * const adminUser = await prisma.adminUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminUsers and only return the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminUserCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AdminUser.
     * @param {AdminUserDeleteArgs} args - Arguments to delete one AdminUser.
     * @example
     * // Delete one AdminUser
     * const AdminUser = await prisma.adminUser.delete({
     *   where: {
     *     // ... filter to delete one AdminUser
     *   }
     * })
     * 
     */
    delete<T extends AdminUserDeleteArgs>(args: SelectSubset<T, AdminUserDeleteArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AdminUser.
     * @param {AdminUserUpdateArgs} args - Arguments to update one AdminUser.
     * @example
     * // Update one AdminUser
     * const adminUser = await prisma.adminUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminUserUpdateArgs>(args: SelectSubset<T, AdminUserUpdateArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AdminUsers.
     * @param {AdminUserDeleteManyArgs} args - Arguments to filter AdminUsers to delete.
     * @example
     * // Delete a few AdminUsers
     * const { count } = await prisma.adminUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminUserDeleteManyArgs>(args?: SelectSubset<T, AdminUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminUserUpdateManyArgs>(args: SelectSubset<T, AdminUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminUsers and returns the data updated in the database.
     * @param {AdminUserUpdateManyAndReturnArgs} args - Arguments to update many AdminUsers.
     * @example
     * // Update many AdminUsers
     * const adminUser = await prisma.adminUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AdminUsers and only return the `id`
     * const adminUserWithIdOnly = await prisma.adminUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AdminUserUpdateManyAndReturnArgs>(args: SelectSubset<T, AdminUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AdminUser.
     * @param {AdminUserUpsertArgs} args - Arguments to update or create a AdminUser.
     * @example
     * // Update or create a AdminUser
     * const adminUser = await prisma.adminUser.upsert({
     *   create: {
     *     // ... data to create a AdminUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminUser we want to update
     *   }
     * })
     */
    upsert<T extends AdminUserUpsertArgs>(args: SelectSubset<T, AdminUserUpsertArgs<ExtArgs>>): Prisma__AdminUserClient<$Result.GetResult<Prisma.$AdminUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AdminUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserCountArgs} args - Arguments to filter AdminUsers to count.
     * @example
     * // Count the number of AdminUsers
     * const count = await prisma.adminUser.count({
     *   where: {
     *     // ... the filter for the AdminUsers we want to count
     *   }
     * })
    **/
    count<T extends AdminUserCountArgs>(
      args?: Subset<T, AdminUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminUserAggregateArgs>(args: Subset<T, AdminUserAggregateArgs>): Prisma.PrismaPromise<GetAdminUserAggregateType<T>>

    /**
     * Group by AdminUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminUserGroupByArgs['orderBy'] }
        : { orderBy?: AdminUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminUser model
   */
  readonly fields: AdminUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminUser model
   */
  interface AdminUserFieldRefs {
    readonly id: FieldRef<"AdminUser", 'String'>
    readonly email: FieldRef<"AdminUser", 'String'>
    readonly name: FieldRef<"AdminUser", 'String'>
    readonly password: FieldRef<"AdminUser", 'String'>
    readonly role: FieldRef<"AdminUser", 'String'>
    readonly createdAt: FieldRef<"AdminUser", 'DateTime'>
    readonly updatedAt: FieldRef<"AdminUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminUser findUnique
   */
  export type AdminUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findUniqueOrThrow
   */
  export type AdminUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser findFirst
   */
  export type AdminUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findFirstOrThrow
   */
  export type AdminUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Filter, which AdminUser to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminUsers.
     */
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser findMany
   */
  export type AdminUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Filter, which AdminUsers to fetch.
     */
    where?: AdminUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminUsers to fetch.
     */
    orderBy?: AdminUserOrderByWithRelationInput | AdminUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminUsers.
     */
    cursor?: AdminUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminUsers.
     */
    skip?: number
    distinct?: AdminUserScalarFieldEnum | AdminUserScalarFieldEnum[]
  }

  /**
   * AdminUser create
   */
  export type AdminUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The data needed to create a AdminUser.
     */
    data: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
  }

  /**
   * AdminUser createMany
   */
  export type AdminUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUser createManyAndReturn
   */
  export type AdminUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The data used to create many AdminUsers.
     */
    data: AdminUserCreateManyInput | AdminUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminUser update
   */
  export type AdminUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The data needed to update a AdminUser.
     */
    data: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
    /**
     * Choose, which AdminUser to update.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser updateMany
   */
  export type AdminUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to update.
     */
    limit?: number
  }

  /**
   * AdminUser updateManyAndReturn
   */
  export type AdminUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The data used to update AdminUsers.
     */
    data: XOR<AdminUserUpdateManyMutationInput, AdminUserUncheckedUpdateManyInput>
    /**
     * Filter which AdminUsers to update
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to update.
     */
    limit?: number
  }

  /**
   * AdminUser upsert
   */
  export type AdminUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * The filter to search for the AdminUser to update in case it exists.
     */
    where: AdminUserWhereUniqueInput
    /**
     * In case the AdminUser found by the `where` argument doesn't exist, create a new AdminUser with this data.
     */
    create: XOR<AdminUserCreateInput, AdminUserUncheckedCreateInput>
    /**
     * In case the AdminUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminUserUpdateInput, AdminUserUncheckedUpdateInput>
  }

  /**
   * AdminUser delete
   */
  export type AdminUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
    /**
     * Filter which AdminUser to delete.
     */
    where: AdminUserWhereUniqueInput
  }

  /**
   * AdminUser deleteMany
   */
  export type AdminUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminUsers to delete
     */
    where?: AdminUserWhereInput
    /**
     * Limit how many AdminUsers to delete.
     */
    limit?: number
  }

  /**
   * AdminUser without action
   */
  export type AdminUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminUser
     */
    select?: AdminUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AdminUser
     */
    omit?: AdminUserOmit<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    provider: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    userId: number
    provider: number
    credentials: number
    createdAt: number
    updatedAt: number
    workspaceId: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    userId?: true
    provider?: true
    credentials?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    userId: string
    provider: string
    credentials: JsonValue
    createdAt: Date
    updatedAt: Date
    workspaceId: string
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    credentials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    credentials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    provider?: boolean
    credentials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectScalar = {
    id?: boolean
    userId?: boolean
    provider?: boolean
    credentials?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
  }

  export type IntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "provider" | "credentials" | "createdAt" | "updatedAt" | "workspaceId", ExtArgs["result"]["integration"]>
  export type IntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
      workspaces: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      provider: string
      credentials: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
      workspaceId: string
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations and returns the data updated in the database.
     * @param {IntegrationUpdateManyAndReturnArgs} args - Arguments to update many Integrations.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, IntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspaces<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly userId: FieldRef<"Integration", 'String'>
    readonly provider: FieldRef<"Integration", 'String'>
    readonly credentials: FieldRef<"Integration", 'Json'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
    readonly updatedAt: FieldRef<"Integration", 'DateTime'>
    readonly workspaceId: FieldRef<"Integration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration createManyAndReturn
   */
  export type IntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
  }

  /**
   * Integration updateManyAndReturn
   */
  export type IntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to delete.
     */
    limit?: number
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    frequencyPenalty: number | null
    maxMessages: number | null
    maxTokens: number | null
    presencePenalty: number | null
    temperature: number | null
  }

  export type AgentSumAggregateOutputType = {
    frequencyPenalty: number | null
    maxMessages: number | null
    maxTokens: number | null
    presencePenalty: number | null
    temperature: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    systemPrompt: string | null
    createdAt: Date | null
    updatedAt: Date | null
    agentFunction: string | null
    agentSkills: string | null
    assistantId: string | null
    companyDescription: string | null
    companyName: string | null
    companySector: string | null
    companyWebsite: string | null
    frequencyPenalty: number | null
    imageUrl: string | null
    initialMessage: string | null
    internalName: string | null
    language: string | null
    maxMessages: number | null
    maxTokens: number | null
    model: string | null
    personalityObjective: string | null
    presencePenalty: number | null
    productInfo: string | null
    responseFormat: string | null
    restrictions: string | null
    temperature: number | null
    timezone: string | null
    vectorStoreId: string | null
    voiceTone: string | null
    openaiApiKey: string | null
    userId: string | null
    workspaceId: string | null
  }

  export type AgentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    systemPrompt: string | null
    createdAt: Date | null
    updatedAt: Date | null
    agentFunction: string | null
    agentSkills: string | null
    assistantId: string | null
    companyDescription: string | null
    companyName: string | null
    companySector: string | null
    companyWebsite: string | null
    frequencyPenalty: number | null
    imageUrl: string | null
    initialMessage: string | null
    internalName: string | null
    language: string | null
    maxMessages: number | null
    maxTokens: number | null
    model: string | null
    personalityObjective: string | null
    presencePenalty: number | null
    productInfo: string | null
    responseFormat: string | null
    restrictions: string | null
    temperature: number | null
    timezone: string | null
    vectorStoreId: string | null
    voiceTone: string | null
    openaiApiKey: string | null
    userId: string | null
    workspaceId: string | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    systemPrompt: number
    createdAt: number
    updatedAt: number
    agentFunction: number
    agentSkills: number
    assistantId: number
    companyDescription: number
    companyName: number
    companySector: number
    companyWebsite: number
    frequencyPenalty: number
    imageUrl: number
    initialMessage: number
    internalName: number
    language: number
    maxMessages: number
    maxTokens: number
    model: number
    personalityObjective: number
    presencePenalty: number
    productInfo: number
    responseFormat: number
    restrictions: number
    temperature: number
    timezone: number
    vectorStoreId: number
    voiceTone: number
    openaiApiKey: number
    userId: number
    workspaceId: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    frequencyPenalty?: true
    maxMessages?: true
    maxTokens?: true
    presencePenalty?: true
    temperature?: true
  }

  export type AgentSumAggregateInputType = {
    frequencyPenalty?: true
    maxMessages?: true
    maxTokens?: true
    presencePenalty?: true
    temperature?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    systemPrompt?: true
    createdAt?: true
    updatedAt?: true
    agentFunction?: true
    agentSkills?: true
    assistantId?: true
    companyDescription?: true
    companyName?: true
    companySector?: true
    companyWebsite?: true
    frequencyPenalty?: true
    imageUrl?: true
    initialMessage?: true
    internalName?: true
    language?: true
    maxMessages?: true
    maxTokens?: true
    model?: true
    personalityObjective?: true
    presencePenalty?: true
    productInfo?: true
    responseFormat?: true
    restrictions?: true
    temperature?: true
    timezone?: true
    vectorStoreId?: true
    voiceTone?: true
    openaiApiKey?: true
    userId?: true
    workspaceId?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    systemPrompt?: true
    createdAt?: true
    updatedAt?: true
    agentFunction?: true
    agentSkills?: true
    assistantId?: true
    companyDescription?: true
    companyName?: true
    companySector?: true
    companyWebsite?: true
    frequencyPenalty?: true
    imageUrl?: true
    initialMessage?: true
    internalName?: true
    language?: true
    maxMessages?: true
    maxTokens?: true
    model?: true
    personalityObjective?: true
    presencePenalty?: true
    productInfo?: true
    responseFormat?: true
    restrictions?: true
    temperature?: true
    timezone?: true
    vectorStoreId?: true
    voiceTone?: true
    openaiApiKey?: true
    userId?: true
    workspaceId?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    systemPrompt?: true
    createdAt?: true
    updatedAt?: true
    agentFunction?: true
    agentSkills?: true
    assistantId?: true
    companyDescription?: true
    companyName?: true
    companySector?: true
    companyWebsite?: true
    frequencyPenalty?: true
    imageUrl?: true
    initialMessage?: true
    internalName?: true
    language?: true
    maxMessages?: true
    maxTokens?: true
    model?: true
    personalityObjective?: true
    presencePenalty?: true
    productInfo?: true
    responseFormat?: true
    restrictions?: true
    temperature?: true
    timezone?: true
    vectorStoreId?: true
    voiceTone?: true
    openaiApiKey?: true
    userId?: true
    workspaceId?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    systemPrompt: string | null
    createdAt: Date
    updatedAt: Date
    agentFunction: string | null
    agentSkills: string | null
    assistantId: string | null
    companyDescription: string | null
    companyName: string | null
    companySector: string | null
    companyWebsite: string | null
    frequencyPenalty: number | null
    imageUrl: string | null
    initialMessage: string | null
    internalName: string | null
    language: string | null
    maxMessages: number | null
    maxTokens: number | null
    model: string | null
    personalityObjective: string | null
    presencePenalty: number | null
    productInfo: string | null
    responseFormat: string | null
    restrictions: string | null
    temperature: number | null
    timezone: string | null
    vectorStoreId: string | null
    voiceTone: string | null
    openaiApiKey: string | null
    userId: string
    workspaceId: string
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentFunction?: boolean
    agentSkills?: boolean
    assistantId?: boolean
    companyDescription?: boolean
    companyName?: boolean
    companySector?: boolean
    companyWebsite?: boolean
    frequencyPenalty?: boolean
    imageUrl?: boolean
    initialMessage?: boolean
    internalName?: boolean
    language?: boolean
    maxMessages?: boolean
    maxTokens?: boolean
    model?: boolean
    personalityObjective?: boolean
    presencePenalty?: boolean
    productInfo?: boolean
    responseFormat?: boolean
    restrictions?: boolean
    temperature?: boolean
    timezone?: boolean
    vectorStoreId?: boolean
    voiceTone?: boolean
    openaiApiKey?: boolean
    userId?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    disparaJaConnections?: boolean | Agent$disparaJaConnectionsArgs<ExtArgs>
    whatsappCloudConnections?: boolean | Agent$whatsappCloudConnectionsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentFunction?: boolean
    agentSkills?: boolean
    assistantId?: boolean
    companyDescription?: boolean
    companyName?: boolean
    companySector?: boolean
    companyWebsite?: boolean
    frequencyPenalty?: boolean
    imageUrl?: boolean
    initialMessage?: boolean
    internalName?: boolean
    language?: boolean
    maxMessages?: boolean
    maxTokens?: boolean
    model?: boolean
    personalityObjective?: boolean
    presencePenalty?: boolean
    productInfo?: boolean
    responseFormat?: boolean
    restrictions?: boolean
    temperature?: boolean
    timezone?: boolean
    vectorStoreId?: boolean
    voiceTone?: boolean
    openaiApiKey?: boolean
    userId?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentFunction?: boolean
    agentSkills?: boolean
    assistantId?: boolean
    companyDescription?: boolean
    companyName?: boolean
    companySector?: boolean
    companyWebsite?: boolean
    frequencyPenalty?: boolean
    imageUrl?: boolean
    initialMessage?: boolean
    internalName?: boolean
    language?: boolean
    maxMessages?: boolean
    maxTokens?: boolean
    model?: boolean
    personalityObjective?: boolean
    presencePenalty?: boolean
    productInfo?: boolean
    responseFormat?: boolean
    restrictions?: boolean
    temperature?: boolean
    timezone?: boolean
    vectorStoreId?: boolean
    voiceTone?: boolean
    openaiApiKey?: boolean
    userId?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    systemPrompt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    agentFunction?: boolean
    agentSkills?: boolean
    assistantId?: boolean
    companyDescription?: boolean
    companyName?: boolean
    companySector?: boolean
    companyWebsite?: boolean
    frequencyPenalty?: boolean
    imageUrl?: boolean
    initialMessage?: boolean
    internalName?: boolean
    language?: boolean
    maxMessages?: boolean
    maxTokens?: boolean
    model?: boolean
    personalityObjective?: boolean
    presencePenalty?: boolean
    productInfo?: boolean
    responseFormat?: boolean
    restrictions?: boolean
    temperature?: boolean
    timezone?: boolean
    vectorStoreId?: boolean
    voiceTone?: boolean
    openaiApiKey?: boolean
    userId?: boolean
    workspaceId?: boolean
  }

  export type AgentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "systemPrompt" | "createdAt" | "updatedAt" | "agentFunction" | "agentSkills" | "assistantId" | "companyDescription" | "companyName" | "companySector" | "companyWebsite" | "frequencyPenalty" | "imageUrl" | "initialMessage" | "internalName" | "language" | "maxMessages" | "maxTokens" | "model" | "personalityObjective" | "presencePenalty" | "productInfo" | "responseFormat" | "restrictions" | "temperature" | "timezone" | "vectorStoreId" | "voiceTone" | "openaiApiKey" | "userId" | "workspaceId", ExtArgs["result"]["agent"]>
  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    disparaJaConnections?: boolean | Agent$disparaJaConnectionsArgs<ExtArgs>
    whatsappCloudConnections?: boolean | Agent$whatsappCloudConnectionsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type AgentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      disparaJaConnections: Prisma.$DisparaJaConnectionPayload<ExtArgs>[]
      whatsappCloudConnections: Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      systemPrompt: string | null
      createdAt: Date
      updatedAt: Date
      agentFunction: string | null
      agentSkills: string | null
      assistantId: string | null
      companyDescription: string | null
      companyName: string | null
      companySector: string | null
      companyWebsite: string | null
      frequencyPenalty: number | null
      imageUrl: string | null
      initialMessage: string | null
      internalName: string | null
      language: string | null
      maxMessages: number | null
      maxTokens: number | null
      model: string | null
      personalityObjective: string | null
      presencePenalty: number | null
      productInfo: string | null
      responseFormat: string | null
      restrictions: string | null
      temperature: number | null
      timezone: string | null
      vectorStoreId: string | null
      voiceTone: string | null
      openaiApiKey: string | null
      userId: string
      workspaceId: string
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents and returns the data updated in the database.
     * @param {AgentUpdateManyAndReturnArgs} args - Arguments to update many Agents.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AgentUpdateManyAndReturnArgs>(args: SelectSubset<T, AgentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    disparaJaConnections<T extends Agent$disparaJaConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$disparaJaConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    whatsappCloudConnections<T extends Agent$whatsappCloudConnectionsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$whatsappCloudConnectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'String'>
    readonly name: FieldRef<"Agent", 'String'>
    readonly description: FieldRef<"Agent", 'String'>
    readonly systemPrompt: FieldRef<"Agent", 'String'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
    readonly agentFunction: FieldRef<"Agent", 'String'>
    readonly agentSkills: FieldRef<"Agent", 'String'>
    readonly assistantId: FieldRef<"Agent", 'String'>
    readonly companyDescription: FieldRef<"Agent", 'String'>
    readonly companyName: FieldRef<"Agent", 'String'>
    readonly companySector: FieldRef<"Agent", 'String'>
    readonly companyWebsite: FieldRef<"Agent", 'String'>
    readonly frequencyPenalty: FieldRef<"Agent", 'Float'>
    readonly imageUrl: FieldRef<"Agent", 'String'>
    readonly initialMessage: FieldRef<"Agent", 'String'>
    readonly internalName: FieldRef<"Agent", 'String'>
    readonly language: FieldRef<"Agent", 'String'>
    readonly maxMessages: FieldRef<"Agent", 'Int'>
    readonly maxTokens: FieldRef<"Agent", 'Int'>
    readonly model: FieldRef<"Agent", 'String'>
    readonly personalityObjective: FieldRef<"Agent", 'String'>
    readonly presencePenalty: FieldRef<"Agent", 'Float'>
    readonly productInfo: FieldRef<"Agent", 'String'>
    readonly responseFormat: FieldRef<"Agent", 'String'>
    readonly restrictions: FieldRef<"Agent", 'String'>
    readonly temperature: FieldRef<"Agent", 'Float'>
    readonly timezone: FieldRef<"Agent", 'String'>
    readonly vectorStoreId: FieldRef<"Agent", 'String'>
    readonly voiceTone: FieldRef<"Agent", 'String'>
    readonly openaiApiKey: FieldRef<"Agent", 'String'>
    readonly userId: FieldRef<"Agent", 'String'>
    readonly workspaceId: FieldRef<"Agent", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
  }

  /**
   * Agent updateManyAndReturn
   */
  export type AgentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
    /**
     * Limit how many Agents to delete.
     */
    limit?: number
  }

  /**
   * Agent.disparaJaConnections
   */
  export type Agent$disparaJaConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    where?: DisparaJaConnectionWhereInput
    orderBy?: DisparaJaConnectionOrderByWithRelationInput | DisparaJaConnectionOrderByWithRelationInput[]
    cursor?: DisparaJaConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisparaJaConnectionScalarFieldEnum | DisparaJaConnectionScalarFieldEnum[]
  }

  /**
   * Agent.whatsappCloudConnections
   */
  export type Agent$whatsappCloudConnectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    where?: WhatsAppCloudConnectionWhereInput
    orderBy?: WhatsAppCloudConnectionOrderByWithRelationInput | WhatsAppCloudConnectionOrderByWithRelationInput[]
    cursor?: WhatsAppCloudConnectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhatsAppCloudConnectionScalarFieldEnum | WhatsAppCloudConnectionScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Agent
     */
    omit?: AgentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    fileId: string | null
    filename: string | null
    purpose: string | null
    size: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    fileId: string | null
    filename: string | null
    purpose: string | null
    size: number | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    fileId: number
    filename: number
    purpose: number
    size: number
    type: number
    createdAt: number
    updatedAt: number
    workspaceId: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    size?: true
  }

  export type FileSumAggregateInputType = {
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    fileId?: true
    filename?: true
    purpose?: true
    size?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    fileId?: true
    filename?: true
    purpose?: true
    size?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    fileId?: true
    filename?: true
    purpose?: true
    size?: true
    type?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    fileId: string
    filename: string
    purpose: string
    size: number
    type: string | null
    createdAt: Date
    updatedAt: Date
    workspaceId: string
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    filename?: boolean
    purpose?: boolean
    size?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    filename?: boolean
    purpose?: boolean
    size?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    filename?: boolean
    purpose?: boolean
    size?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    fileId?: boolean
    filename?: boolean
    purpose?: boolean
    size?: boolean
    type?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileId" | "filename" | "purpose" | "size" | "type" | "createdAt" | "updatedAt" | "workspaceId", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileId: string
      filename: string
      purpose: string
      size: number
      type: string | null
      createdAt: Date
      updatedAt: Date
      workspaceId: string
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly fileId: FieldRef<"File", 'String'>
    readonly filename: FieldRef<"File", 'String'>
    readonly purpose: FieldRef<"File", 'String'>
    readonly size: FieldRef<"File", 'Int'>
    readonly type: FieldRef<"File", 'String'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
    readonly workspaceId: FieldRef<"File", 'String'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Model VectorStore
   */

  export type AggregateVectorStore = {
    _count: VectorStoreCountAggregateOutputType | null
    _min: VectorStoreMinAggregateOutputType | null
    _max: VectorStoreMaxAggregateOutputType | null
  }

  export type VectorStoreMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    openaiId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type VectorStoreMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    openaiId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type VectorStoreCountAggregateOutputType = {
    id: number
    name: number
    description: number
    openaiId: number
    files: number
    createdAt: number
    updatedAt: number
    workspaceId: number
    _all: number
  }


  export type VectorStoreMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    openaiId?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type VectorStoreMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    openaiId?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type VectorStoreCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    openaiId?: true
    files?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
    _all?: true
  }

  export type VectorStoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VectorStore to aggregate.
     */
    where?: VectorStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VectorStores to fetch.
     */
    orderBy?: VectorStoreOrderByWithRelationInput | VectorStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VectorStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VectorStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VectorStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VectorStores
    **/
    _count?: true | VectorStoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VectorStoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VectorStoreMaxAggregateInputType
  }

  export type GetVectorStoreAggregateType<T extends VectorStoreAggregateArgs> = {
        [P in keyof T & keyof AggregateVectorStore]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVectorStore[P]>
      : GetScalarType<T[P], AggregateVectorStore[P]>
  }




  export type VectorStoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VectorStoreWhereInput
    orderBy?: VectorStoreOrderByWithAggregationInput | VectorStoreOrderByWithAggregationInput[]
    by: VectorStoreScalarFieldEnum[] | VectorStoreScalarFieldEnum
    having?: VectorStoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VectorStoreCountAggregateInputType | true
    _min?: VectorStoreMinAggregateInputType
    _max?: VectorStoreMaxAggregateInputType
  }

  export type VectorStoreGroupByOutputType = {
    id: string
    name: string
    description: string | null
    openaiId: string
    files: JsonValue | null
    createdAt: Date
    updatedAt: Date
    workspaceId: string
    _count: VectorStoreCountAggregateOutputType | null
    _min: VectorStoreMinAggregateOutputType | null
    _max: VectorStoreMaxAggregateOutputType | null
  }

  type GetVectorStoreGroupByPayload<T extends VectorStoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VectorStoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VectorStoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VectorStoreGroupByOutputType[P]>
            : GetScalarType<T[P], VectorStoreGroupByOutputType[P]>
        }
      >
    >


  export type VectorStoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    openaiId?: boolean
    files?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vectorStore"]>

  export type VectorStoreSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    openaiId?: boolean
    files?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vectorStore"]>

  export type VectorStoreSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    openaiId?: boolean
    files?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vectorStore"]>

  export type VectorStoreSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    openaiId?: boolean
    files?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
  }

  export type VectorStoreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "openaiId" | "files" | "createdAt" | "updatedAt" | "workspaceId", ExtArgs["result"]["vectorStore"]>
  export type VectorStoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type VectorStoreIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type VectorStoreIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $VectorStorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VectorStore"
    objects: {
      workspaces: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      openaiId: string
      files: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      workspaceId: string
    }, ExtArgs["result"]["vectorStore"]>
    composites: {}
  }

  type VectorStoreGetPayload<S extends boolean | null | undefined | VectorStoreDefaultArgs> = $Result.GetResult<Prisma.$VectorStorePayload, S>

  type VectorStoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VectorStoreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VectorStoreCountAggregateInputType | true
    }

  export interface VectorStoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VectorStore'], meta: { name: 'VectorStore' } }
    /**
     * Find zero or one VectorStore that matches the filter.
     * @param {VectorStoreFindUniqueArgs} args - Arguments to find a VectorStore
     * @example
     * // Get one VectorStore
     * const vectorStore = await prisma.vectorStore.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VectorStoreFindUniqueArgs>(args: SelectSubset<T, VectorStoreFindUniqueArgs<ExtArgs>>): Prisma__VectorStoreClient<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VectorStore that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VectorStoreFindUniqueOrThrowArgs} args - Arguments to find a VectorStore
     * @example
     * // Get one VectorStore
     * const vectorStore = await prisma.vectorStore.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VectorStoreFindUniqueOrThrowArgs>(args: SelectSubset<T, VectorStoreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VectorStoreClient<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VectorStore that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorStoreFindFirstArgs} args - Arguments to find a VectorStore
     * @example
     * // Get one VectorStore
     * const vectorStore = await prisma.vectorStore.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VectorStoreFindFirstArgs>(args?: SelectSubset<T, VectorStoreFindFirstArgs<ExtArgs>>): Prisma__VectorStoreClient<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VectorStore that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorStoreFindFirstOrThrowArgs} args - Arguments to find a VectorStore
     * @example
     * // Get one VectorStore
     * const vectorStore = await prisma.vectorStore.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VectorStoreFindFirstOrThrowArgs>(args?: SelectSubset<T, VectorStoreFindFirstOrThrowArgs<ExtArgs>>): Prisma__VectorStoreClient<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VectorStores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorStoreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VectorStores
     * const vectorStores = await prisma.vectorStore.findMany()
     * 
     * // Get first 10 VectorStores
     * const vectorStores = await prisma.vectorStore.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vectorStoreWithIdOnly = await prisma.vectorStore.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VectorStoreFindManyArgs>(args?: SelectSubset<T, VectorStoreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VectorStore.
     * @param {VectorStoreCreateArgs} args - Arguments to create a VectorStore.
     * @example
     * // Create one VectorStore
     * const VectorStore = await prisma.vectorStore.create({
     *   data: {
     *     // ... data to create a VectorStore
     *   }
     * })
     * 
     */
    create<T extends VectorStoreCreateArgs>(args: SelectSubset<T, VectorStoreCreateArgs<ExtArgs>>): Prisma__VectorStoreClient<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VectorStores.
     * @param {VectorStoreCreateManyArgs} args - Arguments to create many VectorStores.
     * @example
     * // Create many VectorStores
     * const vectorStore = await prisma.vectorStore.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VectorStoreCreateManyArgs>(args?: SelectSubset<T, VectorStoreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VectorStores and returns the data saved in the database.
     * @param {VectorStoreCreateManyAndReturnArgs} args - Arguments to create many VectorStores.
     * @example
     * // Create many VectorStores
     * const vectorStore = await prisma.vectorStore.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VectorStores and only return the `id`
     * const vectorStoreWithIdOnly = await prisma.vectorStore.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VectorStoreCreateManyAndReturnArgs>(args?: SelectSubset<T, VectorStoreCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VectorStore.
     * @param {VectorStoreDeleteArgs} args - Arguments to delete one VectorStore.
     * @example
     * // Delete one VectorStore
     * const VectorStore = await prisma.vectorStore.delete({
     *   where: {
     *     // ... filter to delete one VectorStore
     *   }
     * })
     * 
     */
    delete<T extends VectorStoreDeleteArgs>(args: SelectSubset<T, VectorStoreDeleteArgs<ExtArgs>>): Prisma__VectorStoreClient<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VectorStore.
     * @param {VectorStoreUpdateArgs} args - Arguments to update one VectorStore.
     * @example
     * // Update one VectorStore
     * const vectorStore = await prisma.vectorStore.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VectorStoreUpdateArgs>(args: SelectSubset<T, VectorStoreUpdateArgs<ExtArgs>>): Prisma__VectorStoreClient<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VectorStores.
     * @param {VectorStoreDeleteManyArgs} args - Arguments to filter VectorStores to delete.
     * @example
     * // Delete a few VectorStores
     * const { count } = await prisma.vectorStore.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VectorStoreDeleteManyArgs>(args?: SelectSubset<T, VectorStoreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VectorStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorStoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VectorStores
     * const vectorStore = await prisma.vectorStore.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VectorStoreUpdateManyArgs>(args: SelectSubset<T, VectorStoreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VectorStores and returns the data updated in the database.
     * @param {VectorStoreUpdateManyAndReturnArgs} args - Arguments to update many VectorStores.
     * @example
     * // Update many VectorStores
     * const vectorStore = await prisma.vectorStore.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VectorStores and only return the `id`
     * const vectorStoreWithIdOnly = await prisma.vectorStore.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VectorStoreUpdateManyAndReturnArgs>(args: SelectSubset<T, VectorStoreUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VectorStore.
     * @param {VectorStoreUpsertArgs} args - Arguments to update or create a VectorStore.
     * @example
     * // Update or create a VectorStore
     * const vectorStore = await prisma.vectorStore.upsert({
     *   create: {
     *     // ... data to create a VectorStore
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VectorStore we want to update
     *   }
     * })
     */
    upsert<T extends VectorStoreUpsertArgs>(args: SelectSubset<T, VectorStoreUpsertArgs<ExtArgs>>): Prisma__VectorStoreClient<$Result.GetResult<Prisma.$VectorStorePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VectorStores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorStoreCountArgs} args - Arguments to filter VectorStores to count.
     * @example
     * // Count the number of VectorStores
     * const count = await prisma.vectorStore.count({
     *   where: {
     *     // ... the filter for the VectorStores we want to count
     *   }
     * })
    **/
    count<T extends VectorStoreCountArgs>(
      args?: Subset<T, VectorStoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VectorStoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VectorStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorStoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VectorStoreAggregateArgs>(args: Subset<T, VectorStoreAggregateArgs>): Prisma.PrismaPromise<GetVectorStoreAggregateType<T>>

    /**
     * Group by VectorStore.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VectorStoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VectorStoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VectorStoreGroupByArgs['orderBy'] }
        : { orderBy?: VectorStoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VectorStoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVectorStoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VectorStore model
   */
  readonly fields: VectorStoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VectorStore.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VectorStoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaces<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VectorStore model
   */
  interface VectorStoreFieldRefs {
    readonly id: FieldRef<"VectorStore", 'String'>
    readonly name: FieldRef<"VectorStore", 'String'>
    readonly description: FieldRef<"VectorStore", 'String'>
    readonly openaiId: FieldRef<"VectorStore", 'String'>
    readonly files: FieldRef<"VectorStore", 'Json'>
    readonly createdAt: FieldRef<"VectorStore", 'DateTime'>
    readonly updatedAt: FieldRef<"VectorStore", 'DateTime'>
    readonly workspaceId: FieldRef<"VectorStore", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VectorStore findUnique
   */
  export type VectorStoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
    /**
     * Filter, which VectorStore to fetch.
     */
    where: VectorStoreWhereUniqueInput
  }

  /**
   * VectorStore findUniqueOrThrow
   */
  export type VectorStoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
    /**
     * Filter, which VectorStore to fetch.
     */
    where: VectorStoreWhereUniqueInput
  }

  /**
   * VectorStore findFirst
   */
  export type VectorStoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
    /**
     * Filter, which VectorStore to fetch.
     */
    where?: VectorStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VectorStores to fetch.
     */
    orderBy?: VectorStoreOrderByWithRelationInput | VectorStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VectorStores.
     */
    cursor?: VectorStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VectorStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VectorStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VectorStores.
     */
    distinct?: VectorStoreScalarFieldEnum | VectorStoreScalarFieldEnum[]
  }

  /**
   * VectorStore findFirstOrThrow
   */
  export type VectorStoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
    /**
     * Filter, which VectorStore to fetch.
     */
    where?: VectorStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VectorStores to fetch.
     */
    orderBy?: VectorStoreOrderByWithRelationInput | VectorStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VectorStores.
     */
    cursor?: VectorStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VectorStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VectorStores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VectorStores.
     */
    distinct?: VectorStoreScalarFieldEnum | VectorStoreScalarFieldEnum[]
  }

  /**
   * VectorStore findMany
   */
  export type VectorStoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
    /**
     * Filter, which VectorStores to fetch.
     */
    where?: VectorStoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VectorStores to fetch.
     */
    orderBy?: VectorStoreOrderByWithRelationInput | VectorStoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VectorStores.
     */
    cursor?: VectorStoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VectorStores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VectorStores.
     */
    skip?: number
    distinct?: VectorStoreScalarFieldEnum | VectorStoreScalarFieldEnum[]
  }

  /**
   * VectorStore create
   */
  export type VectorStoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
    /**
     * The data needed to create a VectorStore.
     */
    data: XOR<VectorStoreCreateInput, VectorStoreUncheckedCreateInput>
  }

  /**
   * VectorStore createMany
   */
  export type VectorStoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VectorStores.
     */
    data: VectorStoreCreateManyInput | VectorStoreCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VectorStore createManyAndReturn
   */
  export type VectorStoreCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * The data used to create many VectorStores.
     */
    data: VectorStoreCreateManyInput | VectorStoreCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VectorStore update
   */
  export type VectorStoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
    /**
     * The data needed to update a VectorStore.
     */
    data: XOR<VectorStoreUpdateInput, VectorStoreUncheckedUpdateInput>
    /**
     * Choose, which VectorStore to update.
     */
    where: VectorStoreWhereUniqueInput
  }

  /**
   * VectorStore updateMany
   */
  export type VectorStoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VectorStores.
     */
    data: XOR<VectorStoreUpdateManyMutationInput, VectorStoreUncheckedUpdateManyInput>
    /**
     * Filter which VectorStores to update
     */
    where?: VectorStoreWhereInput
    /**
     * Limit how many VectorStores to update.
     */
    limit?: number
  }

  /**
   * VectorStore updateManyAndReturn
   */
  export type VectorStoreUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * The data used to update VectorStores.
     */
    data: XOR<VectorStoreUpdateManyMutationInput, VectorStoreUncheckedUpdateManyInput>
    /**
     * Filter which VectorStores to update
     */
    where?: VectorStoreWhereInput
    /**
     * Limit how many VectorStores to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VectorStore upsert
   */
  export type VectorStoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
    /**
     * The filter to search for the VectorStore to update in case it exists.
     */
    where: VectorStoreWhereUniqueInput
    /**
     * In case the VectorStore found by the `where` argument doesn't exist, create a new VectorStore with this data.
     */
    create: XOR<VectorStoreCreateInput, VectorStoreUncheckedCreateInput>
    /**
     * In case the VectorStore was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VectorStoreUpdateInput, VectorStoreUncheckedUpdateInput>
  }

  /**
   * VectorStore delete
   */
  export type VectorStoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
    /**
     * Filter which VectorStore to delete.
     */
    where: VectorStoreWhereUniqueInput
  }

  /**
   * VectorStore deleteMany
   */
  export type VectorStoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VectorStores to delete
     */
    where?: VectorStoreWhereInput
    /**
     * Limit how many VectorStores to delete.
     */
    limit?: number
  }

  /**
   * VectorStore without action
   */
  export type VectorStoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VectorStore
     */
    select?: VectorStoreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VectorStore
     */
    omit?: VectorStoreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VectorStoreInclude<ExtArgs> | null
  }


  /**
   * Model ContactField
   */

  export type AggregateContactField = {
    _count: ContactFieldCountAggregateOutputType | null
    _avg: ContactFieldAvgAggregateOutputType | null
    _sum: ContactFieldSumAggregateOutputType | null
    _min: ContactFieldMinAggregateOutputType | null
    _max: ContactFieldMaxAggregateOutputType | null
  }

  export type ContactFieldAvgAggregateOutputType = {
    order: number | null
  }

  export type ContactFieldSumAggregateOutputType = {
    order: number | null
  }

  export type ContactFieldMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    required: boolean | null
    placeholder: string | null
    default_value: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type ContactFieldMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: string | null
    required: boolean | null
    placeholder: string | null
    default_value: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type ContactFieldCountAggregateOutputType = {
    id: number
    name: number
    type: number
    required: number
    options: number
    placeholder: number
    default_value: number
    description: number
    order: number
    createdAt: number
    updatedAt: number
    workspaceId: number
    _all: number
  }


  export type ContactFieldAvgAggregateInputType = {
    order?: true
  }

  export type ContactFieldSumAggregateInputType = {
    order?: true
  }

  export type ContactFieldMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    required?: true
    placeholder?: true
    default_value?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type ContactFieldMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    required?: true
    placeholder?: true
    default_value?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type ContactFieldCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    required?: true
    options?: true
    placeholder?: true
    default_value?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
    _all?: true
  }

  export type ContactFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactField to aggregate.
     */
    where?: ContactFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFields to fetch.
     */
    orderBy?: ContactFieldOrderByWithRelationInput | ContactFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactFields
    **/
    _count?: true | ContactFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactFieldMaxAggregateInputType
  }

  export type GetContactFieldAggregateType<T extends ContactFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateContactField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactField[P]>
      : GetScalarType<T[P], AggregateContactField[P]>
  }




  export type ContactFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactFieldWhereInput
    orderBy?: ContactFieldOrderByWithAggregationInput | ContactFieldOrderByWithAggregationInput[]
    by: ContactFieldScalarFieldEnum[] | ContactFieldScalarFieldEnum
    having?: ContactFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactFieldCountAggregateInputType | true
    _avg?: ContactFieldAvgAggregateInputType
    _sum?: ContactFieldSumAggregateInputType
    _min?: ContactFieldMinAggregateInputType
    _max?: ContactFieldMaxAggregateInputType
  }

  export type ContactFieldGroupByOutputType = {
    id: string
    name: string
    type: string
    required: boolean
    options: string[]
    placeholder: string | null
    default_value: string | null
    description: string | null
    order: number
    createdAt: Date
    updatedAt: Date
    workspaceId: string
    _count: ContactFieldCountAggregateOutputType | null
    _avg: ContactFieldAvgAggregateOutputType | null
    _sum: ContactFieldSumAggregateOutputType | null
    _min: ContactFieldMinAggregateOutputType | null
    _max: ContactFieldMaxAggregateOutputType | null
  }

  type GetContactFieldGroupByPayload<T extends ContactFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactFieldGroupByOutputType[P]>
            : GetScalarType<T[P], ContactFieldGroupByOutputType[P]>
        }
      >
    >


  export type ContactFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    required?: boolean
    options?: boolean
    placeholder?: boolean
    default_value?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactField"]>

  export type ContactFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    required?: boolean
    options?: boolean
    placeholder?: boolean
    default_value?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactField"]>

  export type ContactFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    required?: boolean
    options?: boolean
    placeholder?: boolean
    default_value?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contactField"]>

  export type ContactFieldSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    required?: boolean
    options?: boolean
    placeholder?: boolean
    default_value?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
  }

  export type ContactFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "required" | "options" | "placeholder" | "default_value" | "description" | "order" | "createdAt" | "updatedAt" | "workspaceId", ExtArgs["result"]["contactField"]>
  export type ContactFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ContactFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ContactFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ContactFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactField"
    objects: {
      workspaces: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: string
      required: boolean
      options: string[]
      placeholder: string | null
      default_value: string | null
      description: string | null
      order: number
      createdAt: Date
      updatedAt: Date
      workspaceId: string
    }, ExtArgs["result"]["contactField"]>
    composites: {}
  }

  type ContactFieldGetPayload<S extends boolean | null | undefined | ContactFieldDefaultArgs> = $Result.GetResult<Prisma.$ContactFieldPayload, S>

  type ContactFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactFieldCountAggregateInputType | true
    }

  export interface ContactFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactField'], meta: { name: 'ContactField' } }
    /**
     * Find zero or one ContactField that matches the filter.
     * @param {ContactFieldFindUniqueArgs} args - Arguments to find a ContactField
     * @example
     * // Get one ContactField
     * const contactField = await prisma.contactField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFieldFindUniqueArgs>(args: SelectSubset<T, ContactFieldFindUniqueArgs<ExtArgs>>): Prisma__ContactFieldClient<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFieldFindUniqueOrThrowArgs} args - Arguments to find a ContactField
     * @example
     * // Get one ContactField
     * const contactField = await prisma.contactField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactFieldClient<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFieldFindFirstArgs} args - Arguments to find a ContactField
     * @example
     * // Get one ContactField
     * const contactField = await prisma.contactField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFieldFindFirstArgs>(args?: SelectSubset<T, ContactFieldFindFirstArgs<ExtArgs>>): Prisma__ContactFieldClient<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFieldFindFirstOrThrowArgs} args - Arguments to find a ContactField
     * @example
     * // Get one ContactField
     * const contactField = await prisma.contactField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactFieldClient<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactFields
     * const contactFields = await prisma.contactField.findMany()
     * 
     * // Get first 10 ContactFields
     * const contactFields = await prisma.contactField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactFieldWithIdOnly = await prisma.contactField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFieldFindManyArgs>(args?: SelectSubset<T, ContactFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactField.
     * @param {ContactFieldCreateArgs} args - Arguments to create a ContactField.
     * @example
     * // Create one ContactField
     * const ContactField = await prisma.contactField.create({
     *   data: {
     *     // ... data to create a ContactField
     *   }
     * })
     * 
     */
    create<T extends ContactFieldCreateArgs>(args: SelectSubset<T, ContactFieldCreateArgs<ExtArgs>>): Prisma__ContactFieldClient<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactFields.
     * @param {ContactFieldCreateManyArgs} args - Arguments to create many ContactFields.
     * @example
     * // Create many ContactFields
     * const contactField = await prisma.contactField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactFieldCreateManyArgs>(args?: SelectSubset<T, ContactFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactFields and returns the data saved in the database.
     * @param {ContactFieldCreateManyAndReturnArgs} args - Arguments to create many ContactFields.
     * @example
     * // Create many ContactFields
     * const contactField = await prisma.contactField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactFields and only return the `id`
     * const contactFieldWithIdOnly = await prisma.contactField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactField.
     * @param {ContactFieldDeleteArgs} args - Arguments to delete one ContactField.
     * @example
     * // Delete one ContactField
     * const ContactField = await prisma.contactField.delete({
     *   where: {
     *     // ... filter to delete one ContactField
     *   }
     * })
     * 
     */
    delete<T extends ContactFieldDeleteArgs>(args: SelectSubset<T, ContactFieldDeleteArgs<ExtArgs>>): Prisma__ContactFieldClient<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactField.
     * @param {ContactFieldUpdateArgs} args - Arguments to update one ContactField.
     * @example
     * // Update one ContactField
     * const contactField = await prisma.contactField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactFieldUpdateArgs>(args: SelectSubset<T, ContactFieldUpdateArgs<ExtArgs>>): Prisma__ContactFieldClient<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactFields.
     * @param {ContactFieldDeleteManyArgs} args - Arguments to filter ContactFields to delete.
     * @example
     * // Delete a few ContactFields
     * const { count } = await prisma.contactField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactFieldDeleteManyArgs>(args?: SelectSubset<T, ContactFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactFields
     * const contactField = await prisma.contactField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactFieldUpdateManyArgs>(args: SelectSubset<T, ContactFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactFields and returns the data updated in the database.
     * @param {ContactFieldUpdateManyAndReturnArgs} args - Arguments to update many ContactFields.
     * @example
     * // Update many ContactFields
     * const contactField = await prisma.contactField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactFields and only return the `id`
     * const contactFieldWithIdOnly = await prisma.contactField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactField.
     * @param {ContactFieldUpsertArgs} args - Arguments to update or create a ContactField.
     * @example
     * // Update or create a ContactField
     * const contactField = await prisma.contactField.upsert({
     *   create: {
     *     // ... data to create a ContactField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactField we want to update
     *   }
     * })
     */
    upsert<T extends ContactFieldUpsertArgs>(args: SelectSubset<T, ContactFieldUpsertArgs<ExtArgs>>): Prisma__ContactFieldClient<$Result.GetResult<Prisma.$ContactFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFieldCountArgs} args - Arguments to filter ContactFields to count.
     * @example
     * // Count the number of ContactFields
     * const count = await prisma.contactField.count({
     *   where: {
     *     // ... the filter for the ContactFields we want to count
     *   }
     * })
    **/
    count<T extends ContactFieldCountArgs>(
      args?: Subset<T, ContactFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactFieldAggregateArgs>(args: Subset<T, ContactFieldAggregateArgs>): Prisma.PrismaPromise<GetContactFieldAggregateType<T>>

    /**
     * Group by ContactField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactFieldGroupByArgs['orderBy'] }
        : { orderBy?: ContactFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactField model
   */
  readonly fields: ContactFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaces<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactField model
   */
  interface ContactFieldFieldRefs {
    readonly id: FieldRef<"ContactField", 'String'>
    readonly name: FieldRef<"ContactField", 'String'>
    readonly type: FieldRef<"ContactField", 'String'>
    readonly required: FieldRef<"ContactField", 'Boolean'>
    readonly options: FieldRef<"ContactField", 'String[]'>
    readonly placeholder: FieldRef<"ContactField", 'String'>
    readonly default_value: FieldRef<"ContactField", 'String'>
    readonly description: FieldRef<"ContactField", 'String'>
    readonly order: FieldRef<"ContactField", 'Int'>
    readonly createdAt: FieldRef<"ContactField", 'DateTime'>
    readonly updatedAt: FieldRef<"ContactField", 'DateTime'>
    readonly workspaceId: FieldRef<"ContactField", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ContactField findUnique
   */
  export type ContactFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
    /**
     * Filter, which ContactField to fetch.
     */
    where: ContactFieldWhereUniqueInput
  }

  /**
   * ContactField findUniqueOrThrow
   */
  export type ContactFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
    /**
     * Filter, which ContactField to fetch.
     */
    where: ContactFieldWhereUniqueInput
  }

  /**
   * ContactField findFirst
   */
  export type ContactFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
    /**
     * Filter, which ContactField to fetch.
     */
    where?: ContactFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFields to fetch.
     */
    orderBy?: ContactFieldOrderByWithRelationInput | ContactFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactFields.
     */
    cursor?: ContactFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactFields.
     */
    distinct?: ContactFieldScalarFieldEnum | ContactFieldScalarFieldEnum[]
  }

  /**
   * ContactField findFirstOrThrow
   */
  export type ContactFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
    /**
     * Filter, which ContactField to fetch.
     */
    where?: ContactFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFields to fetch.
     */
    orderBy?: ContactFieldOrderByWithRelationInput | ContactFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactFields.
     */
    cursor?: ContactFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactFields.
     */
    distinct?: ContactFieldScalarFieldEnum | ContactFieldScalarFieldEnum[]
  }

  /**
   * ContactField findMany
   */
  export type ContactFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
    /**
     * Filter, which ContactFields to fetch.
     */
    where?: ContactFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactFields to fetch.
     */
    orderBy?: ContactFieldOrderByWithRelationInput | ContactFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactFields.
     */
    cursor?: ContactFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactFields.
     */
    skip?: number
    distinct?: ContactFieldScalarFieldEnum | ContactFieldScalarFieldEnum[]
  }

  /**
   * ContactField create
   */
  export type ContactFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a ContactField.
     */
    data: XOR<ContactFieldCreateInput, ContactFieldUncheckedCreateInput>
  }

  /**
   * ContactField createMany
   */
  export type ContactFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactFields.
     */
    data: ContactFieldCreateManyInput | ContactFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactField createManyAndReturn
   */
  export type ContactFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * The data used to create many ContactFields.
     */
    data: ContactFieldCreateManyInput | ContactFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactField update
   */
  export type ContactFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a ContactField.
     */
    data: XOR<ContactFieldUpdateInput, ContactFieldUncheckedUpdateInput>
    /**
     * Choose, which ContactField to update.
     */
    where: ContactFieldWhereUniqueInput
  }

  /**
   * ContactField updateMany
   */
  export type ContactFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactFields.
     */
    data: XOR<ContactFieldUpdateManyMutationInput, ContactFieldUncheckedUpdateManyInput>
    /**
     * Filter which ContactFields to update
     */
    where?: ContactFieldWhereInput
    /**
     * Limit how many ContactFields to update.
     */
    limit?: number
  }

  /**
   * ContactField updateManyAndReturn
   */
  export type ContactFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * The data used to update ContactFields.
     */
    data: XOR<ContactFieldUpdateManyMutationInput, ContactFieldUncheckedUpdateManyInput>
    /**
     * Filter which ContactFields to update
     */
    where?: ContactFieldWhereInput
    /**
     * Limit how many ContactFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContactField upsert
   */
  export type ContactFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the ContactField to update in case it exists.
     */
    where: ContactFieldWhereUniqueInput
    /**
     * In case the ContactField found by the `where` argument doesn't exist, create a new ContactField with this data.
     */
    create: XOR<ContactFieldCreateInput, ContactFieldUncheckedCreateInput>
    /**
     * In case the ContactField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactFieldUpdateInput, ContactFieldUncheckedUpdateInput>
  }

  /**
   * ContactField delete
   */
  export type ContactFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
    /**
     * Filter which ContactField to delete.
     */
    where: ContactFieldWhereUniqueInput
  }

  /**
   * ContactField deleteMany
   */
  export type ContactFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactFields to delete
     */
    where?: ContactFieldWhereInput
    /**
     * Limit how many ContactFields to delete.
     */
    limit?: number
  }

  /**
   * ContactField without action
   */
  export type ContactFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactField
     */
    select?: ContactFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactField
     */
    omit?: ContactFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactFieldInclude<ExtArgs> | null
  }


  /**
   * Model DisparaJaConnection
   */

  export type AggregateDisparaJaConnection = {
    _count: DisparaJaConnectionCountAggregateOutputType | null
    _min: DisparaJaConnectionMinAggregateOutputType | null
    _max: DisparaJaConnectionMaxAggregateOutputType | null
  }

  export type DisparaJaConnectionMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    provider: string | null
    secret: string | null
    sid: string | null
    token: string | null
    phoneNumber: string | null
    unique: string | null
    webhookUrl: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type DisparaJaConnectionMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    provider: string | null
    secret: string | null
    sid: string | null
    token: string | null
    phoneNumber: string | null
    unique: string | null
    webhookUrl: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type DisparaJaConnectionCountAggregateOutputType = {
    id: number
    agentId: number
    provider: number
    secret: number
    sid: number
    token: number
    phoneNumber: number
    unique: number
    webhookUrl: number
    status: number
    createdAt: number
    updatedAt: number
    workspaceId: number
    _all: number
  }


  export type DisparaJaConnectionMinAggregateInputType = {
    id?: true
    agentId?: true
    provider?: true
    secret?: true
    sid?: true
    token?: true
    phoneNumber?: true
    unique?: true
    webhookUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type DisparaJaConnectionMaxAggregateInputType = {
    id?: true
    agentId?: true
    provider?: true
    secret?: true
    sid?: true
    token?: true
    phoneNumber?: true
    unique?: true
    webhookUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type DisparaJaConnectionCountAggregateInputType = {
    id?: true
    agentId?: true
    provider?: true
    secret?: true
    sid?: true
    token?: true
    phoneNumber?: true
    unique?: true
    webhookUrl?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
    _all?: true
  }

  export type DisparaJaConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisparaJaConnection to aggregate.
     */
    where?: DisparaJaConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisparaJaConnections to fetch.
     */
    orderBy?: DisparaJaConnectionOrderByWithRelationInput | DisparaJaConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisparaJaConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisparaJaConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisparaJaConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisparaJaConnections
    **/
    _count?: true | DisparaJaConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisparaJaConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisparaJaConnectionMaxAggregateInputType
  }

  export type GetDisparaJaConnectionAggregateType<T extends DisparaJaConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateDisparaJaConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisparaJaConnection[P]>
      : GetScalarType<T[P], AggregateDisparaJaConnection[P]>
  }




  export type DisparaJaConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisparaJaConnectionWhereInput
    orderBy?: DisparaJaConnectionOrderByWithAggregationInput | DisparaJaConnectionOrderByWithAggregationInput[]
    by: DisparaJaConnectionScalarFieldEnum[] | DisparaJaConnectionScalarFieldEnum
    having?: DisparaJaConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisparaJaConnectionCountAggregateInputType | true
    _min?: DisparaJaConnectionMinAggregateInputType
    _max?: DisparaJaConnectionMaxAggregateInputType
  }

  export type DisparaJaConnectionGroupByOutputType = {
    id: string
    agentId: string
    provider: string
    secret: string
    sid: string
    token: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status: string
    createdAt: Date
    updatedAt: Date
    workspaceId: string
    _count: DisparaJaConnectionCountAggregateOutputType | null
    _min: DisparaJaConnectionMinAggregateOutputType | null
    _max: DisparaJaConnectionMaxAggregateOutputType | null
  }

  type GetDisparaJaConnectionGroupByPayload<T extends DisparaJaConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisparaJaConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisparaJaConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisparaJaConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], DisparaJaConnectionGroupByOutputType[P]>
        }
      >
    >


  export type DisparaJaConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    provider?: boolean
    secret?: boolean
    sid?: boolean
    token?: boolean
    phoneNumber?: boolean
    unique?: boolean
    webhookUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    logs?: boolean | DisparaJaConnection$logsArgs<ExtArgs>
    _count?: boolean | DisparaJaConnectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disparaJaConnection"]>

  export type DisparaJaConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    provider?: boolean
    secret?: boolean
    sid?: boolean
    token?: boolean
    phoneNumber?: boolean
    unique?: boolean
    webhookUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disparaJaConnection"]>

  export type DisparaJaConnectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    provider?: boolean
    secret?: boolean
    sid?: boolean
    token?: boolean
    phoneNumber?: boolean
    unique?: boolean
    webhookUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disparaJaConnection"]>

  export type DisparaJaConnectionSelectScalar = {
    id?: boolean
    agentId?: boolean
    provider?: boolean
    secret?: boolean
    sid?: boolean
    token?: boolean
    phoneNumber?: boolean
    unique?: boolean
    webhookUrl?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
  }

  export type DisparaJaConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "provider" | "secret" | "sid" | "token" | "phoneNumber" | "unique" | "webhookUrl" | "status" | "createdAt" | "updatedAt" | "workspaceId", ExtArgs["result"]["disparaJaConnection"]>
  export type DisparaJaConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    logs?: boolean | DisparaJaConnection$logsArgs<ExtArgs>
    _count?: boolean | DisparaJaConnectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DisparaJaConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type DisparaJaConnectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $DisparaJaConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisparaJaConnection"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      logs: Prisma.$DisparaJaLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      provider: string
      secret: string
      sid: string
      token: string | null
      phoneNumber: string
      unique: string
      webhookUrl: string
      status: string
      createdAt: Date
      updatedAt: Date
      workspaceId: string
    }, ExtArgs["result"]["disparaJaConnection"]>
    composites: {}
  }

  type DisparaJaConnectionGetPayload<S extends boolean | null | undefined | DisparaJaConnectionDefaultArgs> = $Result.GetResult<Prisma.$DisparaJaConnectionPayload, S>

  type DisparaJaConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisparaJaConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisparaJaConnectionCountAggregateInputType | true
    }

  export interface DisparaJaConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisparaJaConnection'], meta: { name: 'DisparaJaConnection' } }
    /**
     * Find zero or one DisparaJaConnection that matches the filter.
     * @param {DisparaJaConnectionFindUniqueArgs} args - Arguments to find a DisparaJaConnection
     * @example
     * // Get one DisparaJaConnection
     * const disparaJaConnection = await prisma.disparaJaConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisparaJaConnectionFindUniqueArgs>(args: SelectSubset<T, DisparaJaConnectionFindUniqueArgs<ExtArgs>>): Prisma__DisparaJaConnectionClient<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisparaJaConnection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisparaJaConnectionFindUniqueOrThrowArgs} args - Arguments to find a DisparaJaConnection
     * @example
     * // Get one DisparaJaConnection
     * const disparaJaConnection = await prisma.disparaJaConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisparaJaConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, DisparaJaConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisparaJaConnectionClient<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisparaJaConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaConnectionFindFirstArgs} args - Arguments to find a DisparaJaConnection
     * @example
     * // Get one DisparaJaConnection
     * const disparaJaConnection = await prisma.disparaJaConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisparaJaConnectionFindFirstArgs>(args?: SelectSubset<T, DisparaJaConnectionFindFirstArgs<ExtArgs>>): Prisma__DisparaJaConnectionClient<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisparaJaConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaConnectionFindFirstOrThrowArgs} args - Arguments to find a DisparaJaConnection
     * @example
     * // Get one DisparaJaConnection
     * const disparaJaConnection = await prisma.disparaJaConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisparaJaConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, DisparaJaConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisparaJaConnectionClient<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisparaJaConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisparaJaConnections
     * const disparaJaConnections = await prisma.disparaJaConnection.findMany()
     * 
     * // Get first 10 DisparaJaConnections
     * const disparaJaConnections = await prisma.disparaJaConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disparaJaConnectionWithIdOnly = await prisma.disparaJaConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisparaJaConnectionFindManyArgs>(args?: SelectSubset<T, DisparaJaConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisparaJaConnection.
     * @param {DisparaJaConnectionCreateArgs} args - Arguments to create a DisparaJaConnection.
     * @example
     * // Create one DisparaJaConnection
     * const DisparaJaConnection = await prisma.disparaJaConnection.create({
     *   data: {
     *     // ... data to create a DisparaJaConnection
     *   }
     * })
     * 
     */
    create<T extends DisparaJaConnectionCreateArgs>(args: SelectSubset<T, DisparaJaConnectionCreateArgs<ExtArgs>>): Prisma__DisparaJaConnectionClient<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisparaJaConnections.
     * @param {DisparaJaConnectionCreateManyArgs} args - Arguments to create many DisparaJaConnections.
     * @example
     * // Create many DisparaJaConnections
     * const disparaJaConnection = await prisma.disparaJaConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisparaJaConnectionCreateManyArgs>(args?: SelectSubset<T, DisparaJaConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisparaJaConnections and returns the data saved in the database.
     * @param {DisparaJaConnectionCreateManyAndReturnArgs} args - Arguments to create many DisparaJaConnections.
     * @example
     * // Create many DisparaJaConnections
     * const disparaJaConnection = await prisma.disparaJaConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisparaJaConnections and only return the `id`
     * const disparaJaConnectionWithIdOnly = await prisma.disparaJaConnection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisparaJaConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, DisparaJaConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisparaJaConnection.
     * @param {DisparaJaConnectionDeleteArgs} args - Arguments to delete one DisparaJaConnection.
     * @example
     * // Delete one DisparaJaConnection
     * const DisparaJaConnection = await prisma.disparaJaConnection.delete({
     *   where: {
     *     // ... filter to delete one DisparaJaConnection
     *   }
     * })
     * 
     */
    delete<T extends DisparaJaConnectionDeleteArgs>(args: SelectSubset<T, DisparaJaConnectionDeleteArgs<ExtArgs>>): Prisma__DisparaJaConnectionClient<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisparaJaConnection.
     * @param {DisparaJaConnectionUpdateArgs} args - Arguments to update one DisparaJaConnection.
     * @example
     * // Update one DisparaJaConnection
     * const disparaJaConnection = await prisma.disparaJaConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisparaJaConnectionUpdateArgs>(args: SelectSubset<T, DisparaJaConnectionUpdateArgs<ExtArgs>>): Prisma__DisparaJaConnectionClient<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisparaJaConnections.
     * @param {DisparaJaConnectionDeleteManyArgs} args - Arguments to filter DisparaJaConnections to delete.
     * @example
     * // Delete a few DisparaJaConnections
     * const { count } = await prisma.disparaJaConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisparaJaConnectionDeleteManyArgs>(args?: SelectSubset<T, DisparaJaConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisparaJaConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisparaJaConnections
     * const disparaJaConnection = await prisma.disparaJaConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisparaJaConnectionUpdateManyArgs>(args: SelectSubset<T, DisparaJaConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisparaJaConnections and returns the data updated in the database.
     * @param {DisparaJaConnectionUpdateManyAndReturnArgs} args - Arguments to update many DisparaJaConnections.
     * @example
     * // Update many DisparaJaConnections
     * const disparaJaConnection = await prisma.disparaJaConnection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisparaJaConnections and only return the `id`
     * const disparaJaConnectionWithIdOnly = await prisma.disparaJaConnection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisparaJaConnectionUpdateManyAndReturnArgs>(args: SelectSubset<T, DisparaJaConnectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisparaJaConnection.
     * @param {DisparaJaConnectionUpsertArgs} args - Arguments to update or create a DisparaJaConnection.
     * @example
     * // Update or create a DisparaJaConnection
     * const disparaJaConnection = await prisma.disparaJaConnection.upsert({
     *   create: {
     *     // ... data to create a DisparaJaConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisparaJaConnection we want to update
     *   }
     * })
     */
    upsert<T extends DisparaJaConnectionUpsertArgs>(args: SelectSubset<T, DisparaJaConnectionUpsertArgs<ExtArgs>>): Prisma__DisparaJaConnectionClient<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisparaJaConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaConnectionCountArgs} args - Arguments to filter DisparaJaConnections to count.
     * @example
     * // Count the number of DisparaJaConnections
     * const count = await prisma.disparaJaConnection.count({
     *   where: {
     *     // ... the filter for the DisparaJaConnections we want to count
     *   }
     * })
    **/
    count<T extends DisparaJaConnectionCountArgs>(
      args?: Subset<T, DisparaJaConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisparaJaConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisparaJaConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisparaJaConnectionAggregateArgs>(args: Subset<T, DisparaJaConnectionAggregateArgs>): Prisma.PrismaPromise<GetDisparaJaConnectionAggregateType<T>>

    /**
     * Group by DisparaJaConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisparaJaConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisparaJaConnectionGroupByArgs['orderBy'] }
        : { orderBy?: DisparaJaConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisparaJaConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisparaJaConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisparaJaConnection model
   */
  readonly fields: DisparaJaConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisparaJaConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisparaJaConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    logs<T extends DisparaJaConnection$logsArgs<ExtArgs> = {}>(args?: Subset<T, DisparaJaConnection$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisparaJaConnection model
   */
  interface DisparaJaConnectionFieldRefs {
    readonly id: FieldRef<"DisparaJaConnection", 'String'>
    readonly agentId: FieldRef<"DisparaJaConnection", 'String'>
    readonly provider: FieldRef<"DisparaJaConnection", 'String'>
    readonly secret: FieldRef<"DisparaJaConnection", 'String'>
    readonly sid: FieldRef<"DisparaJaConnection", 'String'>
    readonly token: FieldRef<"DisparaJaConnection", 'String'>
    readonly phoneNumber: FieldRef<"DisparaJaConnection", 'String'>
    readonly unique: FieldRef<"DisparaJaConnection", 'String'>
    readonly webhookUrl: FieldRef<"DisparaJaConnection", 'String'>
    readonly status: FieldRef<"DisparaJaConnection", 'String'>
    readonly createdAt: FieldRef<"DisparaJaConnection", 'DateTime'>
    readonly updatedAt: FieldRef<"DisparaJaConnection", 'DateTime'>
    readonly workspaceId: FieldRef<"DisparaJaConnection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DisparaJaConnection findUnique
   */
  export type DisparaJaConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    /**
     * Filter, which DisparaJaConnection to fetch.
     */
    where: DisparaJaConnectionWhereUniqueInput
  }

  /**
   * DisparaJaConnection findUniqueOrThrow
   */
  export type DisparaJaConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    /**
     * Filter, which DisparaJaConnection to fetch.
     */
    where: DisparaJaConnectionWhereUniqueInput
  }

  /**
   * DisparaJaConnection findFirst
   */
  export type DisparaJaConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    /**
     * Filter, which DisparaJaConnection to fetch.
     */
    where?: DisparaJaConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisparaJaConnections to fetch.
     */
    orderBy?: DisparaJaConnectionOrderByWithRelationInput | DisparaJaConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisparaJaConnections.
     */
    cursor?: DisparaJaConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisparaJaConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisparaJaConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisparaJaConnections.
     */
    distinct?: DisparaJaConnectionScalarFieldEnum | DisparaJaConnectionScalarFieldEnum[]
  }

  /**
   * DisparaJaConnection findFirstOrThrow
   */
  export type DisparaJaConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    /**
     * Filter, which DisparaJaConnection to fetch.
     */
    where?: DisparaJaConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisparaJaConnections to fetch.
     */
    orderBy?: DisparaJaConnectionOrderByWithRelationInput | DisparaJaConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisparaJaConnections.
     */
    cursor?: DisparaJaConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisparaJaConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisparaJaConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisparaJaConnections.
     */
    distinct?: DisparaJaConnectionScalarFieldEnum | DisparaJaConnectionScalarFieldEnum[]
  }

  /**
   * DisparaJaConnection findMany
   */
  export type DisparaJaConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    /**
     * Filter, which DisparaJaConnections to fetch.
     */
    where?: DisparaJaConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisparaJaConnections to fetch.
     */
    orderBy?: DisparaJaConnectionOrderByWithRelationInput | DisparaJaConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisparaJaConnections.
     */
    cursor?: DisparaJaConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisparaJaConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisparaJaConnections.
     */
    skip?: number
    distinct?: DisparaJaConnectionScalarFieldEnum | DisparaJaConnectionScalarFieldEnum[]
  }

  /**
   * DisparaJaConnection create
   */
  export type DisparaJaConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a DisparaJaConnection.
     */
    data: XOR<DisparaJaConnectionCreateInput, DisparaJaConnectionUncheckedCreateInput>
  }

  /**
   * DisparaJaConnection createMany
   */
  export type DisparaJaConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisparaJaConnections.
     */
    data: DisparaJaConnectionCreateManyInput | DisparaJaConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisparaJaConnection createManyAndReturn
   */
  export type DisparaJaConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * The data used to create many DisparaJaConnections.
     */
    data: DisparaJaConnectionCreateManyInput | DisparaJaConnectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisparaJaConnection update
   */
  export type DisparaJaConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a DisparaJaConnection.
     */
    data: XOR<DisparaJaConnectionUpdateInput, DisparaJaConnectionUncheckedUpdateInput>
    /**
     * Choose, which DisparaJaConnection to update.
     */
    where: DisparaJaConnectionWhereUniqueInput
  }

  /**
   * DisparaJaConnection updateMany
   */
  export type DisparaJaConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisparaJaConnections.
     */
    data: XOR<DisparaJaConnectionUpdateManyMutationInput, DisparaJaConnectionUncheckedUpdateManyInput>
    /**
     * Filter which DisparaJaConnections to update
     */
    where?: DisparaJaConnectionWhereInput
    /**
     * Limit how many DisparaJaConnections to update.
     */
    limit?: number
  }

  /**
   * DisparaJaConnection updateManyAndReturn
   */
  export type DisparaJaConnectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * The data used to update DisparaJaConnections.
     */
    data: XOR<DisparaJaConnectionUpdateManyMutationInput, DisparaJaConnectionUncheckedUpdateManyInput>
    /**
     * Filter which DisparaJaConnections to update
     */
    where?: DisparaJaConnectionWhereInput
    /**
     * Limit how many DisparaJaConnections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisparaJaConnection upsert
   */
  export type DisparaJaConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the DisparaJaConnection to update in case it exists.
     */
    where: DisparaJaConnectionWhereUniqueInput
    /**
     * In case the DisparaJaConnection found by the `where` argument doesn't exist, create a new DisparaJaConnection with this data.
     */
    create: XOR<DisparaJaConnectionCreateInput, DisparaJaConnectionUncheckedCreateInput>
    /**
     * In case the DisparaJaConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisparaJaConnectionUpdateInput, DisparaJaConnectionUncheckedUpdateInput>
  }

  /**
   * DisparaJaConnection delete
   */
  export type DisparaJaConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    /**
     * Filter which DisparaJaConnection to delete.
     */
    where: DisparaJaConnectionWhereUniqueInput
  }

  /**
   * DisparaJaConnection deleteMany
   */
  export type DisparaJaConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisparaJaConnections to delete
     */
    where?: DisparaJaConnectionWhereInput
    /**
     * Limit how many DisparaJaConnections to delete.
     */
    limit?: number
  }

  /**
   * DisparaJaConnection.logs
   */
  export type DisparaJaConnection$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    where?: DisparaJaLogWhereInput
    orderBy?: DisparaJaLogOrderByWithRelationInput | DisparaJaLogOrderByWithRelationInput[]
    cursor?: DisparaJaLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DisparaJaLogScalarFieldEnum | DisparaJaLogScalarFieldEnum[]
  }

  /**
   * DisparaJaConnection without action
   */
  export type DisparaJaConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
  }


  /**
   * Model DisparaJaLog
   */

  export type AggregateDisparaJaLog = {
    _count: DisparaJaLogCountAggregateOutputType | null
    _min: DisparaJaLogMinAggregateOutputType | null
    _max: DisparaJaLogMaxAggregateOutputType | null
  }

  export type DisparaJaLogMinAggregateOutputType = {
    id: string | null
    connectionId: string | null
    type: string | null
    message: string | null
    timestamp: Date | null
    workspaceId: string | null
  }

  export type DisparaJaLogMaxAggregateOutputType = {
    id: string | null
    connectionId: string | null
    type: string | null
    message: string | null
    timestamp: Date | null
    workspaceId: string | null
  }

  export type DisparaJaLogCountAggregateOutputType = {
    id: number
    connectionId: number
    type: number
    message: number
    timestamp: number
    workspaceId: number
    _all: number
  }


  export type DisparaJaLogMinAggregateInputType = {
    id?: true
    connectionId?: true
    type?: true
    message?: true
    timestamp?: true
    workspaceId?: true
  }

  export type DisparaJaLogMaxAggregateInputType = {
    id?: true
    connectionId?: true
    type?: true
    message?: true
    timestamp?: true
    workspaceId?: true
  }

  export type DisparaJaLogCountAggregateInputType = {
    id?: true
    connectionId?: true
    type?: true
    message?: true
    timestamp?: true
    workspaceId?: true
    _all?: true
  }

  export type DisparaJaLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisparaJaLog to aggregate.
     */
    where?: DisparaJaLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisparaJaLogs to fetch.
     */
    orderBy?: DisparaJaLogOrderByWithRelationInput | DisparaJaLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DisparaJaLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisparaJaLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisparaJaLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DisparaJaLogs
    **/
    _count?: true | DisparaJaLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DisparaJaLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DisparaJaLogMaxAggregateInputType
  }

  export type GetDisparaJaLogAggregateType<T extends DisparaJaLogAggregateArgs> = {
        [P in keyof T & keyof AggregateDisparaJaLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDisparaJaLog[P]>
      : GetScalarType<T[P], AggregateDisparaJaLog[P]>
  }




  export type DisparaJaLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DisparaJaLogWhereInput
    orderBy?: DisparaJaLogOrderByWithAggregationInput | DisparaJaLogOrderByWithAggregationInput[]
    by: DisparaJaLogScalarFieldEnum[] | DisparaJaLogScalarFieldEnum
    having?: DisparaJaLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DisparaJaLogCountAggregateInputType | true
    _min?: DisparaJaLogMinAggregateInputType
    _max?: DisparaJaLogMaxAggregateInputType
  }

  export type DisparaJaLogGroupByOutputType = {
    id: string
    connectionId: string | null
    type: string
    message: string
    timestamp: Date
    workspaceId: string
    _count: DisparaJaLogCountAggregateOutputType | null
    _min: DisparaJaLogMinAggregateOutputType | null
    _max: DisparaJaLogMaxAggregateOutputType | null
  }

  type GetDisparaJaLogGroupByPayload<T extends DisparaJaLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DisparaJaLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DisparaJaLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DisparaJaLogGroupByOutputType[P]>
            : GetScalarType<T[P], DisparaJaLogGroupByOutputType[P]>
        }
      >
    >


  export type DisparaJaLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectionId?: boolean
    type?: boolean
    message?: boolean
    timestamp?: boolean
    workspaceId?: boolean
    connection?: boolean | DisparaJaLog$connectionArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disparaJaLog"]>

  export type DisparaJaLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectionId?: boolean
    type?: boolean
    message?: boolean
    timestamp?: boolean
    workspaceId?: boolean
    connection?: boolean | DisparaJaLog$connectionArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disparaJaLog"]>

  export type DisparaJaLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    connectionId?: boolean
    type?: boolean
    message?: boolean
    timestamp?: boolean
    workspaceId?: boolean
    connection?: boolean | DisparaJaLog$connectionArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["disparaJaLog"]>

  export type DisparaJaLogSelectScalar = {
    id?: boolean
    connectionId?: boolean
    type?: boolean
    message?: boolean
    timestamp?: boolean
    workspaceId?: boolean
  }

  export type DisparaJaLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "connectionId" | "type" | "message" | "timestamp" | "workspaceId", ExtArgs["result"]["disparaJaLog"]>
  export type DisparaJaLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    connection?: boolean | DisparaJaLog$connectionArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type DisparaJaLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    connection?: boolean | DisparaJaLog$connectionArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type DisparaJaLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    connection?: boolean | DisparaJaLog$connectionArgs<ExtArgs>
    workspaces?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $DisparaJaLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DisparaJaLog"
    objects: {
      connection: Prisma.$DisparaJaConnectionPayload<ExtArgs> | null
      workspaces: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      connectionId: string | null
      type: string
      message: string
      timestamp: Date
      workspaceId: string
    }, ExtArgs["result"]["disparaJaLog"]>
    composites: {}
  }

  type DisparaJaLogGetPayload<S extends boolean | null | undefined | DisparaJaLogDefaultArgs> = $Result.GetResult<Prisma.$DisparaJaLogPayload, S>

  type DisparaJaLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DisparaJaLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DisparaJaLogCountAggregateInputType | true
    }

  export interface DisparaJaLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DisparaJaLog'], meta: { name: 'DisparaJaLog' } }
    /**
     * Find zero or one DisparaJaLog that matches the filter.
     * @param {DisparaJaLogFindUniqueArgs} args - Arguments to find a DisparaJaLog
     * @example
     * // Get one DisparaJaLog
     * const disparaJaLog = await prisma.disparaJaLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DisparaJaLogFindUniqueArgs>(args: SelectSubset<T, DisparaJaLogFindUniqueArgs<ExtArgs>>): Prisma__DisparaJaLogClient<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DisparaJaLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DisparaJaLogFindUniqueOrThrowArgs} args - Arguments to find a DisparaJaLog
     * @example
     * // Get one DisparaJaLog
     * const disparaJaLog = await prisma.disparaJaLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DisparaJaLogFindUniqueOrThrowArgs>(args: SelectSubset<T, DisparaJaLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DisparaJaLogClient<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisparaJaLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaLogFindFirstArgs} args - Arguments to find a DisparaJaLog
     * @example
     * // Get one DisparaJaLog
     * const disparaJaLog = await prisma.disparaJaLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DisparaJaLogFindFirstArgs>(args?: SelectSubset<T, DisparaJaLogFindFirstArgs<ExtArgs>>): Prisma__DisparaJaLogClient<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DisparaJaLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaLogFindFirstOrThrowArgs} args - Arguments to find a DisparaJaLog
     * @example
     * // Get one DisparaJaLog
     * const disparaJaLog = await prisma.disparaJaLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DisparaJaLogFindFirstOrThrowArgs>(args?: SelectSubset<T, DisparaJaLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__DisparaJaLogClient<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DisparaJaLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DisparaJaLogs
     * const disparaJaLogs = await prisma.disparaJaLog.findMany()
     * 
     * // Get first 10 DisparaJaLogs
     * const disparaJaLogs = await prisma.disparaJaLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const disparaJaLogWithIdOnly = await prisma.disparaJaLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DisparaJaLogFindManyArgs>(args?: SelectSubset<T, DisparaJaLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DisparaJaLog.
     * @param {DisparaJaLogCreateArgs} args - Arguments to create a DisparaJaLog.
     * @example
     * // Create one DisparaJaLog
     * const DisparaJaLog = await prisma.disparaJaLog.create({
     *   data: {
     *     // ... data to create a DisparaJaLog
     *   }
     * })
     * 
     */
    create<T extends DisparaJaLogCreateArgs>(args: SelectSubset<T, DisparaJaLogCreateArgs<ExtArgs>>): Prisma__DisparaJaLogClient<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DisparaJaLogs.
     * @param {DisparaJaLogCreateManyArgs} args - Arguments to create many DisparaJaLogs.
     * @example
     * // Create many DisparaJaLogs
     * const disparaJaLog = await prisma.disparaJaLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DisparaJaLogCreateManyArgs>(args?: SelectSubset<T, DisparaJaLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DisparaJaLogs and returns the data saved in the database.
     * @param {DisparaJaLogCreateManyAndReturnArgs} args - Arguments to create many DisparaJaLogs.
     * @example
     * // Create many DisparaJaLogs
     * const disparaJaLog = await prisma.disparaJaLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DisparaJaLogs and only return the `id`
     * const disparaJaLogWithIdOnly = await prisma.disparaJaLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DisparaJaLogCreateManyAndReturnArgs>(args?: SelectSubset<T, DisparaJaLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DisparaJaLog.
     * @param {DisparaJaLogDeleteArgs} args - Arguments to delete one DisparaJaLog.
     * @example
     * // Delete one DisparaJaLog
     * const DisparaJaLog = await prisma.disparaJaLog.delete({
     *   where: {
     *     // ... filter to delete one DisparaJaLog
     *   }
     * })
     * 
     */
    delete<T extends DisparaJaLogDeleteArgs>(args: SelectSubset<T, DisparaJaLogDeleteArgs<ExtArgs>>): Prisma__DisparaJaLogClient<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DisparaJaLog.
     * @param {DisparaJaLogUpdateArgs} args - Arguments to update one DisparaJaLog.
     * @example
     * // Update one DisparaJaLog
     * const disparaJaLog = await prisma.disparaJaLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DisparaJaLogUpdateArgs>(args: SelectSubset<T, DisparaJaLogUpdateArgs<ExtArgs>>): Prisma__DisparaJaLogClient<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DisparaJaLogs.
     * @param {DisparaJaLogDeleteManyArgs} args - Arguments to filter DisparaJaLogs to delete.
     * @example
     * // Delete a few DisparaJaLogs
     * const { count } = await prisma.disparaJaLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DisparaJaLogDeleteManyArgs>(args?: SelectSubset<T, DisparaJaLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisparaJaLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DisparaJaLogs
     * const disparaJaLog = await prisma.disparaJaLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DisparaJaLogUpdateManyArgs>(args: SelectSubset<T, DisparaJaLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DisparaJaLogs and returns the data updated in the database.
     * @param {DisparaJaLogUpdateManyAndReturnArgs} args - Arguments to update many DisparaJaLogs.
     * @example
     * // Update many DisparaJaLogs
     * const disparaJaLog = await prisma.disparaJaLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DisparaJaLogs and only return the `id`
     * const disparaJaLogWithIdOnly = await prisma.disparaJaLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DisparaJaLogUpdateManyAndReturnArgs>(args: SelectSubset<T, DisparaJaLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DisparaJaLog.
     * @param {DisparaJaLogUpsertArgs} args - Arguments to update or create a DisparaJaLog.
     * @example
     * // Update or create a DisparaJaLog
     * const disparaJaLog = await prisma.disparaJaLog.upsert({
     *   create: {
     *     // ... data to create a DisparaJaLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DisparaJaLog we want to update
     *   }
     * })
     */
    upsert<T extends DisparaJaLogUpsertArgs>(args: SelectSubset<T, DisparaJaLogUpsertArgs<ExtArgs>>): Prisma__DisparaJaLogClient<$Result.GetResult<Prisma.$DisparaJaLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DisparaJaLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaLogCountArgs} args - Arguments to filter DisparaJaLogs to count.
     * @example
     * // Count the number of DisparaJaLogs
     * const count = await prisma.disparaJaLog.count({
     *   where: {
     *     // ... the filter for the DisparaJaLogs we want to count
     *   }
     * })
    **/
    count<T extends DisparaJaLogCountArgs>(
      args?: Subset<T, DisparaJaLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DisparaJaLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DisparaJaLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DisparaJaLogAggregateArgs>(args: Subset<T, DisparaJaLogAggregateArgs>): Prisma.PrismaPromise<GetDisparaJaLogAggregateType<T>>

    /**
     * Group by DisparaJaLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DisparaJaLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DisparaJaLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DisparaJaLogGroupByArgs['orderBy'] }
        : { orderBy?: DisparaJaLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DisparaJaLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDisparaJaLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DisparaJaLog model
   */
  readonly fields: DisparaJaLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DisparaJaLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DisparaJaLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    connection<T extends DisparaJaLog$connectionArgs<ExtArgs> = {}>(args?: Subset<T, DisparaJaLog$connectionArgs<ExtArgs>>): Prisma__DisparaJaConnectionClient<$Result.GetResult<Prisma.$DisparaJaConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    workspaces<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DisparaJaLog model
   */
  interface DisparaJaLogFieldRefs {
    readonly id: FieldRef<"DisparaJaLog", 'String'>
    readonly connectionId: FieldRef<"DisparaJaLog", 'String'>
    readonly type: FieldRef<"DisparaJaLog", 'String'>
    readonly message: FieldRef<"DisparaJaLog", 'String'>
    readonly timestamp: FieldRef<"DisparaJaLog", 'DateTime'>
    readonly workspaceId: FieldRef<"DisparaJaLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DisparaJaLog findUnique
   */
  export type DisparaJaLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    /**
     * Filter, which DisparaJaLog to fetch.
     */
    where: DisparaJaLogWhereUniqueInput
  }

  /**
   * DisparaJaLog findUniqueOrThrow
   */
  export type DisparaJaLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    /**
     * Filter, which DisparaJaLog to fetch.
     */
    where: DisparaJaLogWhereUniqueInput
  }

  /**
   * DisparaJaLog findFirst
   */
  export type DisparaJaLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    /**
     * Filter, which DisparaJaLog to fetch.
     */
    where?: DisparaJaLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisparaJaLogs to fetch.
     */
    orderBy?: DisparaJaLogOrderByWithRelationInput | DisparaJaLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisparaJaLogs.
     */
    cursor?: DisparaJaLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisparaJaLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisparaJaLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisparaJaLogs.
     */
    distinct?: DisparaJaLogScalarFieldEnum | DisparaJaLogScalarFieldEnum[]
  }

  /**
   * DisparaJaLog findFirstOrThrow
   */
  export type DisparaJaLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    /**
     * Filter, which DisparaJaLog to fetch.
     */
    where?: DisparaJaLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisparaJaLogs to fetch.
     */
    orderBy?: DisparaJaLogOrderByWithRelationInput | DisparaJaLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DisparaJaLogs.
     */
    cursor?: DisparaJaLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisparaJaLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisparaJaLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DisparaJaLogs.
     */
    distinct?: DisparaJaLogScalarFieldEnum | DisparaJaLogScalarFieldEnum[]
  }

  /**
   * DisparaJaLog findMany
   */
  export type DisparaJaLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    /**
     * Filter, which DisparaJaLogs to fetch.
     */
    where?: DisparaJaLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DisparaJaLogs to fetch.
     */
    orderBy?: DisparaJaLogOrderByWithRelationInput | DisparaJaLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DisparaJaLogs.
     */
    cursor?: DisparaJaLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DisparaJaLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DisparaJaLogs.
     */
    skip?: number
    distinct?: DisparaJaLogScalarFieldEnum | DisparaJaLogScalarFieldEnum[]
  }

  /**
   * DisparaJaLog create
   */
  export type DisparaJaLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    /**
     * The data needed to create a DisparaJaLog.
     */
    data: XOR<DisparaJaLogCreateInput, DisparaJaLogUncheckedCreateInput>
  }

  /**
   * DisparaJaLog createMany
   */
  export type DisparaJaLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DisparaJaLogs.
     */
    data: DisparaJaLogCreateManyInput | DisparaJaLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DisparaJaLog createManyAndReturn
   */
  export type DisparaJaLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * The data used to create many DisparaJaLogs.
     */
    data: DisparaJaLogCreateManyInput | DisparaJaLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisparaJaLog update
   */
  export type DisparaJaLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    /**
     * The data needed to update a DisparaJaLog.
     */
    data: XOR<DisparaJaLogUpdateInput, DisparaJaLogUncheckedUpdateInput>
    /**
     * Choose, which DisparaJaLog to update.
     */
    where: DisparaJaLogWhereUniqueInput
  }

  /**
   * DisparaJaLog updateMany
   */
  export type DisparaJaLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DisparaJaLogs.
     */
    data: XOR<DisparaJaLogUpdateManyMutationInput, DisparaJaLogUncheckedUpdateManyInput>
    /**
     * Filter which DisparaJaLogs to update
     */
    where?: DisparaJaLogWhereInput
    /**
     * Limit how many DisparaJaLogs to update.
     */
    limit?: number
  }

  /**
   * DisparaJaLog updateManyAndReturn
   */
  export type DisparaJaLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * The data used to update DisparaJaLogs.
     */
    data: XOR<DisparaJaLogUpdateManyMutationInput, DisparaJaLogUncheckedUpdateManyInput>
    /**
     * Filter which DisparaJaLogs to update
     */
    where?: DisparaJaLogWhereInput
    /**
     * Limit how many DisparaJaLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DisparaJaLog upsert
   */
  export type DisparaJaLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    /**
     * The filter to search for the DisparaJaLog to update in case it exists.
     */
    where: DisparaJaLogWhereUniqueInput
    /**
     * In case the DisparaJaLog found by the `where` argument doesn't exist, create a new DisparaJaLog with this data.
     */
    create: XOR<DisparaJaLogCreateInput, DisparaJaLogUncheckedCreateInput>
    /**
     * In case the DisparaJaLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DisparaJaLogUpdateInput, DisparaJaLogUncheckedUpdateInput>
  }

  /**
   * DisparaJaLog delete
   */
  export type DisparaJaLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
    /**
     * Filter which DisparaJaLog to delete.
     */
    where: DisparaJaLogWhereUniqueInput
  }

  /**
   * DisparaJaLog deleteMany
   */
  export type DisparaJaLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DisparaJaLogs to delete
     */
    where?: DisparaJaLogWhereInput
    /**
     * Limit how many DisparaJaLogs to delete.
     */
    limit?: number
  }

  /**
   * DisparaJaLog.connection
   */
  export type DisparaJaLog$connectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaConnection
     */
    select?: DisparaJaConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaConnection
     */
    omit?: DisparaJaConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaConnectionInclude<ExtArgs> | null
    where?: DisparaJaConnectionWhereInput
  }

  /**
   * DisparaJaLog without action
   */
  export type DisparaJaLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DisparaJaLog
     */
    select?: DisparaJaLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DisparaJaLog
     */
    omit?: DisparaJaLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DisparaJaLogInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    photo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    photo: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    photo: number
    createdAt: number
    updatedAt: number
    workspaceId: number
    _all: number
  }


  export type LeadMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    photo?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    photo?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    photo?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    name: string | null
    phone: string
    photo: string | null
    createdAt: Date
    updatedAt: Date
    workspaceId: string
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    photo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    conversations?: boolean | Lead$conversationsArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    photo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    photo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    photo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "photo" | "createdAt" | "updatedAt" | "workspaceId", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversations?: boolean | Lead$conversationsArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type LeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      phone: string
      photo: string | null
      createdAt: Date
      updatedAt: Date
      workspaceId: string
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads and returns the data updated in the database.
     * @param {LeadUpdateManyAndReturnArgs} args - Arguments to update many Leads.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversations<T extends Lead$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly name: FieldRef<"Lead", 'String'>
    readonly phone: FieldRef<"Lead", 'String'>
    readonly photo: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
    readonly workspaceId: FieldRef<"Lead", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead updateManyAndReturn
   */
  export type LeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead.conversations
   */
  export type Lead$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    leadId: string | null
    threadId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    leadId: string | null
    threadId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    workspaceId: string | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    leadId: number
    threadId: number
    createdAt: number
    updatedAt: number
    workspaceId: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    leadId?: true
    threadId?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    leadId?: true
    threadId?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    leadId?: true
    threadId?: true
    createdAt?: true
    updatedAt?: true
    workspaceId?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    leadId: string
    threadId: string | null
    createdAt: Date
    updatedAt: Date
    workspaceId: string
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    threadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    threadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    leadId?: boolean
    threadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    leadId?: boolean
    threadId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    workspaceId?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "leadId" | "threadId" | "createdAt" | "updatedAt" | "workspaceId", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lead?: boolean | LeadDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      lead: Prisma.$LeadPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      leadId: string
      threadId: string | null
      createdAt: Date
      updatedAt: Date
      workspaceId: string
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lead<T extends LeadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LeadDefaultArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly leadId: FieldRef<"Conversation", 'String'>
    readonly threadId: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
    readonly workspaceId: FieldRef<"Conversation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    content: string | null
    sender: string | null
    read: boolean | null
    createdAt: Date | null
    mediaUrl: string | null
    updatedAt: Date | null
    type: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    content: string | null
    sender: string | null
    read: boolean | null
    createdAt: Date | null
    mediaUrl: string | null
    updatedAt: Date | null
    type: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    content: number
    sender: number
    read: number
    createdAt: number
    mediaUrl: number
    updatedAt: number
    type: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    content?: true
    sender?: true
    read?: true
    createdAt?: true
    mediaUrl?: true
    updatedAt?: true
    type?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    content?: true
    sender?: true
    read?: true
    createdAt?: true
    mediaUrl?: true
    updatedAt?: true
    type?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    content?: true
    sender?: true
    read?: true
    createdAt?: true
    mediaUrl?: true
    updatedAt?: true
    type?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    content: string
    sender: string
    read: boolean
    createdAt: Date
    mediaUrl: string | null
    updatedAt: Date
    type: string
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    content?: boolean
    sender?: boolean
    read?: boolean
    createdAt?: boolean
    mediaUrl?: boolean
    updatedAt?: boolean
    type?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    content?: boolean
    sender?: boolean
    read?: boolean
    createdAt?: boolean
    mediaUrl?: boolean
    updatedAt?: boolean
    type?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    content?: boolean
    sender?: boolean
    read?: boolean
    createdAt?: boolean
    mediaUrl?: boolean
    updatedAt?: boolean
    type?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    content?: boolean
    sender?: boolean
    read?: boolean
    createdAt?: boolean
    mediaUrl?: boolean
    updatedAt?: boolean
    type?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "content" | "sender" | "read" | "createdAt" | "mediaUrl" | "updatedAt" | "type", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      content: string
      sender: string
      read: boolean
      createdAt: Date
      mediaUrl: string | null
      updatedAt: Date
      /**
       * @AllowedValues: ["text", "image", "audio"]
       */
      type: string
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly sender: FieldRef<"Message", 'String'>
    readonly read: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly mediaUrl: FieldRef<"Message", 'String'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly type: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model WhatsAppCloudConnection
   */

  export type AggregateWhatsAppCloudConnection = {
    _count: WhatsAppCloudConnectionCountAggregateOutputType | null
    _min: WhatsAppCloudConnectionMinAggregateOutputType | null
    _max: WhatsAppCloudConnectionMaxAggregateOutputType | null
  }

  export type WhatsAppCloudConnectionMinAggregateOutputType = {
    id: string | null
    agentId: string | null
    phoneNumberId: string | null
    accessToken: string | null
    status: string | null
    webhookUrl: string | null
    workspaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    verifyToken: string | null
  }

  export type WhatsAppCloudConnectionMaxAggregateOutputType = {
    id: string | null
    agentId: string | null
    phoneNumberId: string | null
    accessToken: string | null
    status: string | null
    webhookUrl: string | null
    workspaceId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    verifyToken: string | null
  }

  export type WhatsAppCloudConnectionCountAggregateOutputType = {
    id: number
    agentId: number
    phoneNumberId: number
    accessToken: number
    status: number
    webhookUrl: number
    workspaceId: number
    createdAt: number
    updatedAt: number
    verifyToken: number
    _all: number
  }


  export type WhatsAppCloudConnectionMinAggregateInputType = {
    id?: true
    agentId?: true
    phoneNumberId?: true
    accessToken?: true
    status?: true
    webhookUrl?: true
    workspaceId?: true
    createdAt?: true
    updatedAt?: true
    verifyToken?: true
  }

  export type WhatsAppCloudConnectionMaxAggregateInputType = {
    id?: true
    agentId?: true
    phoneNumberId?: true
    accessToken?: true
    status?: true
    webhookUrl?: true
    workspaceId?: true
    createdAt?: true
    updatedAt?: true
    verifyToken?: true
  }

  export type WhatsAppCloudConnectionCountAggregateInputType = {
    id?: true
    agentId?: true
    phoneNumberId?: true
    accessToken?: true
    status?: true
    webhookUrl?: true
    workspaceId?: true
    createdAt?: true
    updatedAt?: true
    verifyToken?: true
    _all?: true
  }

  export type WhatsAppCloudConnectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppCloudConnection to aggregate.
     */
    where?: WhatsAppCloudConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCloudConnections to fetch.
     */
    orderBy?: WhatsAppCloudConnectionOrderByWithRelationInput | WhatsAppCloudConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhatsAppCloudConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCloudConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCloudConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhatsAppCloudConnections
    **/
    _count?: true | WhatsAppCloudConnectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhatsAppCloudConnectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhatsAppCloudConnectionMaxAggregateInputType
  }

  export type GetWhatsAppCloudConnectionAggregateType<T extends WhatsAppCloudConnectionAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsAppCloudConnection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsAppCloudConnection[P]>
      : GetScalarType<T[P], AggregateWhatsAppCloudConnection[P]>
  }




  export type WhatsAppCloudConnectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhatsAppCloudConnectionWhereInput
    orderBy?: WhatsAppCloudConnectionOrderByWithAggregationInput | WhatsAppCloudConnectionOrderByWithAggregationInput[]
    by: WhatsAppCloudConnectionScalarFieldEnum[] | WhatsAppCloudConnectionScalarFieldEnum
    having?: WhatsAppCloudConnectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhatsAppCloudConnectionCountAggregateInputType | true
    _min?: WhatsAppCloudConnectionMinAggregateInputType
    _max?: WhatsAppCloudConnectionMaxAggregateInputType
  }

  export type WhatsAppCloudConnectionGroupByOutputType = {
    id: string
    agentId: string
    phoneNumberId: string
    accessToken: string
    status: string
    webhookUrl: string | null
    workspaceId: string
    createdAt: Date
    updatedAt: Date
    verifyToken: string
    _count: WhatsAppCloudConnectionCountAggregateOutputType | null
    _min: WhatsAppCloudConnectionMinAggregateOutputType | null
    _max: WhatsAppCloudConnectionMaxAggregateOutputType | null
  }

  type GetWhatsAppCloudConnectionGroupByPayload<T extends WhatsAppCloudConnectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhatsAppCloudConnectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhatsAppCloudConnectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhatsAppCloudConnectionGroupByOutputType[P]>
            : GetScalarType<T[P], WhatsAppCloudConnectionGroupByOutputType[P]>
        }
      >
    >


  export type WhatsAppCloudConnectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    phoneNumberId?: boolean
    accessToken?: boolean
    status?: boolean
    webhookUrl?: boolean
    workspaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verifyToken?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppCloudConnection"]>

  export type WhatsAppCloudConnectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    phoneNumberId?: boolean
    accessToken?: boolean
    status?: boolean
    webhookUrl?: boolean
    workspaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verifyToken?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppCloudConnection"]>

  export type WhatsAppCloudConnectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    agentId?: boolean
    phoneNumberId?: boolean
    accessToken?: boolean
    status?: boolean
    webhookUrl?: boolean
    workspaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verifyToken?: boolean
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsAppCloudConnection"]>

  export type WhatsAppCloudConnectionSelectScalar = {
    id?: boolean
    agentId?: boolean
    phoneNumberId?: boolean
    accessToken?: boolean
    status?: boolean
    webhookUrl?: boolean
    workspaceId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    verifyToken?: boolean
  }

  export type WhatsAppCloudConnectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "agentId" | "phoneNumberId" | "accessToken" | "status" | "webhookUrl" | "workspaceId" | "createdAt" | "updatedAt" | "verifyToken", ExtArgs["result"]["whatsAppCloudConnection"]>
  export type WhatsAppCloudConnectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WhatsAppCloudConnectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }
  export type WhatsAppCloudConnectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | AgentDefaultArgs<ExtArgs>
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
  }

  export type $WhatsAppCloudConnectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhatsAppCloudConnection"
    objects: {
      agent: Prisma.$AgentPayload<ExtArgs>
      workspace: Prisma.$WorkspacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      agentId: string
      phoneNumberId: string
      accessToken: string
      status: string
      webhookUrl: string | null
      workspaceId: string
      createdAt: Date
      updatedAt: Date
      verifyToken: string
    }, ExtArgs["result"]["whatsAppCloudConnection"]>
    composites: {}
  }

  type WhatsAppCloudConnectionGetPayload<S extends boolean | null | undefined | WhatsAppCloudConnectionDefaultArgs> = $Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload, S>

  type WhatsAppCloudConnectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WhatsAppCloudConnectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WhatsAppCloudConnectionCountAggregateInputType | true
    }

  export interface WhatsAppCloudConnectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhatsAppCloudConnection'], meta: { name: 'WhatsAppCloudConnection' } }
    /**
     * Find zero or one WhatsAppCloudConnection that matches the filter.
     * @param {WhatsAppCloudConnectionFindUniqueArgs} args - Arguments to find a WhatsAppCloudConnection
     * @example
     * // Get one WhatsAppCloudConnection
     * const whatsAppCloudConnection = await prisma.whatsAppCloudConnection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhatsAppCloudConnectionFindUniqueArgs>(args: SelectSubset<T, WhatsAppCloudConnectionFindUniqueArgs<ExtArgs>>): Prisma__WhatsAppCloudConnectionClient<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WhatsAppCloudConnection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WhatsAppCloudConnectionFindUniqueOrThrowArgs} args - Arguments to find a WhatsAppCloudConnection
     * @example
     * // Get one WhatsAppCloudConnection
     * const whatsAppCloudConnection = await prisma.whatsAppCloudConnection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhatsAppCloudConnectionFindUniqueOrThrowArgs>(args: SelectSubset<T, WhatsAppCloudConnectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhatsAppCloudConnectionClient<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppCloudConnection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCloudConnectionFindFirstArgs} args - Arguments to find a WhatsAppCloudConnection
     * @example
     * // Get one WhatsAppCloudConnection
     * const whatsAppCloudConnection = await prisma.whatsAppCloudConnection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhatsAppCloudConnectionFindFirstArgs>(args?: SelectSubset<T, WhatsAppCloudConnectionFindFirstArgs<ExtArgs>>): Prisma__WhatsAppCloudConnectionClient<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WhatsAppCloudConnection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCloudConnectionFindFirstOrThrowArgs} args - Arguments to find a WhatsAppCloudConnection
     * @example
     * // Get one WhatsAppCloudConnection
     * const whatsAppCloudConnection = await prisma.whatsAppCloudConnection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhatsAppCloudConnectionFindFirstOrThrowArgs>(args?: SelectSubset<T, WhatsAppCloudConnectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhatsAppCloudConnectionClient<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WhatsAppCloudConnections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCloudConnectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhatsAppCloudConnections
     * const whatsAppCloudConnections = await prisma.whatsAppCloudConnection.findMany()
     * 
     * // Get first 10 WhatsAppCloudConnections
     * const whatsAppCloudConnections = await prisma.whatsAppCloudConnection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whatsAppCloudConnectionWithIdOnly = await prisma.whatsAppCloudConnection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhatsAppCloudConnectionFindManyArgs>(args?: SelectSubset<T, WhatsAppCloudConnectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WhatsAppCloudConnection.
     * @param {WhatsAppCloudConnectionCreateArgs} args - Arguments to create a WhatsAppCloudConnection.
     * @example
     * // Create one WhatsAppCloudConnection
     * const WhatsAppCloudConnection = await prisma.whatsAppCloudConnection.create({
     *   data: {
     *     // ... data to create a WhatsAppCloudConnection
     *   }
     * })
     * 
     */
    create<T extends WhatsAppCloudConnectionCreateArgs>(args: SelectSubset<T, WhatsAppCloudConnectionCreateArgs<ExtArgs>>): Prisma__WhatsAppCloudConnectionClient<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WhatsAppCloudConnections.
     * @param {WhatsAppCloudConnectionCreateManyArgs} args - Arguments to create many WhatsAppCloudConnections.
     * @example
     * // Create many WhatsAppCloudConnections
     * const whatsAppCloudConnection = await prisma.whatsAppCloudConnection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhatsAppCloudConnectionCreateManyArgs>(args?: SelectSubset<T, WhatsAppCloudConnectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhatsAppCloudConnections and returns the data saved in the database.
     * @param {WhatsAppCloudConnectionCreateManyAndReturnArgs} args - Arguments to create many WhatsAppCloudConnections.
     * @example
     * // Create many WhatsAppCloudConnections
     * const whatsAppCloudConnection = await prisma.whatsAppCloudConnection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhatsAppCloudConnections and only return the `id`
     * const whatsAppCloudConnectionWithIdOnly = await prisma.whatsAppCloudConnection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhatsAppCloudConnectionCreateManyAndReturnArgs>(args?: SelectSubset<T, WhatsAppCloudConnectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WhatsAppCloudConnection.
     * @param {WhatsAppCloudConnectionDeleteArgs} args - Arguments to delete one WhatsAppCloudConnection.
     * @example
     * // Delete one WhatsAppCloudConnection
     * const WhatsAppCloudConnection = await prisma.whatsAppCloudConnection.delete({
     *   where: {
     *     // ... filter to delete one WhatsAppCloudConnection
     *   }
     * })
     * 
     */
    delete<T extends WhatsAppCloudConnectionDeleteArgs>(args: SelectSubset<T, WhatsAppCloudConnectionDeleteArgs<ExtArgs>>): Prisma__WhatsAppCloudConnectionClient<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WhatsAppCloudConnection.
     * @param {WhatsAppCloudConnectionUpdateArgs} args - Arguments to update one WhatsAppCloudConnection.
     * @example
     * // Update one WhatsAppCloudConnection
     * const whatsAppCloudConnection = await prisma.whatsAppCloudConnection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhatsAppCloudConnectionUpdateArgs>(args: SelectSubset<T, WhatsAppCloudConnectionUpdateArgs<ExtArgs>>): Prisma__WhatsAppCloudConnectionClient<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WhatsAppCloudConnections.
     * @param {WhatsAppCloudConnectionDeleteManyArgs} args - Arguments to filter WhatsAppCloudConnections to delete.
     * @example
     * // Delete a few WhatsAppCloudConnections
     * const { count } = await prisma.whatsAppCloudConnection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhatsAppCloudConnectionDeleteManyArgs>(args?: SelectSubset<T, WhatsAppCloudConnectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppCloudConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCloudConnectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhatsAppCloudConnections
     * const whatsAppCloudConnection = await prisma.whatsAppCloudConnection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhatsAppCloudConnectionUpdateManyArgs>(args: SelectSubset<T, WhatsAppCloudConnectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhatsAppCloudConnections and returns the data updated in the database.
     * @param {WhatsAppCloudConnectionUpdateManyAndReturnArgs} args - Arguments to update many WhatsAppCloudConnections.
     * @example
     * // Update many WhatsAppCloudConnections
     * const whatsAppCloudConnection = await prisma.whatsAppCloudConnection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WhatsAppCloudConnections and only return the `id`
     * const whatsAppCloudConnectionWithIdOnly = await prisma.whatsAppCloudConnection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WhatsAppCloudConnectionUpdateManyAndReturnArgs>(args: SelectSubset<T, WhatsAppCloudConnectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WhatsAppCloudConnection.
     * @param {WhatsAppCloudConnectionUpsertArgs} args - Arguments to update or create a WhatsAppCloudConnection.
     * @example
     * // Update or create a WhatsAppCloudConnection
     * const whatsAppCloudConnection = await prisma.whatsAppCloudConnection.upsert({
     *   create: {
     *     // ... data to create a WhatsAppCloudConnection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhatsAppCloudConnection we want to update
     *   }
     * })
     */
    upsert<T extends WhatsAppCloudConnectionUpsertArgs>(args: SelectSubset<T, WhatsAppCloudConnectionUpsertArgs<ExtArgs>>): Prisma__WhatsAppCloudConnectionClient<$Result.GetResult<Prisma.$WhatsAppCloudConnectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WhatsAppCloudConnections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCloudConnectionCountArgs} args - Arguments to filter WhatsAppCloudConnections to count.
     * @example
     * // Count the number of WhatsAppCloudConnections
     * const count = await prisma.whatsAppCloudConnection.count({
     *   where: {
     *     // ... the filter for the WhatsAppCloudConnections we want to count
     *   }
     * })
    **/
    count<T extends WhatsAppCloudConnectionCountArgs>(
      args?: Subset<T, WhatsAppCloudConnectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhatsAppCloudConnectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhatsAppCloudConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCloudConnectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhatsAppCloudConnectionAggregateArgs>(args: Subset<T, WhatsAppCloudConnectionAggregateArgs>): Prisma.PrismaPromise<GetWhatsAppCloudConnectionAggregateType<T>>

    /**
     * Group by WhatsAppCloudConnection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhatsAppCloudConnectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhatsAppCloudConnectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhatsAppCloudConnectionGroupByArgs['orderBy'] }
        : { orderBy?: WhatsAppCloudConnectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhatsAppCloudConnectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsAppCloudConnectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhatsAppCloudConnection model
   */
  readonly fields: WhatsAppCloudConnectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhatsAppCloudConnection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhatsAppCloudConnectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends AgentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AgentDefaultArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhatsAppCloudConnection model
   */
  interface WhatsAppCloudConnectionFieldRefs {
    readonly id: FieldRef<"WhatsAppCloudConnection", 'String'>
    readonly agentId: FieldRef<"WhatsAppCloudConnection", 'String'>
    readonly phoneNumberId: FieldRef<"WhatsAppCloudConnection", 'String'>
    readonly accessToken: FieldRef<"WhatsAppCloudConnection", 'String'>
    readonly status: FieldRef<"WhatsAppCloudConnection", 'String'>
    readonly webhookUrl: FieldRef<"WhatsAppCloudConnection", 'String'>
    readonly workspaceId: FieldRef<"WhatsAppCloudConnection", 'String'>
    readonly createdAt: FieldRef<"WhatsAppCloudConnection", 'DateTime'>
    readonly updatedAt: FieldRef<"WhatsAppCloudConnection", 'DateTime'>
    readonly verifyToken: FieldRef<"WhatsAppCloudConnection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * WhatsAppCloudConnection findUnique
   */
  export type WhatsAppCloudConnectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCloudConnection to fetch.
     */
    where: WhatsAppCloudConnectionWhereUniqueInput
  }

  /**
   * WhatsAppCloudConnection findUniqueOrThrow
   */
  export type WhatsAppCloudConnectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCloudConnection to fetch.
     */
    where: WhatsAppCloudConnectionWhereUniqueInput
  }

  /**
   * WhatsAppCloudConnection findFirst
   */
  export type WhatsAppCloudConnectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCloudConnection to fetch.
     */
    where?: WhatsAppCloudConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCloudConnections to fetch.
     */
    orderBy?: WhatsAppCloudConnectionOrderByWithRelationInput | WhatsAppCloudConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppCloudConnections.
     */
    cursor?: WhatsAppCloudConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCloudConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCloudConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppCloudConnections.
     */
    distinct?: WhatsAppCloudConnectionScalarFieldEnum | WhatsAppCloudConnectionScalarFieldEnum[]
  }

  /**
   * WhatsAppCloudConnection findFirstOrThrow
   */
  export type WhatsAppCloudConnectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCloudConnection to fetch.
     */
    where?: WhatsAppCloudConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCloudConnections to fetch.
     */
    orderBy?: WhatsAppCloudConnectionOrderByWithRelationInput | WhatsAppCloudConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhatsAppCloudConnections.
     */
    cursor?: WhatsAppCloudConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCloudConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCloudConnections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhatsAppCloudConnections.
     */
    distinct?: WhatsAppCloudConnectionScalarFieldEnum | WhatsAppCloudConnectionScalarFieldEnum[]
  }

  /**
   * WhatsAppCloudConnection findMany
   */
  export type WhatsAppCloudConnectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    /**
     * Filter, which WhatsAppCloudConnections to fetch.
     */
    where?: WhatsAppCloudConnectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhatsAppCloudConnections to fetch.
     */
    orderBy?: WhatsAppCloudConnectionOrderByWithRelationInput | WhatsAppCloudConnectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhatsAppCloudConnections.
     */
    cursor?: WhatsAppCloudConnectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhatsAppCloudConnections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhatsAppCloudConnections.
     */
    skip?: number
    distinct?: WhatsAppCloudConnectionScalarFieldEnum | WhatsAppCloudConnectionScalarFieldEnum[]
  }

  /**
   * WhatsAppCloudConnection create
   */
  export type WhatsAppCloudConnectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    /**
     * The data needed to create a WhatsAppCloudConnection.
     */
    data: XOR<WhatsAppCloudConnectionCreateInput, WhatsAppCloudConnectionUncheckedCreateInput>
  }

  /**
   * WhatsAppCloudConnection createMany
   */
  export type WhatsAppCloudConnectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhatsAppCloudConnections.
     */
    data: WhatsAppCloudConnectionCreateManyInput | WhatsAppCloudConnectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhatsAppCloudConnection createManyAndReturn
   */
  export type WhatsAppCloudConnectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * The data used to create many WhatsAppCloudConnections.
     */
    data: WhatsAppCloudConnectionCreateManyInput | WhatsAppCloudConnectionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppCloudConnection update
   */
  export type WhatsAppCloudConnectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    /**
     * The data needed to update a WhatsAppCloudConnection.
     */
    data: XOR<WhatsAppCloudConnectionUpdateInput, WhatsAppCloudConnectionUncheckedUpdateInput>
    /**
     * Choose, which WhatsAppCloudConnection to update.
     */
    where: WhatsAppCloudConnectionWhereUniqueInput
  }

  /**
   * WhatsAppCloudConnection updateMany
   */
  export type WhatsAppCloudConnectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhatsAppCloudConnections.
     */
    data: XOR<WhatsAppCloudConnectionUpdateManyMutationInput, WhatsAppCloudConnectionUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppCloudConnections to update
     */
    where?: WhatsAppCloudConnectionWhereInput
    /**
     * Limit how many WhatsAppCloudConnections to update.
     */
    limit?: number
  }

  /**
   * WhatsAppCloudConnection updateManyAndReturn
   */
  export type WhatsAppCloudConnectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * The data used to update WhatsAppCloudConnections.
     */
    data: XOR<WhatsAppCloudConnectionUpdateManyMutationInput, WhatsAppCloudConnectionUncheckedUpdateManyInput>
    /**
     * Filter which WhatsAppCloudConnections to update
     */
    where?: WhatsAppCloudConnectionWhereInput
    /**
     * Limit how many WhatsAppCloudConnections to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhatsAppCloudConnection upsert
   */
  export type WhatsAppCloudConnectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    /**
     * The filter to search for the WhatsAppCloudConnection to update in case it exists.
     */
    where: WhatsAppCloudConnectionWhereUniqueInput
    /**
     * In case the WhatsAppCloudConnection found by the `where` argument doesn't exist, create a new WhatsAppCloudConnection with this data.
     */
    create: XOR<WhatsAppCloudConnectionCreateInput, WhatsAppCloudConnectionUncheckedCreateInput>
    /**
     * In case the WhatsAppCloudConnection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhatsAppCloudConnectionUpdateInput, WhatsAppCloudConnectionUncheckedUpdateInput>
  }

  /**
   * WhatsAppCloudConnection delete
   */
  export type WhatsAppCloudConnectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
    /**
     * Filter which WhatsAppCloudConnection to delete.
     */
    where: WhatsAppCloudConnectionWhereUniqueInput
  }

  /**
   * WhatsAppCloudConnection deleteMany
   */
  export type WhatsAppCloudConnectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhatsAppCloudConnections to delete
     */
    where?: WhatsAppCloudConnectionWhereInput
    /**
     * Limit how many WhatsAppCloudConnections to delete.
     */
    limit?: number
  }

  /**
   * WhatsAppCloudConnection without action
   */
  export type WhatsAppCloudConnectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhatsAppCloudConnection
     */
    select?: WhatsAppCloudConnectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WhatsAppCloudConnection
     */
    omit?: WhatsAppCloudConnectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhatsAppCloudConnectionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    token: number
    expires: number
    createdAt: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    token?: true
    expires?: true
    createdAt?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    id: string
    userId: string
    email: string
    token: string
    expires: Date
    createdAt: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "email" | "token" | "expires" | "createdAt", ExtArgs["result"]["verificationToken"]>
  export type VerificationTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type VerificationTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type VerificationTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      email: string
      token: string
      expires: Date
      createdAt: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `id`
     * const verificationTokenWithIdOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly id: FieldRef<"VerificationToken", 'String'>
    readonly userId: FieldRef<"VerificationToken", 'String'>
    readonly email: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
    readonly createdAt: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VerificationTokenInclude<ExtArgs> | null
  }


  /**
   * Model AccessToken
   */

  export type AggregateAccessToken = {
    _count: AccessTokenCountAggregateOutputType | null
    _min: AccessTokenMinAggregateOutputType | null
    _max: AccessTokenMaxAggregateOutputType | null
  }

  export type AccessTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type AccessTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expires: Date | null
    createdAt: Date | null
  }

  export type AccessTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expires: number
    createdAt: number
    _all: number
  }


  export type AccessTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type AccessTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expires?: true
    createdAt?: true
  }

  export type AccessTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expires?: true
    createdAt?: true
    _all?: true
  }

  export type AccessTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessToken to aggregate.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessTokens
    **/
    _count?: true | AccessTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessTokenMaxAggregateInputType
  }

  export type GetAccessTokenAggregateType<T extends AccessTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessToken[P]>
      : GetScalarType<T[P], AggregateAccessToken[P]>
  }




  export type AccessTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessTokenWhereInput
    orderBy?: AccessTokenOrderByWithAggregationInput | AccessTokenOrderByWithAggregationInput[]
    by: AccessTokenScalarFieldEnum[] | AccessTokenScalarFieldEnum
    having?: AccessTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessTokenCountAggregateInputType | true
    _min?: AccessTokenMinAggregateInputType
    _max?: AccessTokenMaxAggregateInputType
  }

  export type AccessTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expires: Date
    createdAt: Date
    _count: AccessTokenCountAggregateOutputType | null
    _min: AccessTokenMinAggregateOutputType | null
    _max: AccessTokenMaxAggregateOutputType | null
  }

  type GetAccessTokenGroupByPayload<T extends AccessTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessTokenGroupByOutputType[P]>
            : GetScalarType<T[P], AccessTokenGroupByOutputType[P]>
        }
      >
    >


  export type AccessTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessToken"]>

  export type AccessTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessToken"]>

  export type AccessTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
    user?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessToken"]>

  export type AccessTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expires?: boolean
    createdAt?: boolean
  }

  export type AccessTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "token" | "expires" | "createdAt", ExtArgs["result"]["accessToken"]>
  export type AccessTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type AccessTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type AccessTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $AccessTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessToken"
    objects: {
      user: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expires: Date
      createdAt: Date
    }, ExtArgs["result"]["accessToken"]>
    composites: {}
  }

  type AccessTokenGetPayload<S extends boolean | null | undefined | AccessTokenDefaultArgs> = $Result.GetResult<Prisma.$AccessTokenPayload, S>

  type AccessTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessTokenCountAggregateInputType | true
    }

  export interface AccessTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessToken'], meta: { name: 'AccessToken' } }
    /**
     * Find zero or one AccessToken that matches the filter.
     * @param {AccessTokenFindUniqueArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessTokenFindUniqueArgs>(args: SelectSubset<T, AccessTokenFindUniqueArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessTokenFindUniqueOrThrowArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenFindFirstArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessTokenFindFirstArgs>(args?: SelectSubset<T, AccessTokenFindFirstArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenFindFirstOrThrowArgs} args - Arguments to find a AccessToken
     * @example
     * // Get one AccessToken
     * const accessToken = await prisma.accessToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessTokens
     * const accessTokens = await prisma.accessToken.findMany()
     * 
     * // Get first 10 AccessTokens
     * const accessTokens = await prisma.accessToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessTokenWithIdOnly = await prisma.accessToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessTokenFindManyArgs>(args?: SelectSubset<T, AccessTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessToken.
     * @param {AccessTokenCreateArgs} args - Arguments to create a AccessToken.
     * @example
     * // Create one AccessToken
     * const AccessToken = await prisma.accessToken.create({
     *   data: {
     *     // ... data to create a AccessToken
     *   }
     * })
     * 
     */
    create<T extends AccessTokenCreateArgs>(args: SelectSubset<T, AccessTokenCreateArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessTokens.
     * @param {AccessTokenCreateManyArgs} args - Arguments to create many AccessTokens.
     * @example
     * // Create many AccessTokens
     * const accessToken = await prisma.accessToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessTokenCreateManyArgs>(args?: SelectSubset<T, AccessTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccessTokens and returns the data saved in the database.
     * @param {AccessTokenCreateManyAndReturnArgs} args - Arguments to create many AccessTokens.
     * @example
     * // Create many AccessTokens
     * const accessToken = await prisma.accessToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccessTokens and only return the `id`
     * const accessTokenWithIdOnly = await prisma.accessToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccessToken.
     * @param {AccessTokenDeleteArgs} args - Arguments to delete one AccessToken.
     * @example
     * // Delete one AccessToken
     * const AccessToken = await prisma.accessToken.delete({
     *   where: {
     *     // ... filter to delete one AccessToken
     *   }
     * })
     * 
     */
    delete<T extends AccessTokenDeleteArgs>(args: SelectSubset<T, AccessTokenDeleteArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessToken.
     * @param {AccessTokenUpdateArgs} args - Arguments to update one AccessToken.
     * @example
     * // Update one AccessToken
     * const accessToken = await prisma.accessToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessTokenUpdateArgs>(args: SelectSubset<T, AccessTokenUpdateArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessTokens.
     * @param {AccessTokenDeleteManyArgs} args - Arguments to filter AccessTokens to delete.
     * @example
     * // Delete a few AccessTokens
     * const { count } = await prisma.accessToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessTokenDeleteManyArgs>(args?: SelectSubset<T, AccessTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessTokens
     * const accessToken = await prisma.accessToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessTokenUpdateManyArgs>(args: SelectSubset<T, AccessTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessTokens and returns the data updated in the database.
     * @param {AccessTokenUpdateManyAndReturnArgs} args - Arguments to update many AccessTokens.
     * @example
     * // Update many AccessTokens
     * const accessToken = await prisma.accessToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccessTokens and only return the `id`
     * const accessTokenWithIdOnly = await prisma.accessToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccessToken.
     * @param {AccessTokenUpsertArgs} args - Arguments to update or create a AccessToken.
     * @example
     * // Update or create a AccessToken
     * const accessToken = await prisma.accessToken.upsert({
     *   create: {
     *     // ... data to create a AccessToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessToken we want to update
     *   }
     * })
     */
    upsert<T extends AccessTokenUpsertArgs>(args: SelectSubset<T, AccessTokenUpsertArgs<ExtArgs>>): Prisma__AccessTokenClient<$Result.GetResult<Prisma.$AccessTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenCountArgs} args - Arguments to filter AccessTokens to count.
     * @example
     * // Count the number of AccessTokens
     * const count = await prisma.accessToken.count({
     *   where: {
     *     // ... the filter for the AccessTokens we want to count
     *   }
     * })
    **/
    count<T extends AccessTokenCountArgs>(
      args?: Subset<T, AccessTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessTokenAggregateArgs>(args: Subset<T, AccessTokenAggregateArgs>): Prisma.PrismaPromise<GetAccessTokenAggregateType<T>>

    /**
     * Group by AccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessTokenGroupByArgs['orderBy'] }
        : { orderBy?: AccessTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessToken model
   */
  readonly fields: AccessTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessToken model
   */
  interface AccessTokenFieldRefs {
    readonly id: FieldRef<"AccessToken", 'String'>
    readonly userId: FieldRef<"AccessToken", 'String'>
    readonly token: FieldRef<"AccessToken", 'String'>
    readonly expires: FieldRef<"AccessToken", 'DateTime'>
    readonly createdAt: FieldRef<"AccessToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccessToken findUnique
   */
  export type AccessTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where: AccessTokenWhereUniqueInput
  }

  /**
   * AccessToken findUniqueOrThrow
   */
  export type AccessTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where: AccessTokenWhereUniqueInput
  }

  /**
   * AccessToken findFirst
   */
  export type AccessTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessTokens.
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessTokens.
     */
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
  }

  /**
   * AccessToken findFirstOrThrow
   */
  export type AccessTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessToken to fetch.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessTokens.
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessTokens.
     */
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
  }

  /**
   * AccessToken findMany
   */
  export type AccessTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which AccessTokens to fetch.
     */
    where?: AccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessTokens to fetch.
     */
    orderBy?: AccessTokenOrderByWithRelationInput | AccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessTokens.
     */
    cursor?: AccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessTokens.
     */
    skip?: number
    distinct?: AccessTokenScalarFieldEnum | AccessTokenScalarFieldEnum[]
  }

  /**
   * AccessToken create
   */
  export type AccessTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessToken.
     */
    data: XOR<AccessTokenCreateInput, AccessTokenUncheckedCreateInput>
  }

  /**
   * AccessToken createMany
   */
  export type AccessTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessTokens.
     */
    data: AccessTokenCreateManyInput | AccessTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessToken createManyAndReturn
   */
  export type AccessTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * The data used to create many AccessTokens.
     */
    data: AccessTokenCreateManyInput | AccessTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessToken update
   */
  export type AccessTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessToken.
     */
    data: XOR<AccessTokenUpdateInput, AccessTokenUncheckedUpdateInput>
    /**
     * Choose, which AccessToken to update.
     */
    where: AccessTokenWhereUniqueInput
  }

  /**
   * AccessToken updateMany
   */
  export type AccessTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessTokens.
     */
    data: XOR<AccessTokenUpdateManyMutationInput, AccessTokenUncheckedUpdateManyInput>
    /**
     * Filter which AccessTokens to update
     */
    where?: AccessTokenWhereInput
    /**
     * Limit how many AccessTokens to update.
     */
    limit?: number
  }

  /**
   * AccessToken updateManyAndReturn
   */
  export type AccessTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * The data used to update AccessTokens.
     */
    data: XOR<AccessTokenUpdateManyMutationInput, AccessTokenUncheckedUpdateManyInput>
    /**
     * Filter which AccessTokens to update
     */
    where?: AccessTokenWhereInput
    /**
     * Limit how many AccessTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessToken upsert
   */
  export type AccessTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessToken to update in case it exists.
     */
    where: AccessTokenWhereUniqueInput
    /**
     * In case the AccessToken found by the `where` argument doesn't exist, create a new AccessToken with this data.
     */
    create: XOR<AccessTokenCreateInput, AccessTokenUncheckedCreateInput>
    /**
     * In case the AccessToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessTokenUpdateInput, AccessTokenUncheckedUpdateInput>
  }

  /**
   * AccessToken delete
   */
  export type AccessTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
    /**
     * Filter which AccessToken to delete.
     */
    where: AccessTokenWhereUniqueInput
  }

  /**
   * AccessToken deleteMany
   */
  export type AccessTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessTokens to delete
     */
    where?: AccessTokenWhereInput
    /**
     * Limit how many AccessTokens to delete.
     */
    limit?: number
  }

  /**
   * AccessToken without action
   */
  export type AccessTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessToken
     */
    select?: AccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessToken
     */
    omit?: AccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessTokenInclude<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires", ExtArgs["result"]["passwordResetToken"]>

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    subdomain: 'subdomain',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    workspaceId: 'workspaceId',
    emailVerified: 'emailVerified',
    verifyToken: 'verifyToken',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    lastLogin: 'lastLogin',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const PlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    features: 'features',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlanScalarFieldEnum = (typeof PlanScalarFieldEnum)[keyof typeof PlanScalarFieldEnum]


  export const SystemConfigScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workspaceId: 'workspaceId'
  };

  export type SystemConfigScalarFieldEnum = (typeof SystemConfigScalarFieldEnum)[keyof typeof SystemConfigScalarFieldEnum]


  export const AdminUserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AdminUserScalarFieldEnum = (typeof AdminUserScalarFieldEnum)[keyof typeof AdminUserScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    provider: 'provider',
    credentials: 'credentials',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workspaceId: 'workspaceId'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    systemPrompt: 'systemPrompt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    agentFunction: 'agentFunction',
    agentSkills: 'agentSkills',
    assistantId: 'assistantId',
    companyDescription: 'companyDescription',
    companyName: 'companyName',
    companySector: 'companySector',
    companyWebsite: 'companyWebsite',
    frequencyPenalty: 'frequencyPenalty',
    imageUrl: 'imageUrl',
    initialMessage: 'initialMessage',
    internalName: 'internalName',
    language: 'language',
    maxMessages: 'maxMessages',
    maxTokens: 'maxTokens',
    model: 'model',
    personalityObjective: 'personalityObjective',
    presencePenalty: 'presencePenalty',
    productInfo: 'productInfo',
    responseFormat: 'responseFormat',
    restrictions: 'restrictions',
    temperature: 'temperature',
    timezone: 'timezone',
    vectorStoreId: 'vectorStoreId',
    voiceTone: 'voiceTone',
    openaiApiKey: 'openaiApiKey',
    userId: 'userId',
    workspaceId: 'workspaceId'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    fileId: 'fileId',
    filename: 'filename',
    purpose: 'purpose',
    size: 'size',
    type: 'type',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workspaceId: 'workspaceId'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const VectorStoreScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    openaiId: 'openaiId',
    files: 'files',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workspaceId: 'workspaceId'
  };

  export type VectorStoreScalarFieldEnum = (typeof VectorStoreScalarFieldEnum)[keyof typeof VectorStoreScalarFieldEnum]


  export const ContactFieldScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    required: 'required',
    options: 'options',
    placeholder: 'placeholder',
    default_value: 'default_value',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workspaceId: 'workspaceId'
  };

  export type ContactFieldScalarFieldEnum = (typeof ContactFieldScalarFieldEnum)[keyof typeof ContactFieldScalarFieldEnum]


  export const DisparaJaConnectionScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    provider: 'provider',
    secret: 'secret',
    sid: 'sid',
    token: 'token',
    phoneNumber: 'phoneNumber',
    unique: 'unique',
    webhookUrl: 'webhookUrl',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workspaceId: 'workspaceId'
  };

  export type DisparaJaConnectionScalarFieldEnum = (typeof DisparaJaConnectionScalarFieldEnum)[keyof typeof DisparaJaConnectionScalarFieldEnum]


  export const DisparaJaLogScalarFieldEnum: {
    id: 'id',
    connectionId: 'connectionId',
    type: 'type',
    message: 'message',
    timestamp: 'timestamp',
    workspaceId: 'workspaceId'
  };

  export type DisparaJaLogScalarFieldEnum = (typeof DisparaJaLogScalarFieldEnum)[keyof typeof DisparaJaLogScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    photo: 'photo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workspaceId: 'workspaceId'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    leadId: 'leadId',
    threadId: 'threadId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    workspaceId: 'workspaceId'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    content: 'content',
    sender: 'sender',
    read: 'read',
    createdAt: 'createdAt',
    mediaUrl: 'mediaUrl',
    updatedAt: 'updatedAt',
    type: 'type'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const WhatsAppCloudConnectionScalarFieldEnum: {
    id: 'id',
    agentId: 'agentId',
    phoneNumberId: 'phoneNumberId',
    accessToken: 'accessToken',
    status: 'status',
    webhookUrl: 'webhookUrl',
    workspaceId: 'workspaceId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    verifyToken: 'verifyToken'
  };

  export type WhatsAppCloudConnectionScalarFieldEnum = (typeof WhatsAppCloudConnectionScalarFieldEnum)[keyof typeof WhatsAppCloudConnectionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const AccessTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expires: 'expires',
    createdAt: 'createdAt'
  };

  export type AccessTokenScalarFieldEnum = (typeof AccessTokenScalarFieldEnum)[keyof typeof AccessTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    id?: StringFilter<"Workspace"> | string
    name?: StringFilter<"Workspace"> | string
    subdomain?: StringNullableFilter<"Workspace"> | string | null
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    agents?: AgentListRelationFilter
    contact_fields?: ContactFieldListRelationFilter
    conversations?: ConversationListRelationFilter
    disparaJaConnections?: DisparaJaConnectionListRelationFilter
    dispara_ja_logs?: DisparaJaLogListRelationFilter
    files?: FileListRelationFilter
    integrations?: IntegrationListRelationFilter
    leads?: LeadListRelationFilter
    system_configs?: SystemConfigListRelationFilter
    users?: UsersListRelationFilter
    vector_stores?: VectorStoreListRelationFilter
    whatsappCloudConnections?: WhatsAppCloudConnectionListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agents?: AgentOrderByRelationAggregateInput
    contact_fields?: ContactFieldOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    disparaJaConnections?: DisparaJaConnectionOrderByRelationAggregateInput
    dispara_ja_logs?: DisparaJaLogOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
    integrations?: IntegrationOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    system_configs?: SystemConfigOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
    vector_stores?: VectorStoreOrderByRelationAggregateInput
    whatsappCloudConnections?: WhatsAppCloudConnectionOrderByRelationAggregateInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    subdomain?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    name?: StringFilter<"Workspace"> | string
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeFilter<"Workspace"> | Date | string
    agents?: AgentListRelationFilter
    contact_fields?: ContactFieldListRelationFilter
    conversations?: ConversationListRelationFilter
    disparaJaConnections?: DisparaJaConnectionListRelationFilter
    dispara_ja_logs?: DisparaJaLogListRelationFilter
    files?: FileListRelationFilter
    integrations?: IntegrationListRelationFilter
    leads?: LeadListRelationFilter
    system_configs?: SystemConfigListRelationFilter
    users?: UsersListRelationFilter
    vector_stores?: VectorStoreListRelationFilter
    whatsappCloudConnections?: WhatsAppCloudConnectionListRelationFilter
  }, "id" | "subdomain">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workspace"> | string
    name?: StringWithAggregatesFilter<"Workspace"> | string
    subdomain?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    password?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    workspaceId?: StringFilter<"users"> | string
    emailVerified?: DateTimeNullableFilter<"users"> | Date | string | null
    verifyToken?: StringNullableFilter<"users"> | string | null
    resetToken?: StringNullableFilter<"users"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"users"> | Date | string | null
    lastLogin?: DateTimeNullableFilter<"users"> | Date | string | null
    status?: StringFilter<"users"> | string
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    accessTokens?: AccessTokenListRelationFilter
    integrations?: IntegrationListRelationFilter
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    verificationTokens?: VerificationTokenListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    workspaceId?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    verifyToken?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accessTokens?: AccessTokenOrderByRelationAggregateInput
    integrations?: IntegrationOrderByRelationAggregateInput
    workspace?: WorkspaceOrderByWithRelationInput
    verificationTokens?: VerificationTokenOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringNullableFilter<"users"> | string | null
    password?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    workspaceId?: StringFilter<"users"> | string
    emailVerified?: DateTimeNullableFilter<"users"> | Date | string | null
    verifyToken?: StringNullableFilter<"users"> | string | null
    resetToken?: StringNullableFilter<"users"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"users"> | Date | string | null
    lastLogin?: DateTimeNullableFilter<"users"> | Date | string | null
    status?: StringFilter<"users"> | string
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
    accessTokens?: AccessTokenListRelationFilter
    integrations?: IntegrationListRelationFilter
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    verificationTokens?: VerificationTokenListRelationFilter
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    workspaceId?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    verifyToken?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    lastLogin?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    name?: StringNullableWithAggregatesFilter<"users"> | string | null
    password?: StringWithAggregatesFilter<"users"> | string
    role?: StringWithAggregatesFilter<"users"> | string
    workspaceId?: StringWithAggregatesFilter<"users"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    verifyToken?: StringNullableWithAggregatesFilter<"users"> | string | null
    resetToken?: StringNullableWithAggregatesFilter<"users"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    lastLogin?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    status?: StringWithAggregatesFilter<"users"> | string
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type PlanWhereInput = {
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    id?: StringFilter<"Plan"> | string
    name?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    price?: FloatFilter<"Plan"> | number
    features?: JsonFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
  }

  export type PlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlanWhereInput | PlanWhereInput[]
    OR?: PlanWhereInput[]
    NOT?: PlanWhereInput | PlanWhereInput[]
    name?: StringFilter<"Plan"> | string
    description?: StringNullableFilter<"Plan"> | string | null
    price?: FloatFilter<"Plan"> | number
    features?: JsonFilter<"Plan">
    createdAt?: DateTimeFilter<"Plan"> | Date | string
    updatedAt?: DateTimeFilter<"Plan"> | Date | string
  }, "id">

  export type PlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlanCountOrderByAggregateInput
    _avg?: PlanAvgOrderByAggregateInput
    _max?: PlanMaxOrderByAggregateInput
    _min?: PlanMinOrderByAggregateInput
    _sum?: PlanSumOrderByAggregateInput
  }

  export type PlanScalarWhereWithAggregatesInput = {
    AND?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    OR?: PlanScalarWhereWithAggregatesInput[]
    NOT?: PlanScalarWhereWithAggregatesInput | PlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Plan"> | string
    name?: StringWithAggregatesFilter<"Plan"> | string
    description?: StringNullableWithAggregatesFilter<"Plan"> | string | null
    price?: FloatWithAggregatesFilter<"Plan"> | number
    features?: JsonWithAggregatesFilter<"Plan">
    createdAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plan"> | Date | string
  }

  export type SystemConfigWhereInput = {
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
    workspaceId?: StringFilter<"SystemConfig"> | string
    workspaces?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type SystemConfigOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    workspaces?: WorkspaceOrderByWithRelationInput
  }

  export type SystemConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemConfigWhereInput | SystemConfigWhereInput[]
    OR?: SystemConfigWhereInput[]
    NOT?: SystemConfigWhereInput | SystemConfigWhereInput[]
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
    workspaceId?: StringFilter<"SystemConfig"> | string
    workspaces?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "key">

  export type SystemConfigOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    _count?: SystemConfigCountOrderByAggregateInput
    _max?: SystemConfigMaxOrderByAggregateInput
    _min?: SystemConfigMinOrderByAggregateInput
  }

  export type SystemConfigScalarWhereWithAggregatesInput = {
    AND?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    OR?: SystemConfigScalarWhereWithAggregatesInput[]
    NOT?: SystemConfigScalarWhereWithAggregatesInput | SystemConfigScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemConfig"> | string
    key?: StringWithAggregatesFilter<"SystemConfig"> | string
    value?: StringWithAggregatesFilter<"SystemConfig"> | string
    description?: StringNullableWithAggregatesFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemConfig"> | Date | string
    workspaceId?: StringWithAggregatesFilter<"SystemConfig"> | string
  }

  export type AdminUserWhereInput = {
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    id?: StringFilter<"AdminUser"> | string
    email?: StringFilter<"AdminUser"> | string
    name?: StringFilter<"AdminUser"> | string
    password?: StringFilter<"AdminUser"> | string
    role?: StringFilter<"AdminUser"> | string
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
  }

  export type AdminUserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: AdminUserWhereInput | AdminUserWhereInput[]
    OR?: AdminUserWhereInput[]
    NOT?: AdminUserWhereInput | AdminUserWhereInput[]
    name?: StringFilter<"AdminUser"> | string
    password?: StringFilter<"AdminUser"> | string
    role?: StringFilter<"AdminUser"> | string
    createdAt?: DateTimeFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeFilter<"AdminUser"> | Date | string
  }, "id" | "email">

  export type AdminUserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AdminUserCountOrderByAggregateInput
    _max?: AdminUserMaxOrderByAggregateInput
    _min?: AdminUserMinOrderByAggregateInput
  }

  export type AdminUserScalarWhereWithAggregatesInput = {
    AND?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    OR?: AdminUserScalarWhereWithAggregatesInput[]
    NOT?: AdminUserScalarWhereWithAggregatesInput | AdminUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminUser"> | string
    email?: StringWithAggregatesFilter<"AdminUser"> | string
    name?: StringWithAggregatesFilter<"AdminUser"> | string
    password?: StringWithAggregatesFilter<"AdminUser"> | string
    role?: StringWithAggregatesFilter<"AdminUser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AdminUser"> | Date | string
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: StringFilter<"Integration"> | string
    userId?: StringFilter<"Integration"> | string
    provider?: StringFilter<"Integration"> | string
    credentials?: JsonFilter<"Integration">
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    workspaceId?: StringFilter<"Integration"> | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    workspaces?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    user?: usersOrderByWithRelationInput
    workspaces?: WorkspaceOrderByWithRelationInput
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_provider?: IntegrationUserIdProviderCompoundUniqueInput
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    userId?: StringFilter<"Integration"> | string
    provider?: StringFilter<"Integration"> | string
    credentials?: JsonFilter<"Integration">
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    workspaceId?: StringFilter<"Integration"> | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
    workspaces?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "userId_provider">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Integration"> | string
    userId?: StringWithAggregatesFilter<"Integration"> | string
    provider?: StringWithAggregatesFilter<"Integration"> | string
    credentials?: JsonWithAggregatesFilter<"Integration">
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    workspaceId?: StringWithAggregatesFilter<"Integration"> | string
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    systemPrompt?: StringNullableFilter<"Agent"> | string | null
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    agentFunction?: StringNullableFilter<"Agent"> | string | null
    agentSkills?: StringNullableFilter<"Agent"> | string | null
    assistantId?: StringNullableFilter<"Agent"> | string | null
    companyDescription?: StringNullableFilter<"Agent"> | string | null
    companyName?: StringNullableFilter<"Agent"> | string | null
    companySector?: StringNullableFilter<"Agent"> | string | null
    companyWebsite?: StringNullableFilter<"Agent"> | string | null
    frequencyPenalty?: FloatNullableFilter<"Agent"> | number | null
    imageUrl?: StringNullableFilter<"Agent"> | string | null
    initialMessage?: StringNullableFilter<"Agent"> | string | null
    internalName?: StringNullableFilter<"Agent"> | string | null
    language?: StringNullableFilter<"Agent"> | string | null
    maxMessages?: IntNullableFilter<"Agent"> | number | null
    maxTokens?: IntNullableFilter<"Agent"> | number | null
    model?: StringNullableFilter<"Agent"> | string | null
    personalityObjective?: StringNullableFilter<"Agent"> | string | null
    presencePenalty?: FloatNullableFilter<"Agent"> | number | null
    productInfo?: StringNullableFilter<"Agent"> | string | null
    responseFormat?: StringNullableFilter<"Agent"> | string | null
    restrictions?: StringNullableFilter<"Agent"> | string | null
    temperature?: FloatNullableFilter<"Agent"> | number | null
    timezone?: StringNullableFilter<"Agent"> | string | null
    vectorStoreId?: StringNullableFilter<"Agent"> | string | null
    voiceTone?: StringNullableFilter<"Agent"> | string | null
    openaiApiKey?: StringNullableFilter<"Agent"> | string | null
    userId?: StringFilter<"Agent"> | string
    workspaceId?: StringFilter<"Agent"> | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    disparaJaConnections?: DisparaJaConnectionListRelationFilter
    whatsappCloudConnections?: WhatsAppCloudConnectionListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    systemPrompt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentFunction?: SortOrderInput | SortOrder
    agentSkills?: SortOrderInput | SortOrder
    assistantId?: SortOrderInput | SortOrder
    companyDescription?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    companySector?: SortOrderInput | SortOrder
    companyWebsite?: SortOrderInput | SortOrder
    frequencyPenalty?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    initialMessage?: SortOrderInput | SortOrder
    internalName?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    maxMessages?: SortOrderInput | SortOrder
    maxTokens?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    personalityObjective?: SortOrderInput | SortOrder
    presencePenalty?: SortOrderInput | SortOrder
    productInfo?: SortOrderInput | SortOrder
    responseFormat?: SortOrderInput | SortOrder
    restrictions?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    vectorStoreId?: SortOrderInput | SortOrder
    voiceTone?: SortOrderInput | SortOrder
    openaiApiKey?: SortOrderInput | SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    disparaJaConnections?: DisparaJaConnectionOrderByRelationAggregateInput
    whatsappCloudConnections?: WhatsAppCloudConnectionOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    systemPrompt?: StringNullableFilter<"Agent"> | string | null
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    agentFunction?: StringNullableFilter<"Agent"> | string | null
    agentSkills?: StringNullableFilter<"Agent"> | string | null
    assistantId?: StringNullableFilter<"Agent"> | string | null
    companyDescription?: StringNullableFilter<"Agent"> | string | null
    companyName?: StringNullableFilter<"Agent"> | string | null
    companySector?: StringNullableFilter<"Agent"> | string | null
    companyWebsite?: StringNullableFilter<"Agent"> | string | null
    frequencyPenalty?: FloatNullableFilter<"Agent"> | number | null
    imageUrl?: StringNullableFilter<"Agent"> | string | null
    initialMessage?: StringNullableFilter<"Agent"> | string | null
    internalName?: StringNullableFilter<"Agent"> | string | null
    language?: StringNullableFilter<"Agent"> | string | null
    maxMessages?: IntNullableFilter<"Agent"> | number | null
    maxTokens?: IntNullableFilter<"Agent"> | number | null
    model?: StringNullableFilter<"Agent"> | string | null
    personalityObjective?: StringNullableFilter<"Agent"> | string | null
    presencePenalty?: FloatNullableFilter<"Agent"> | number | null
    productInfo?: StringNullableFilter<"Agent"> | string | null
    responseFormat?: StringNullableFilter<"Agent"> | string | null
    restrictions?: StringNullableFilter<"Agent"> | string | null
    temperature?: FloatNullableFilter<"Agent"> | number | null
    timezone?: StringNullableFilter<"Agent"> | string | null
    vectorStoreId?: StringNullableFilter<"Agent"> | string | null
    voiceTone?: StringNullableFilter<"Agent"> | string | null
    openaiApiKey?: StringNullableFilter<"Agent"> | string | null
    userId?: StringFilter<"Agent"> | string
    workspaceId?: StringFilter<"Agent"> | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    disparaJaConnections?: DisparaJaConnectionListRelationFilter
    whatsappCloudConnections?: WhatsAppCloudConnectionListRelationFilter
  }, "id">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    systemPrompt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentFunction?: SortOrderInput | SortOrder
    agentSkills?: SortOrderInput | SortOrder
    assistantId?: SortOrderInput | SortOrder
    companyDescription?: SortOrderInput | SortOrder
    companyName?: SortOrderInput | SortOrder
    companySector?: SortOrderInput | SortOrder
    companyWebsite?: SortOrderInput | SortOrder
    frequencyPenalty?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    initialMessage?: SortOrderInput | SortOrder
    internalName?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    maxMessages?: SortOrderInput | SortOrder
    maxTokens?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    personalityObjective?: SortOrderInput | SortOrder
    presencePenalty?: SortOrderInput | SortOrder
    productInfo?: SortOrderInput | SortOrder
    responseFormat?: SortOrderInput | SortOrder
    restrictions?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    timezone?: SortOrderInput | SortOrder
    vectorStoreId?: SortOrderInput | SortOrder
    voiceTone?: SortOrderInput | SortOrder
    openaiApiKey?: SortOrderInput | SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Agent"> | string
    name?: StringWithAggregatesFilter<"Agent"> | string
    description?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    systemPrompt?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    agentFunction?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    agentSkills?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    assistantId?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    companyDescription?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    companyName?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    companySector?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    companyWebsite?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    frequencyPenalty?: FloatNullableWithAggregatesFilter<"Agent"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    initialMessage?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    internalName?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    language?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    maxMessages?: IntNullableWithAggregatesFilter<"Agent"> | number | null
    maxTokens?: IntNullableWithAggregatesFilter<"Agent"> | number | null
    model?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    personalityObjective?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    presencePenalty?: FloatNullableWithAggregatesFilter<"Agent"> | number | null
    productInfo?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    responseFormat?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    restrictions?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    temperature?: FloatNullableWithAggregatesFilter<"Agent"> | number | null
    timezone?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    vectorStoreId?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    voiceTone?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    openaiApiKey?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    userId?: StringWithAggregatesFilter<"Agent"> | string
    workspaceId?: StringWithAggregatesFilter<"Agent"> | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    fileId?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    purpose?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    type?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    workspaceId?: StringFilter<"File"> | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    fileId?: SortOrder
    filename?: SortOrder
    purpose?: SortOrder
    size?: SortOrder
    type?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fileId?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    filename?: StringFilter<"File"> | string
    purpose?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    type?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    workspaceId?: StringFilter<"File"> | string
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "fileId">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    fileId?: SortOrder
    filename?: SortOrder
    purpose?: SortOrder
    size?: SortOrder
    type?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    fileId?: StringWithAggregatesFilter<"File"> | string
    filename?: StringWithAggregatesFilter<"File"> | string
    purpose?: StringWithAggregatesFilter<"File"> | string
    size?: IntWithAggregatesFilter<"File"> | number
    type?: StringNullableWithAggregatesFilter<"File"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    workspaceId?: StringWithAggregatesFilter<"File"> | string
  }

  export type VectorStoreWhereInput = {
    AND?: VectorStoreWhereInput | VectorStoreWhereInput[]
    OR?: VectorStoreWhereInput[]
    NOT?: VectorStoreWhereInput | VectorStoreWhereInput[]
    id?: StringFilter<"VectorStore"> | string
    name?: StringFilter<"VectorStore"> | string
    description?: StringNullableFilter<"VectorStore"> | string | null
    openaiId?: StringFilter<"VectorStore"> | string
    files?: JsonNullableFilter<"VectorStore">
    createdAt?: DateTimeFilter<"VectorStore"> | Date | string
    updatedAt?: DateTimeFilter<"VectorStore"> | Date | string
    workspaceId?: StringFilter<"VectorStore"> | string
    workspaces?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type VectorStoreOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    openaiId?: SortOrder
    files?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    workspaces?: WorkspaceOrderByWithRelationInput
  }

  export type VectorStoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    openaiId?: string
    AND?: VectorStoreWhereInput | VectorStoreWhereInput[]
    OR?: VectorStoreWhereInput[]
    NOT?: VectorStoreWhereInput | VectorStoreWhereInput[]
    name?: StringFilter<"VectorStore"> | string
    description?: StringNullableFilter<"VectorStore"> | string | null
    files?: JsonNullableFilter<"VectorStore">
    createdAt?: DateTimeFilter<"VectorStore"> | Date | string
    updatedAt?: DateTimeFilter<"VectorStore"> | Date | string
    workspaceId?: StringFilter<"VectorStore"> | string
    workspaces?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "openaiId">

  export type VectorStoreOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    openaiId?: SortOrder
    files?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    _count?: VectorStoreCountOrderByAggregateInput
    _max?: VectorStoreMaxOrderByAggregateInput
    _min?: VectorStoreMinOrderByAggregateInput
  }

  export type VectorStoreScalarWhereWithAggregatesInput = {
    AND?: VectorStoreScalarWhereWithAggregatesInput | VectorStoreScalarWhereWithAggregatesInput[]
    OR?: VectorStoreScalarWhereWithAggregatesInput[]
    NOT?: VectorStoreScalarWhereWithAggregatesInput | VectorStoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VectorStore"> | string
    name?: StringWithAggregatesFilter<"VectorStore"> | string
    description?: StringNullableWithAggregatesFilter<"VectorStore"> | string | null
    openaiId?: StringWithAggregatesFilter<"VectorStore"> | string
    files?: JsonNullableWithAggregatesFilter<"VectorStore">
    createdAt?: DateTimeWithAggregatesFilter<"VectorStore"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"VectorStore"> | Date | string
    workspaceId?: StringWithAggregatesFilter<"VectorStore"> | string
  }

  export type ContactFieldWhereInput = {
    AND?: ContactFieldWhereInput | ContactFieldWhereInput[]
    OR?: ContactFieldWhereInput[]
    NOT?: ContactFieldWhereInput | ContactFieldWhereInput[]
    id?: StringFilter<"ContactField"> | string
    name?: StringFilter<"ContactField"> | string
    type?: StringFilter<"ContactField"> | string
    required?: BoolFilter<"ContactField"> | boolean
    options?: StringNullableListFilter<"ContactField">
    placeholder?: StringNullableFilter<"ContactField"> | string | null
    default_value?: StringNullableFilter<"ContactField"> | string | null
    description?: StringNullableFilter<"ContactField"> | string | null
    order?: IntFilter<"ContactField"> | number
    createdAt?: DateTimeFilter<"ContactField"> | Date | string
    updatedAt?: DateTimeFilter<"ContactField"> | Date | string
    workspaceId?: StringFilter<"ContactField"> | string
    workspaces?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type ContactFieldOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    required?: SortOrder
    options?: SortOrder
    placeholder?: SortOrderInput | SortOrder
    default_value?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    workspaces?: WorkspaceOrderByWithRelationInput
  }

  export type ContactFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactFieldWhereInput | ContactFieldWhereInput[]
    OR?: ContactFieldWhereInput[]
    NOT?: ContactFieldWhereInput | ContactFieldWhereInput[]
    name?: StringFilter<"ContactField"> | string
    type?: StringFilter<"ContactField"> | string
    required?: BoolFilter<"ContactField"> | boolean
    options?: StringNullableListFilter<"ContactField">
    placeholder?: StringNullableFilter<"ContactField"> | string | null
    default_value?: StringNullableFilter<"ContactField"> | string | null
    description?: StringNullableFilter<"ContactField"> | string | null
    order?: IntFilter<"ContactField"> | number
    createdAt?: DateTimeFilter<"ContactField"> | Date | string
    updatedAt?: DateTimeFilter<"ContactField"> | Date | string
    workspaceId?: StringFilter<"ContactField"> | string
    workspaces?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type ContactFieldOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    required?: SortOrder
    options?: SortOrder
    placeholder?: SortOrderInput | SortOrder
    default_value?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    _count?: ContactFieldCountOrderByAggregateInput
    _avg?: ContactFieldAvgOrderByAggregateInput
    _max?: ContactFieldMaxOrderByAggregateInput
    _min?: ContactFieldMinOrderByAggregateInput
    _sum?: ContactFieldSumOrderByAggregateInput
  }

  export type ContactFieldScalarWhereWithAggregatesInput = {
    AND?: ContactFieldScalarWhereWithAggregatesInput | ContactFieldScalarWhereWithAggregatesInput[]
    OR?: ContactFieldScalarWhereWithAggregatesInput[]
    NOT?: ContactFieldScalarWhereWithAggregatesInput | ContactFieldScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContactField"> | string
    name?: StringWithAggregatesFilter<"ContactField"> | string
    type?: StringWithAggregatesFilter<"ContactField"> | string
    required?: BoolWithAggregatesFilter<"ContactField"> | boolean
    options?: StringNullableListFilter<"ContactField">
    placeholder?: StringNullableWithAggregatesFilter<"ContactField"> | string | null
    default_value?: StringNullableWithAggregatesFilter<"ContactField"> | string | null
    description?: StringNullableWithAggregatesFilter<"ContactField"> | string | null
    order?: IntWithAggregatesFilter<"ContactField"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ContactField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContactField"> | Date | string
    workspaceId?: StringWithAggregatesFilter<"ContactField"> | string
  }

  export type DisparaJaConnectionWhereInput = {
    AND?: DisparaJaConnectionWhereInput | DisparaJaConnectionWhereInput[]
    OR?: DisparaJaConnectionWhereInput[]
    NOT?: DisparaJaConnectionWhereInput | DisparaJaConnectionWhereInput[]
    id?: StringFilter<"DisparaJaConnection"> | string
    agentId?: StringFilter<"DisparaJaConnection"> | string
    provider?: StringFilter<"DisparaJaConnection"> | string
    secret?: StringFilter<"DisparaJaConnection"> | string
    sid?: StringFilter<"DisparaJaConnection"> | string
    token?: StringNullableFilter<"DisparaJaConnection"> | string | null
    phoneNumber?: StringFilter<"DisparaJaConnection"> | string
    unique?: StringFilter<"DisparaJaConnection"> | string
    webhookUrl?: StringFilter<"DisparaJaConnection"> | string
    status?: StringFilter<"DisparaJaConnection"> | string
    createdAt?: DateTimeFilter<"DisparaJaConnection"> | Date | string
    updatedAt?: DateTimeFilter<"DisparaJaConnection"> | Date | string
    workspaceId?: StringFilter<"DisparaJaConnection"> | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    logs?: DisparaJaLogListRelationFilter
  }

  export type DisparaJaConnectionOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    provider?: SortOrder
    secret?: SortOrder
    sid?: SortOrder
    token?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    unique?: SortOrder
    webhookUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    agent?: AgentOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    logs?: DisparaJaLogOrderByRelationAggregateInput
  }

  export type DisparaJaConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DisparaJaConnectionWhereInput | DisparaJaConnectionWhereInput[]
    OR?: DisparaJaConnectionWhereInput[]
    NOT?: DisparaJaConnectionWhereInput | DisparaJaConnectionWhereInput[]
    agentId?: StringFilter<"DisparaJaConnection"> | string
    provider?: StringFilter<"DisparaJaConnection"> | string
    secret?: StringFilter<"DisparaJaConnection"> | string
    sid?: StringFilter<"DisparaJaConnection"> | string
    token?: StringNullableFilter<"DisparaJaConnection"> | string | null
    phoneNumber?: StringFilter<"DisparaJaConnection"> | string
    unique?: StringFilter<"DisparaJaConnection"> | string
    webhookUrl?: StringFilter<"DisparaJaConnection"> | string
    status?: StringFilter<"DisparaJaConnection"> | string
    createdAt?: DateTimeFilter<"DisparaJaConnection"> | Date | string
    updatedAt?: DateTimeFilter<"DisparaJaConnection"> | Date | string
    workspaceId?: StringFilter<"DisparaJaConnection"> | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    logs?: DisparaJaLogListRelationFilter
  }, "id">

  export type DisparaJaConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    provider?: SortOrder
    secret?: SortOrder
    sid?: SortOrder
    token?: SortOrderInput | SortOrder
    phoneNumber?: SortOrder
    unique?: SortOrder
    webhookUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    _count?: DisparaJaConnectionCountOrderByAggregateInput
    _max?: DisparaJaConnectionMaxOrderByAggregateInput
    _min?: DisparaJaConnectionMinOrderByAggregateInput
  }

  export type DisparaJaConnectionScalarWhereWithAggregatesInput = {
    AND?: DisparaJaConnectionScalarWhereWithAggregatesInput | DisparaJaConnectionScalarWhereWithAggregatesInput[]
    OR?: DisparaJaConnectionScalarWhereWithAggregatesInput[]
    NOT?: DisparaJaConnectionScalarWhereWithAggregatesInput | DisparaJaConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisparaJaConnection"> | string
    agentId?: StringWithAggregatesFilter<"DisparaJaConnection"> | string
    provider?: StringWithAggregatesFilter<"DisparaJaConnection"> | string
    secret?: StringWithAggregatesFilter<"DisparaJaConnection"> | string
    sid?: StringWithAggregatesFilter<"DisparaJaConnection"> | string
    token?: StringNullableWithAggregatesFilter<"DisparaJaConnection"> | string | null
    phoneNumber?: StringWithAggregatesFilter<"DisparaJaConnection"> | string
    unique?: StringWithAggregatesFilter<"DisparaJaConnection"> | string
    webhookUrl?: StringWithAggregatesFilter<"DisparaJaConnection"> | string
    status?: StringWithAggregatesFilter<"DisparaJaConnection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DisparaJaConnection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DisparaJaConnection"> | Date | string
    workspaceId?: StringWithAggregatesFilter<"DisparaJaConnection"> | string
  }

  export type DisparaJaLogWhereInput = {
    AND?: DisparaJaLogWhereInput | DisparaJaLogWhereInput[]
    OR?: DisparaJaLogWhereInput[]
    NOT?: DisparaJaLogWhereInput | DisparaJaLogWhereInput[]
    id?: StringFilter<"DisparaJaLog"> | string
    connectionId?: StringNullableFilter<"DisparaJaLog"> | string | null
    type?: StringFilter<"DisparaJaLog"> | string
    message?: StringFilter<"DisparaJaLog"> | string
    timestamp?: DateTimeFilter<"DisparaJaLog"> | Date | string
    workspaceId?: StringFilter<"DisparaJaLog"> | string
    connection?: XOR<DisparaJaConnectionNullableScalarRelationFilter, DisparaJaConnectionWhereInput> | null
    workspaces?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type DisparaJaLogOrderByWithRelationInput = {
    id?: SortOrder
    connectionId?: SortOrderInput | SortOrder
    type?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    workspaceId?: SortOrder
    connection?: DisparaJaConnectionOrderByWithRelationInput
    workspaces?: WorkspaceOrderByWithRelationInput
  }

  export type DisparaJaLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DisparaJaLogWhereInput | DisparaJaLogWhereInput[]
    OR?: DisparaJaLogWhereInput[]
    NOT?: DisparaJaLogWhereInput | DisparaJaLogWhereInput[]
    connectionId?: StringNullableFilter<"DisparaJaLog"> | string | null
    type?: StringFilter<"DisparaJaLog"> | string
    message?: StringFilter<"DisparaJaLog"> | string
    timestamp?: DateTimeFilter<"DisparaJaLog"> | Date | string
    workspaceId?: StringFilter<"DisparaJaLog"> | string
    connection?: XOR<DisparaJaConnectionNullableScalarRelationFilter, DisparaJaConnectionWhereInput> | null
    workspaces?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type DisparaJaLogOrderByWithAggregationInput = {
    id?: SortOrder
    connectionId?: SortOrderInput | SortOrder
    type?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    workspaceId?: SortOrder
    _count?: DisparaJaLogCountOrderByAggregateInput
    _max?: DisparaJaLogMaxOrderByAggregateInput
    _min?: DisparaJaLogMinOrderByAggregateInput
  }

  export type DisparaJaLogScalarWhereWithAggregatesInput = {
    AND?: DisparaJaLogScalarWhereWithAggregatesInput | DisparaJaLogScalarWhereWithAggregatesInput[]
    OR?: DisparaJaLogScalarWhereWithAggregatesInput[]
    NOT?: DisparaJaLogScalarWhereWithAggregatesInput | DisparaJaLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DisparaJaLog"> | string
    connectionId?: StringNullableWithAggregatesFilter<"DisparaJaLog"> | string | null
    type?: StringWithAggregatesFilter<"DisparaJaLog"> | string
    message?: StringWithAggregatesFilter<"DisparaJaLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"DisparaJaLog"> | Date | string
    workspaceId?: StringWithAggregatesFilter<"DisparaJaLog"> | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: UuidFilter<"Lead"> | string
    name?: StringNullableFilter<"Lead"> | string | null
    phone?: StringFilter<"Lead"> | string
    photo?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    workspaceId?: StringFilter<"Lead"> | string
    conversations?: ConversationListRelationFilter
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrder
    photo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    conversations?: ConversationOrderByRelationAggregateInput
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    phone_workspaceId?: LeadPhoneWorkspaceIdCompoundUniqueInput
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    name?: StringNullableFilter<"Lead"> | string | null
    phone?: StringFilter<"Lead"> | string
    photo?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    workspaceId?: StringFilter<"Lead"> | string
    conversations?: ConversationListRelationFilter
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id" | "phone_workspaceId">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrder
    photo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Lead"> | string
    name?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    phone?: StringWithAggregatesFilter<"Lead"> | string
    photo?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    workspaceId?: StringWithAggregatesFilter<"Lead"> | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: UuidFilter<"Conversation"> | string
    leadId?: UuidFilter<"Conversation"> | string
    threadId?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    workspaceId?: StringFilter<"Conversation"> | string
    lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    messages?: MessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    leadId?: SortOrder
    threadId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    lead?: LeadOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    leadId?: UuidFilter<"Conversation"> | string
    threadId?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    workspaceId?: StringFilter<"Conversation"> | string
    lead?: XOR<LeadScalarRelationFilter, LeadWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
    messages?: MessageListRelationFilter
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    leadId?: SortOrder
    threadId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Conversation"> | string
    leadId?: UuidWithAggregatesFilter<"Conversation"> | string
    threadId?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    workspaceId?: StringWithAggregatesFilter<"Conversation"> | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: UuidFilter<"Message"> | string
    conversationId?: UuidFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    sender?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    type?: StringFilter<"Message"> | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    content?: SortOrder
    sender?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: UuidFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    sender?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    type?: StringFilter<"Message"> | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    content?: SortOrder
    sender?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    mediaUrl?: SortOrderInput | SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Message"> | string
    conversationId?: UuidWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    sender?: StringWithAggregatesFilter<"Message"> | string
    read?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    mediaUrl?: StringNullableWithAggregatesFilter<"Message"> | string | null
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    type?: StringWithAggregatesFilter<"Message"> | string
  }

  export type WhatsAppCloudConnectionWhereInput = {
    AND?: WhatsAppCloudConnectionWhereInput | WhatsAppCloudConnectionWhereInput[]
    OR?: WhatsAppCloudConnectionWhereInput[]
    NOT?: WhatsAppCloudConnectionWhereInput | WhatsAppCloudConnectionWhereInput[]
    id?: StringFilter<"WhatsAppCloudConnection"> | string
    agentId?: StringFilter<"WhatsAppCloudConnection"> | string
    phoneNumberId?: StringFilter<"WhatsAppCloudConnection"> | string
    accessToken?: StringFilter<"WhatsAppCloudConnection"> | string
    status?: StringFilter<"WhatsAppCloudConnection"> | string
    webhookUrl?: StringNullableFilter<"WhatsAppCloudConnection"> | string | null
    workspaceId?: StringFilter<"WhatsAppCloudConnection"> | string
    createdAt?: DateTimeFilter<"WhatsAppCloudConnection"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppCloudConnection"> | Date | string
    verifyToken?: StringFilter<"WhatsAppCloudConnection"> | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }

  export type WhatsAppCloudConnectionOrderByWithRelationInput = {
    id?: SortOrder
    agentId?: SortOrder
    phoneNumberId?: SortOrder
    accessToken?: SortOrder
    status?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verifyToken?: SortOrder
    agent?: AgentOrderByWithRelationInput
    workspace?: WorkspaceOrderByWithRelationInput
  }

  export type WhatsAppCloudConnectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WhatsAppCloudConnectionWhereInput | WhatsAppCloudConnectionWhereInput[]
    OR?: WhatsAppCloudConnectionWhereInput[]
    NOT?: WhatsAppCloudConnectionWhereInput | WhatsAppCloudConnectionWhereInput[]
    agentId?: StringFilter<"WhatsAppCloudConnection"> | string
    phoneNumberId?: StringFilter<"WhatsAppCloudConnection"> | string
    accessToken?: StringFilter<"WhatsAppCloudConnection"> | string
    status?: StringFilter<"WhatsAppCloudConnection"> | string
    webhookUrl?: StringNullableFilter<"WhatsAppCloudConnection"> | string | null
    workspaceId?: StringFilter<"WhatsAppCloudConnection"> | string
    createdAt?: DateTimeFilter<"WhatsAppCloudConnection"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppCloudConnection"> | Date | string
    verifyToken?: StringFilter<"WhatsAppCloudConnection"> | string
    agent?: XOR<AgentScalarRelationFilter, AgentWhereInput>
    workspace?: XOR<WorkspaceScalarRelationFilter, WorkspaceWhereInput>
  }, "id">

  export type WhatsAppCloudConnectionOrderByWithAggregationInput = {
    id?: SortOrder
    agentId?: SortOrder
    phoneNumberId?: SortOrder
    accessToken?: SortOrder
    status?: SortOrder
    webhookUrl?: SortOrderInput | SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verifyToken?: SortOrder
    _count?: WhatsAppCloudConnectionCountOrderByAggregateInput
    _max?: WhatsAppCloudConnectionMaxOrderByAggregateInput
    _min?: WhatsAppCloudConnectionMinOrderByAggregateInput
  }

  export type WhatsAppCloudConnectionScalarWhereWithAggregatesInput = {
    AND?: WhatsAppCloudConnectionScalarWhereWithAggregatesInput | WhatsAppCloudConnectionScalarWhereWithAggregatesInput[]
    OR?: WhatsAppCloudConnectionScalarWhereWithAggregatesInput[]
    NOT?: WhatsAppCloudConnectionScalarWhereWithAggregatesInput | WhatsAppCloudConnectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhatsAppCloudConnection"> | string
    agentId?: StringWithAggregatesFilter<"WhatsAppCloudConnection"> | string
    phoneNumberId?: StringWithAggregatesFilter<"WhatsAppCloudConnection"> | string
    accessToken?: StringWithAggregatesFilter<"WhatsAppCloudConnection"> | string
    status?: StringWithAggregatesFilter<"WhatsAppCloudConnection"> | string
    webhookUrl?: StringNullableWithAggregatesFilter<"WhatsAppCloudConnection"> | string | null
    workspaceId?: StringWithAggregatesFilter<"WhatsAppCloudConnection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"WhatsAppCloudConnection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhatsAppCloudConnection"> | Date | string
    verifyToken?: StringWithAggregatesFilter<"WhatsAppCloudConnection"> | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    userId?: StringFilter<"VerificationToken"> | string
    email?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type VerificationTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: VerificationTokenEmailTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    userId?: StringFilter<"VerificationToken"> | string
    email?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "token" | "email_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VerificationToken"> | string
    userId?: StringWithAggregatesFilter<"VerificationToken"> | string
    email?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type AccessTokenWhereInput = {
    AND?: AccessTokenWhereInput | AccessTokenWhereInput[]
    OR?: AccessTokenWhereInput[]
    NOT?: AccessTokenWhereInput | AccessTokenWhereInput[]
    id?: StringFilter<"AccessToken"> | string
    userId?: StringFilter<"AccessToken"> | string
    token?: StringFilter<"AccessToken"> | string
    expires?: DateTimeFilter<"AccessToken"> | Date | string
    createdAt?: DateTimeFilter<"AccessToken"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type AccessTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    user?: usersOrderByWithRelationInput
  }

  export type AccessTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: AccessTokenWhereInput | AccessTokenWhereInput[]
    OR?: AccessTokenWhereInput[]
    NOT?: AccessTokenWhereInput | AccessTokenWhereInput[]
    userId?: StringFilter<"AccessToken"> | string
    expires?: DateTimeFilter<"AccessToken"> | Date | string
    createdAt?: DateTimeFilter<"AccessToken"> | Date | string
    user?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "token">

  export type AccessTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
    _count?: AccessTokenCountOrderByAggregateInput
    _max?: AccessTokenMaxOrderByAggregateInput
    _min?: AccessTokenMinOrderByAggregateInput
  }

  export type AccessTokenScalarWhereWithAggregatesInput = {
    AND?: AccessTokenScalarWhereWithAggregatesInput | AccessTokenScalarWhereWithAggregatesInput[]
    OR?: AccessTokenScalarWhereWithAggregatesInput[]
    NOT?: AccessTokenScalarWhereWithAggregatesInput | AccessTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccessToken"> | string
    userId?: StringWithAggregatesFilter<"AccessToken"> | string
    token?: StringWithAggregatesFilter<"AccessToken"> | string
    expires?: DateTimeWithAggregatesFilter<"AccessToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AccessToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    email?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }, "id" | "token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type WorkspaceCreateInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenCreateNestedManyWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    workspace: WorkspaceCreateNestedOneWithoutUsersInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    workspaceId: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutUsersNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    workspaceId: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    features: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    features: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    features: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    features?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces: WorkspaceCreateNestedOneWithoutSystem_configsInput
  }

  export type SystemConfigUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type SystemConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUpdateOneRequiredWithoutSystem_configsNestedInput
  }

  export type SystemConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type SystemConfigCreateManyInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type SystemConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type AdminUserCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserUncheckedCreateInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserCreateManyInput = {
    id?: string
    email: string
    name: string
    password: string
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateInput = {
    id?: string
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutIntegrationsInput
    workspaces: WorkspaceCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    userId: string
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutIntegrationsNestedInput
    workspaces?: WorkspaceUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type IntegrationCreateManyInput = {
    id?: string
    userId: string
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type AgentCreateInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentFunction?: string | null
    agentSkills?: string | null
    assistantId?: string | null
    companyDescription?: string | null
    companyName?: string | null
    companySector?: string | null
    companyWebsite?: string | null
    frequencyPenalty?: number | null
    imageUrl?: string | null
    initialMessage?: string | null
    internalName?: string | null
    language?: string | null
    maxMessages?: number | null
    maxTokens?: number | null
    model?: string | null
    personalityObjective?: string | null
    presencePenalty?: number | null
    productInfo?: string | null
    responseFormat?: string | null
    restrictions?: string | null
    temperature?: number | null
    timezone?: string | null
    vectorStoreId?: string | null
    voiceTone?: string | null
    openaiApiKey?: string | null
    userId: string
    workspace: WorkspaceCreateNestedOneWithoutAgentsInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutAgentInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentFunction?: string | null
    agentSkills?: string | null
    assistantId?: string | null
    companyDescription?: string | null
    companyName?: string | null
    companySector?: string | null
    companyWebsite?: string | null
    frequencyPenalty?: number | null
    imageUrl?: string | null
    initialMessage?: string | null
    internalName?: string | null
    language?: string | null
    maxMessages?: number | null
    maxTokens?: number | null
    model?: string | null
    personalityObjective?: string | null
    presencePenalty?: number | null
    productInfo?: string | null
    responseFormat?: string | null
    restrictions?: string | null
    temperature?: number | null
    timezone?: string | null
    vectorStoreId?: string | null
    voiceTone?: string | null
    openaiApiKey?: string | null
    userId: string
    workspaceId: string
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutAgentInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAgentsNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutAgentNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutAgentNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentFunction?: string | null
    agentSkills?: string | null
    assistantId?: string | null
    companyDescription?: string | null
    companyName?: string | null
    companySector?: string | null
    companyWebsite?: string | null
    frequencyPenalty?: number | null
    imageUrl?: string | null
    initialMessage?: string | null
    internalName?: string | null
    language?: string | null
    maxMessages?: number | null
    maxTokens?: number | null
    model?: string | null
    personalityObjective?: string | null
    presencePenalty?: number | null
    productInfo?: string | null
    responseFormat?: string | null
    restrictions?: string | null
    temperature?: number | null
    timezone?: string | null
    vectorStoreId?: string | null
    voiceTone?: string | null
    openaiApiKey?: string | null
    userId: string
    workspaceId: string
  }

  export type AgentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type FileCreateInput = {
    id?: string
    fileId: string
    filename: string
    purpose: string
    size: number
    type?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutFilesInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    fileId: string
    filename: string
    purpose: string
    size: number
    type?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutFilesNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type FileCreateManyInput = {
    id?: string
    fileId: string
    filename: string
    purpose: string
    size: number
    type?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type VectorStoreCreateInput = {
    id?: string
    name: string
    description?: string | null
    openaiId: string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces: WorkspaceCreateNestedOneWithoutVector_storesInput
  }

  export type VectorStoreUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    openaiId: string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type VectorStoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openaiId?: StringFieldUpdateOperationsInput | string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUpdateOneRequiredWithoutVector_storesNestedInput
  }

  export type VectorStoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openaiId?: StringFieldUpdateOperationsInput | string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type VectorStoreCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    openaiId: string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type VectorStoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openaiId?: StringFieldUpdateOperationsInput | string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VectorStoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openaiId?: StringFieldUpdateOperationsInput | string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactFieldCreateInput = {
    id?: string
    name: string
    type: string
    required?: boolean
    options?: ContactFieldCreateoptionsInput | string[]
    placeholder?: string | null
    default_value?: string | null
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces: WorkspaceCreateNestedOneWithoutContact_fieldsInput
  }

  export type ContactFieldUncheckedCreateInput = {
    id?: string
    name: string
    type: string
    required?: boolean
    options?: ContactFieldCreateoptionsInput | string[]
    placeholder?: string | null
    default_value?: string | null
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type ContactFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: ContactFieldUpdateoptionsInput | string[]
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUpdateOneRequiredWithoutContact_fieldsNestedInput
  }

  export type ContactFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: ContactFieldUpdateoptionsInput | string[]
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactFieldCreateManyInput = {
    id?: string
    name: string
    type: string
    required?: boolean
    options?: ContactFieldCreateoptionsInput | string[]
    placeholder?: string | null
    default_value?: string | null
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type ContactFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: ContactFieldUpdateoptionsInput | string[]
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: ContactFieldUpdateoptionsInput | string[]
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type DisparaJaConnectionCreateInput = {
    id?: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutDisparaJaConnectionsInput
    workspace: WorkspaceCreateNestedOneWithoutDisparaJaConnectionsInput
    logs?: DisparaJaLogCreateNestedManyWithoutConnectionInput
  }

  export type DisparaJaConnectionUncheckedCreateInput = {
    id?: string
    agentId: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
    logs?: DisparaJaLogUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type DisparaJaConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutDisparaJaConnectionsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutDisparaJaConnectionsNestedInput
    logs?: DisparaJaLogUpdateManyWithoutConnectionNestedInput
  }

  export type DisparaJaConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    logs?: DisparaJaLogUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type DisparaJaConnectionCreateManyInput = {
    id?: string
    agentId: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type DisparaJaConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisparaJaConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type DisparaJaLogCreateInput = {
    id?: string
    type: string
    message: string
    timestamp?: Date | string
    connection?: DisparaJaConnectionCreateNestedOneWithoutLogsInput
    workspaces: WorkspaceCreateNestedOneWithoutDispara_ja_logsInput
  }

  export type DisparaJaLogUncheckedCreateInput = {
    id?: string
    connectionId?: string | null
    type: string
    message: string
    timestamp?: Date | string
    workspaceId: string
  }

  export type DisparaJaLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    connection?: DisparaJaConnectionUpdateOneWithoutLogsNestedInput
    workspaces?: WorkspaceUpdateOneRequiredWithoutDispara_ja_logsNestedInput
  }

  export type DisparaJaLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type DisparaJaLogCreateManyInput = {
    id?: string
    connectionId?: string | null
    type: string
    message: string
    timestamp?: Date | string
    workspaceId: string
  }

  export type DisparaJaLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisparaJaLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type LeadCreateInput = {
    id?: string
    name?: string | null
    phone: string
    photo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutLeadInput
    workspace: WorkspaceCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    name?: string | null
    phone: string
    photo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
    conversations?: ConversationUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutLeadNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    conversations?: ConversationUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    name?: string | null
    phone: string
    photo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCreateInput = {
    id?: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lead: LeadCreateNestedOneWithoutConversationsInput
    workspace: WorkspaceCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    leadId: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneRequiredWithoutConversationsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    leadId: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    sender?: string
    read?: boolean
    createdAt?: Date | string
    mediaUrl?: string | null
    updatedAt?: Date | string
    type?: string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    content: string
    sender?: string
    read?: boolean
    createdAt?: Date | string
    mediaUrl?: string | null
    updatedAt?: Date | string
    type?: string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    content: string
    sender?: string
    read?: boolean
    createdAt?: Date | string
    mediaUrl?: string | null
    updatedAt?: Date | string
    type?: string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppCloudConnectionCreateInput = {
    id?: string
    phoneNumberId: string
    accessToken: string
    status?: string
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifyToken?: string
    agent: AgentCreateNestedOneWithoutWhatsappCloudConnectionsInput
    workspace: WorkspaceCreateNestedOneWithoutWhatsappCloudConnectionsInput
  }

  export type WhatsAppCloudConnectionUncheckedCreateInput = {
    id?: string
    agentId: string
    phoneNumberId: string
    accessToken: string
    status?: string
    webhookUrl?: string | null
    workspaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    verifyToken?: string
  }

  export type WhatsAppCloudConnectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyToken?: StringFieldUpdateOperationsInput | string
    agent?: AgentUpdateOneRequiredWithoutWhatsappCloudConnectionsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutWhatsappCloudConnectionsNestedInput
  }

  export type WhatsAppCloudConnectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyToken?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppCloudConnectionCreateManyInput = {
    id?: string
    agentId: string
    phoneNumberId: string
    accessToken: string
    status?: string
    webhookUrl?: string | null
    workspaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    verifyToken?: string
  }

  export type WhatsAppCloudConnectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyToken?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppCloudConnectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyToken?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutVerificationTokensInput
  }

  export type VerificationTokenUncheckedCreateInput = {
    id?: string
    userId: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type VerificationTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutVerificationTokensNestedInput
  }

  export type VerificationTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    id?: string
    userId: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenCreateInput = {
    id?: string
    token: string
    expires: Date | string
    createdAt?: Date | string
    user: usersCreateNestedOneWithoutAccessTokensInput
  }

  export type AccessTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type AccessTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutAccessTokensNestedInput
  }

  export type AccessTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type AccessTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AgentListRelationFilter = {
    every?: AgentWhereInput
    some?: AgentWhereInput
    none?: AgentWhereInput
  }

  export type ContactFieldListRelationFilter = {
    every?: ContactFieldWhereInput
    some?: ContactFieldWhereInput
    none?: ContactFieldWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type DisparaJaConnectionListRelationFilter = {
    every?: DisparaJaConnectionWhereInput
    some?: DisparaJaConnectionWhereInput
    none?: DisparaJaConnectionWhereInput
  }

  export type DisparaJaLogListRelationFilter = {
    every?: DisparaJaLogWhereInput
    some?: DisparaJaLogWhereInput
    none?: DisparaJaLogWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type IntegrationListRelationFilter = {
    every?: IntegrationWhereInput
    some?: IntegrationWhereInput
    none?: IntegrationWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type SystemConfigListRelationFilter = {
    every?: SystemConfigWhereInput
    some?: SystemConfigWhereInput
    none?: SystemConfigWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type VectorStoreListRelationFilter = {
    every?: VectorStoreWhereInput
    some?: VectorStoreWhereInput
    none?: VectorStoreWhereInput
  }

  export type WhatsAppCloudConnectionListRelationFilter = {
    every?: WhatsAppCloudConnectionWhereInput
    some?: WhatsAppCloudConnectionWhereInput
    none?: WhatsAppCloudConnectionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AgentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisparaJaConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DisparaJaLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SystemConfigOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VectorStoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhatsAppCloudConnectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    subdomain?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccessTokenListRelationFilter = {
    every?: AccessTokenWhereInput
    some?: AccessTokenWhereInput
    none?: AccessTokenWhereInput
  }

  export type WorkspaceScalarRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type VerificationTokenListRelationFilter = {
    every?: VerificationTokenWhereInput
    some?: VerificationTokenWhereInput
    none?: VerificationTokenWhereInput
  }

  export type AccessTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VerificationTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    workspaceId?: SortOrder
    emailVerified?: SortOrder
    verifyToken?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    lastLogin?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    workspaceId?: SortOrder
    emailVerified?: SortOrder
    verifyToken?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    lastLogin?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    workspaceId?: SortOrder
    emailVerified?: SortOrder
    verifyToken?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    lastLogin?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    features?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type PlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlanSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type SystemConfigCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type SystemConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type SystemConfigMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type AdminUserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AdminUserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type IntegrationUserIdProviderCompoundUniqueInput = {
    userId: string
    provider: string
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentFunction?: SortOrder
    agentSkills?: SortOrder
    assistantId?: SortOrder
    companyDescription?: SortOrder
    companyName?: SortOrder
    companySector?: SortOrder
    companyWebsite?: SortOrder
    frequencyPenalty?: SortOrder
    imageUrl?: SortOrder
    initialMessage?: SortOrder
    internalName?: SortOrder
    language?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    model?: SortOrder
    personalityObjective?: SortOrder
    presencePenalty?: SortOrder
    productInfo?: SortOrder
    responseFormat?: SortOrder
    restrictions?: SortOrder
    temperature?: SortOrder
    timezone?: SortOrder
    vectorStoreId?: SortOrder
    voiceTone?: SortOrder
    openaiApiKey?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    frequencyPenalty?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    presencePenalty?: SortOrder
    temperature?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentFunction?: SortOrder
    agentSkills?: SortOrder
    assistantId?: SortOrder
    companyDescription?: SortOrder
    companyName?: SortOrder
    companySector?: SortOrder
    companyWebsite?: SortOrder
    frequencyPenalty?: SortOrder
    imageUrl?: SortOrder
    initialMessage?: SortOrder
    internalName?: SortOrder
    language?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    model?: SortOrder
    personalityObjective?: SortOrder
    presencePenalty?: SortOrder
    productInfo?: SortOrder
    responseFormat?: SortOrder
    restrictions?: SortOrder
    temperature?: SortOrder
    timezone?: SortOrder
    vectorStoreId?: SortOrder
    voiceTone?: SortOrder
    openaiApiKey?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    systemPrompt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    agentFunction?: SortOrder
    agentSkills?: SortOrder
    assistantId?: SortOrder
    companyDescription?: SortOrder
    companyName?: SortOrder
    companySector?: SortOrder
    companyWebsite?: SortOrder
    frequencyPenalty?: SortOrder
    imageUrl?: SortOrder
    initialMessage?: SortOrder
    internalName?: SortOrder
    language?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    model?: SortOrder
    personalityObjective?: SortOrder
    presencePenalty?: SortOrder
    productInfo?: SortOrder
    responseFormat?: SortOrder
    restrictions?: SortOrder
    temperature?: SortOrder
    timezone?: SortOrder
    vectorStoreId?: SortOrder
    voiceTone?: SortOrder
    openaiApiKey?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    frequencyPenalty?: SortOrder
    maxMessages?: SortOrder
    maxTokens?: SortOrder
    presencePenalty?: SortOrder
    temperature?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    filename?: SortOrder
    purpose?: SortOrder
    size?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    filename?: SortOrder
    purpose?: SortOrder
    size?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    filename?: SortOrder
    purpose?: SortOrder
    size?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type VectorStoreCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    openaiId?: SortOrder
    files?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type VectorStoreMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    openaiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type VectorStoreMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    openaiId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ContactFieldCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    required?: SortOrder
    options?: SortOrder
    placeholder?: SortOrder
    default_value?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type ContactFieldAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ContactFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    required?: SortOrder
    placeholder?: SortOrder
    default_value?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type ContactFieldMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    required?: SortOrder
    placeholder?: SortOrder
    default_value?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type ContactFieldSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AgentScalarRelationFilter = {
    is?: AgentWhereInput
    isNot?: AgentWhereInput
  }

  export type DisparaJaConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    provider?: SortOrder
    secret?: SortOrder
    sid?: SortOrder
    token?: SortOrder
    phoneNumber?: SortOrder
    unique?: SortOrder
    webhookUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type DisparaJaConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    provider?: SortOrder
    secret?: SortOrder
    sid?: SortOrder
    token?: SortOrder
    phoneNumber?: SortOrder
    unique?: SortOrder
    webhookUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type DisparaJaConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    provider?: SortOrder
    secret?: SortOrder
    sid?: SortOrder
    token?: SortOrder
    phoneNumber?: SortOrder
    unique?: SortOrder
    webhookUrl?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type DisparaJaConnectionNullableScalarRelationFilter = {
    is?: DisparaJaConnectionWhereInput | null
    isNot?: DisparaJaConnectionWhereInput | null
  }

  export type DisparaJaLogCountOrderByAggregateInput = {
    id?: SortOrder
    connectionId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    workspaceId?: SortOrder
  }

  export type DisparaJaLogMaxOrderByAggregateInput = {
    id?: SortOrder
    connectionId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    workspaceId?: SortOrder
  }

  export type DisparaJaLogMinOrderByAggregateInput = {
    id?: SortOrder
    connectionId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    timestamp?: SortOrder
    workspaceId?: SortOrder
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type LeadPhoneWorkspaceIdCompoundUniqueInput = {
    phone: string
    workspaceId: string
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    photo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type LeadScalarRelationFilter = {
    is?: LeadWhereInput
    isNot?: LeadWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    threadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    threadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    leadId?: SortOrder
    threadId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    workspaceId?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    content?: SortOrder
    sender?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    mediaUrl?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    content?: SortOrder
    sender?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    mediaUrl?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    content?: SortOrder
    sender?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    mediaUrl?: SortOrder
    updatedAt?: SortOrder
    type?: SortOrder
  }

  export type WhatsAppCloudConnectionCountOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    phoneNumberId?: SortOrder
    accessToken?: SortOrder
    status?: SortOrder
    webhookUrl?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verifyToken?: SortOrder
  }

  export type WhatsAppCloudConnectionMaxOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    phoneNumberId?: SortOrder
    accessToken?: SortOrder
    status?: SortOrder
    webhookUrl?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verifyToken?: SortOrder
  }

  export type WhatsAppCloudConnectionMinOrderByAggregateInput = {
    id?: SortOrder
    agentId?: SortOrder
    phoneNumberId?: SortOrder
    accessToken?: SortOrder
    status?: SortOrder
    webhookUrl?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    verifyToken?: SortOrder
  }

  export type VerificationTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type AgentCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AgentCreateWithoutWorkspaceInput, AgentUncheckedCreateWithoutWorkspaceInput> | AgentCreateWithoutWorkspaceInput[] | AgentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutWorkspaceInput | AgentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AgentCreateManyWorkspaceInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type ContactFieldCreateNestedManyWithoutWorkspacesInput = {
    create?: XOR<ContactFieldCreateWithoutWorkspacesInput, ContactFieldUncheckedCreateWithoutWorkspacesInput> | ContactFieldCreateWithoutWorkspacesInput[] | ContactFieldUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: ContactFieldCreateOrConnectWithoutWorkspacesInput | ContactFieldCreateOrConnectWithoutWorkspacesInput[]
    createMany?: ContactFieldCreateManyWorkspacesInputEnvelope
    connect?: ContactFieldWhereUniqueInput | ContactFieldWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ConversationCreateWithoutWorkspaceInput, ConversationUncheckedCreateWithoutWorkspaceInput> | ConversationCreateWithoutWorkspaceInput[] | ConversationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutWorkspaceInput | ConversationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ConversationCreateManyWorkspaceInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<DisparaJaConnectionCreateWithoutWorkspaceInput, DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput> | DisparaJaConnectionCreateWithoutWorkspaceInput[] | DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DisparaJaConnectionCreateOrConnectWithoutWorkspaceInput | DisparaJaConnectionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: DisparaJaConnectionCreateManyWorkspaceInputEnvelope
    connect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
  }

  export type DisparaJaLogCreateNestedManyWithoutWorkspacesInput = {
    create?: XOR<DisparaJaLogCreateWithoutWorkspacesInput, DisparaJaLogUncheckedCreateWithoutWorkspacesInput> | DisparaJaLogCreateWithoutWorkspacesInput[] | DisparaJaLogUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: DisparaJaLogCreateOrConnectWithoutWorkspacesInput | DisparaJaLogCreateOrConnectWithoutWorkspacesInput[]
    createMany?: DisparaJaLogCreateManyWorkspacesInputEnvelope
    connect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput> | FileCreateWithoutWorkspaceInput[] | FileUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutWorkspaceInput | FileCreateOrConnectWithoutWorkspaceInput[]
    createMany?: FileCreateManyWorkspaceInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutWorkspacesInput = {
    create?: XOR<IntegrationCreateWithoutWorkspacesInput, IntegrationUncheckedCreateWithoutWorkspacesInput> | IntegrationCreateWithoutWorkspacesInput[] | IntegrationUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutWorkspacesInput | IntegrationCreateOrConnectWithoutWorkspacesInput[]
    createMany?: IntegrationCreateManyWorkspacesInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LeadCreateWithoutWorkspaceInput, LeadUncheckedCreateWithoutWorkspaceInput> | LeadCreateWithoutWorkspaceInput[] | LeadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutWorkspaceInput | LeadCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LeadCreateManyWorkspaceInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type SystemConfigCreateNestedManyWithoutWorkspacesInput = {
    create?: XOR<SystemConfigCreateWithoutWorkspacesInput, SystemConfigUncheckedCreateWithoutWorkspacesInput> | SystemConfigCreateWithoutWorkspacesInput[] | SystemConfigUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: SystemConfigCreateOrConnectWithoutWorkspacesInput | SystemConfigCreateOrConnectWithoutWorkspacesInput[]
    createMany?: SystemConfigCreateManyWorkspacesInputEnvelope
    connect?: SystemConfigWhereUniqueInput | SystemConfigWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<usersCreateWithoutWorkspaceInput, usersUncheckedCreateWithoutWorkspaceInput> | usersCreateWithoutWorkspaceInput[] | usersUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: usersCreateOrConnectWithoutWorkspaceInput | usersCreateOrConnectWithoutWorkspaceInput[]
    createMany?: usersCreateManyWorkspaceInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type VectorStoreCreateNestedManyWithoutWorkspacesInput = {
    create?: XOR<VectorStoreCreateWithoutWorkspacesInput, VectorStoreUncheckedCreateWithoutWorkspacesInput> | VectorStoreCreateWithoutWorkspacesInput[] | VectorStoreUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: VectorStoreCreateOrConnectWithoutWorkspacesInput | VectorStoreCreateOrConnectWithoutWorkspacesInput[]
    createMany?: VectorStoreCreateManyWorkspacesInputEnvelope
    connect?: VectorStoreWhereUniqueInput | VectorStoreWhereUniqueInput[]
  }

  export type WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WhatsAppCloudConnectionCreateWithoutWorkspaceInput, WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput> | WhatsAppCloudConnectionCreateWithoutWorkspaceInput[] | WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WhatsAppCloudConnectionCreateOrConnectWithoutWorkspaceInput | WhatsAppCloudConnectionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WhatsAppCloudConnectionCreateManyWorkspaceInputEnvelope
    connect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
  }

  export type AgentUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<AgentCreateWithoutWorkspaceInput, AgentUncheckedCreateWithoutWorkspaceInput> | AgentCreateWithoutWorkspaceInput[] | AgentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutWorkspaceInput | AgentCreateOrConnectWithoutWorkspaceInput[]
    createMany?: AgentCreateManyWorkspaceInputEnvelope
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
  }

  export type ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput = {
    create?: XOR<ContactFieldCreateWithoutWorkspacesInput, ContactFieldUncheckedCreateWithoutWorkspacesInput> | ContactFieldCreateWithoutWorkspacesInput[] | ContactFieldUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: ContactFieldCreateOrConnectWithoutWorkspacesInput | ContactFieldCreateOrConnectWithoutWorkspacesInput[]
    createMany?: ContactFieldCreateManyWorkspacesInputEnvelope
    connect?: ContactFieldWhereUniqueInput | ContactFieldWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ConversationCreateWithoutWorkspaceInput, ConversationUncheckedCreateWithoutWorkspaceInput> | ConversationCreateWithoutWorkspaceInput[] | ConversationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutWorkspaceInput | ConversationCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ConversationCreateManyWorkspaceInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<DisparaJaConnectionCreateWithoutWorkspaceInput, DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput> | DisparaJaConnectionCreateWithoutWorkspaceInput[] | DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DisparaJaConnectionCreateOrConnectWithoutWorkspaceInput | DisparaJaConnectionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: DisparaJaConnectionCreateManyWorkspaceInputEnvelope
    connect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
  }

  export type DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput = {
    create?: XOR<DisparaJaLogCreateWithoutWorkspacesInput, DisparaJaLogUncheckedCreateWithoutWorkspacesInput> | DisparaJaLogCreateWithoutWorkspacesInput[] | DisparaJaLogUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: DisparaJaLogCreateOrConnectWithoutWorkspacesInput | DisparaJaLogCreateOrConnectWithoutWorkspacesInput[]
    createMany?: DisparaJaLogCreateManyWorkspacesInputEnvelope
    connect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput> | FileCreateWithoutWorkspaceInput[] | FileUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutWorkspaceInput | FileCreateOrConnectWithoutWorkspaceInput[]
    createMany?: FileCreateManyWorkspaceInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput = {
    create?: XOR<IntegrationCreateWithoutWorkspacesInput, IntegrationUncheckedCreateWithoutWorkspacesInput> | IntegrationCreateWithoutWorkspacesInput[] | IntegrationUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutWorkspacesInput | IntegrationCreateOrConnectWithoutWorkspacesInput[]
    createMany?: IntegrationCreateManyWorkspacesInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<LeadCreateWithoutWorkspaceInput, LeadUncheckedCreateWithoutWorkspaceInput> | LeadCreateWithoutWorkspaceInput[] | LeadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutWorkspaceInput | LeadCreateOrConnectWithoutWorkspaceInput[]
    createMany?: LeadCreateManyWorkspaceInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput = {
    create?: XOR<SystemConfigCreateWithoutWorkspacesInput, SystemConfigUncheckedCreateWithoutWorkspacesInput> | SystemConfigCreateWithoutWorkspacesInput[] | SystemConfigUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: SystemConfigCreateOrConnectWithoutWorkspacesInput | SystemConfigCreateOrConnectWithoutWorkspacesInput[]
    createMany?: SystemConfigCreateManyWorkspacesInputEnvelope
    connect?: SystemConfigWhereUniqueInput | SystemConfigWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<usersCreateWithoutWorkspaceInput, usersUncheckedCreateWithoutWorkspaceInput> | usersCreateWithoutWorkspaceInput[] | usersUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: usersCreateOrConnectWithoutWorkspaceInput | usersCreateOrConnectWithoutWorkspaceInput[]
    createMany?: usersCreateManyWorkspaceInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput = {
    create?: XOR<VectorStoreCreateWithoutWorkspacesInput, VectorStoreUncheckedCreateWithoutWorkspacesInput> | VectorStoreCreateWithoutWorkspacesInput[] | VectorStoreUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: VectorStoreCreateOrConnectWithoutWorkspacesInput | VectorStoreCreateOrConnectWithoutWorkspacesInput[]
    createMany?: VectorStoreCreateManyWorkspacesInputEnvelope
    connect?: VectorStoreWhereUniqueInput | VectorStoreWhereUniqueInput[]
  }

  export type WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WhatsAppCloudConnectionCreateWithoutWorkspaceInput, WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput> | WhatsAppCloudConnectionCreateWithoutWorkspaceInput[] | WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WhatsAppCloudConnectionCreateOrConnectWithoutWorkspaceInput | WhatsAppCloudConnectionCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WhatsAppCloudConnectionCreateManyWorkspaceInputEnvelope
    connect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AgentUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AgentCreateWithoutWorkspaceInput, AgentUncheckedCreateWithoutWorkspaceInput> | AgentCreateWithoutWorkspaceInput[] | AgentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutWorkspaceInput | AgentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutWorkspaceInput | AgentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AgentCreateManyWorkspaceInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutWorkspaceInput | AgentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutWorkspaceInput | AgentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type ContactFieldUpdateManyWithoutWorkspacesNestedInput = {
    create?: XOR<ContactFieldCreateWithoutWorkspacesInput, ContactFieldUncheckedCreateWithoutWorkspacesInput> | ContactFieldCreateWithoutWorkspacesInput[] | ContactFieldUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: ContactFieldCreateOrConnectWithoutWorkspacesInput | ContactFieldCreateOrConnectWithoutWorkspacesInput[]
    upsert?: ContactFieldUpsertWithWhereUniqueWithoutWorkspacesInput | ContactFieldUpsertWithWhereUniqueWithoutWorkspacesInput[]
    createMany?: ContactFieldCreateManyWorkspacesInputEnvelope
    set?: ContactFieldWhereUniqueInput | ContactFieldWhereUniqueInput[]
    disconnect?: ContactFieldWhereUniqueInput | ContactFieldWhereUniqueInput[]
    delete?: ContactFieldWhereUniqueInput | ContactFieldWhereUniqueInput[]
    connect?: ContactFieldWhereUniqueInput | ContactFieldWhereUniqueInput[]
    update?: ContactFieldUpdateWithWhereUniqueWithoutWorkspacesInput | ContactFieldUpdateWithWhereUniqueWithoutWorkspacesInput[]
    updateMany?: ContactFieldUpdateManyWithWhereWithoutWorkspacesInput | ContactFieldUpdateManyWithWhereWithoutWorkspacesInput[]
    deleteMany?: ContactFieldScalarWhereInput | ContactFieldScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ConversationCreateWithoutWorkspaceInput, ConversationUncheckedCreateWithoutWorkspaceInput> | ConversationCreateWithoutWorkspaceInput[] | ConversationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutWorkspaceInput | ConversationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutWorkspaceInput | ConversationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ConversationCreateManyWorkspaceInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutWorkspaceInput | ConversationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutWorkspaceInput | ConversationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<DisparaJaConnectionCreateWithoutWorkspaceInput, DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput> | DisparaJaConnectionCreateWithoutWorkspaceInput[] | DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DisparaJaConnectionCreateOrConnectWithoutWorkspaceInput | DisparaJaConnectionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: DisparaJaConnectionUpsertWithWhereUniqueWithoutWorkspaceInput | DisparaJaConnectionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: DisparaJaConnectionCreateManyWorkspaceInputEnvelope
    set?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    disconnect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    delete?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    connect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    update?: DisparaJaConnectionUpdateWithWhereUniqueWithoutWorkspaceInput | DisparaJaConnectionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: DisparaJaConnectionUpdateManyWithWhereWithoutWorkspaceInput | DisparaJaConnectionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: DisparaJaConnectionScalarWhereInput | DisparaJaConnectionScalarWhereInput[]
  }

  export type DisparaJaLogUpdateManyWithoutWorkspacesNestedInput = {
    create?: XOR<DisparaJaLogCreateWithoutWorkspacesInput, DisparaJaLogUncheckedCreateWithoutWorkspacesInput> | DisparaJaLogCreateWithoutWorkspacesInput[] | DisparaJaLogUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: DisparaJaLogCreateOrConnectWithoutWorkspacesInput | DisparaJaLogCreateOrConnectWithoutWorkspacesInput[]
    upsert?: DisparaJaLogUpsertWithWhereUniqueWithoutWorkspacesInput | DisparaJaLogUpsertWithWhereUniqueWithoutWorkspacesInput[]
    createMany?: DisparaJaLogCreateManyWorkspacesInputEnvelope
    set?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    disconnect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    delete?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    connect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    update?: DisparaJaLogUpdateWithWhereUniqueWithoutWorkspacesInput | DisparaJaLogUpdateWithWhereUniqueWithoutWorkspacesInput[]
    updateMany?: DisparaJaLogUpdateManyWithWhereWithoutWorkspacesInput | DisparaJaLogUpdateManyWithWhereWithoutWorkspacesInput[]
    deleteMany?: DisparaJaLogScalarWhereInput | DisparaJaLogScalarWhereInput[]
  }

  export type FileUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput> | FileCreateWithoutWorkspaceInput[] | FileUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutWorkspaceInput | FileCreateOrConnectWithoutWorkspaceInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutWorkspaceInput | FileUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: FileCreateManyWorkspaceInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutWorkspaceInput | FileUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: FileUpdateManyWithWhereWithoutWorkspaceInput | FileUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutWorkspacesNestedInput = {
    create?: XOR<IntegrationCreateWithoutWorkspacesInput, IntegrationUncheckedCreateWithoutWorkspacesInput> | IntegrationCreateWithoutWorkspacesInput[] | IntegrationUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutWorkspacesInput | IntegrationCreateOrConnectWithoutWorkspacesInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutWorkspacesInput | IntegrationUpsertWithWhereUniqueWithoutWorkspacesInput[]
    createMany?: IntegrationCreateManyWorkspacesInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutWorkspacesInput | IntegrationUpdateWithWhereUniqueWithoutWorkspacesInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutWorkspacesInput | IntegrationUpdateManyWithWhereWithoutWorkspacesInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LeadCreateWithoutWorkspaceInput, LeadUncheckedCreateWithoutWorkspaceInput> | LeadCreateWithoutWorkspaceInput[] | LeadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutWorkspaceInput | LeadCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutWorkspaceInput | LeadUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LeadCreateManyWorkspaceInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutWorkspaceInput | LeadUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutWorkspaceInput | LeadUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type SystemConfigUpdateManyWithoutWorkspacesNestedInput = {
    create?: XOR<SystemConfigCreateWithoutWorkspacesInput, SystemConfigUncheckedCreateWithoutWorkspacesInput> | SystemConfigCreateWithoutWorkspacesInput[] | SystemConfigUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: SystemConfigCreateOrConnectWithoutWorkspacesInput | SystemConfigCreateOrConnectWithoutWorkspacesInput[]
    upsert?: SystemConfigUpsertWithWhereUniqueWithoutWorkspacesInput | SystemConfigUpsertWithWhereUniqueWithoutWorkspacesInput[]
    createMany?: SystemConfigCreateManyWorkspacesInputEnvelope
    set?: SystemConfigWhereUniqueInput | SystemConfigWhereUniqueInput[]
    disconnect?: SystemConfigWhereUniqueInput | SystemConfigWhereUniqueInput[]
    delete?: SystemConfigWhereUniqueInput | SystemConfigWhereUniqueInput[]
    connect?: SystemConfigWhereUniqueInput | SystemConfigWhereUniqueInput[]
    update?: SystemConfigUpdateWithWhereUniqueWithoutWorkspacesInput | SystemConfigUpdateWithWhereUniqueWithoutWorkspacesInput[]
    updateMany?: SystemConfigUpdateManyWithWhereWithoutWorkspacesInput | SystemConfigUpdateManyWithWhereWithoutWorkspacesInput[]
    deleteMany?: SystemConfigScalarWhereInput | SystemConfigScalarWhereInput[]
  }

  export type usersUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<usersCreateWithoutWorkspaceInput, usersUncheckedCreateWithoutWorkspaceInput> | usersCreateWithoutWorkspaceInput[] | usersUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: usersCreateOrConnectWithoutWorkspaceInput | usersCreateOrConnectWithoutWorkspaceInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutWorkspaceInput | usersUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: usersCreateManyWorkspaceInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutWorkspaceInput | usersUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: usersUpdateManyWithWhereWithoutWorkspaceInput | usersUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type VectorStoreUpdateManyWithoutWorkspacesNestedInput = {
    create?: XOR<VectorStoreCreateWithoutWorkspacesInput, VectorStoreUncheckedCreateWithoutWorkspacesInput> | VectorStoreCreateWithoutWorkspacesInput[] | VectorStoreUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: VectorStoreCreateOrConnectWithoutWorkspacesInput | VectorStoreCreateOrConnectWithoutWorkspacesInput[]
    upsert?: VectorStoreUpsertWithWhereUniqueWithoutWorkspacesInput | VectorStoreUpsertWithWhereUniqueWithoutWorkspacesInput[]
    createMany?: VectorStoreCreateManyWorkspacesInputEnvelope
    set?: VectorStoreWhereUniqueInput | VectorStoreWhereUniqueInput[]
    disconnect?: VectorStoreWhereUniqueInput | VectorStoreWhereUniqueInput[]
    delete?: VectorStoreWhereUniqueInput | VectorStoreWhereUniqueInput[]
    connect?: VectorStoreWhereUniqueInput | VectorStoreWhereUniqueInput[]
    update?: VectorStoreUpdateWithWhereUniqueWithoutWorkspacesInput | VectorStoreUpdateWithWhereUniqueWithoutWorkspacesInput[]
    updateMany?: VectorStoreUpdateManyWithWhereWithoutWorkspacesInput | VectorStoreUpdateManyWithWhereWithoutWorkspacesInput[]
    deleteMany?: VectorStoreScalarWhereInput | VectorStoreScalarWhereInput[]
  }

  export type WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WhatsAppCloudConnectionCreateWithoutWorkspaceInput, WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput> | WhatsAppCloudConnectionCreateWithoutWorkspaceInput[] | WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WhatsAppCloudConnectionCreateOrConnectWithoutWorkspaceInput | WhatsAppCloudConnectionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WhatsAppCloudConnectionUpsertWithWhereUniqueWithoutWorkspaceInput | WhatsAppCloudConnectionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WhatsAppCloudConnectionCreateManyWorkspaceInputEnvelope
    set?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    disconnect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    delete?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    connect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    update?: WhatsAppCloudConnectionUpdateWithWhereUniqueWithoutWorkspaceInput | WhatsAppCloudConnectionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WhatsAppCloudConnectionUpdateManyWithWhereWithoutWorkspaceInput | WhatsAppCloudConnectionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WhatsAppCloudConnectionScalarWhereInput | WhatsAppCloudConnectionScalarWhereInput[]
  }

  export type AgentUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<AgentCreateWithoutWorkspaceInput, AgentUncheckedCreateWithoutWorkspaceInput> | AgentCreateWithoutWorkspaceInput[] | AgentUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: AgentCreateOrConnectWithoutWorkspaceInput | AgentCreateOrConnectWithoutWorkspaceInput[]
    upsert?: AgentUpsertWithWhereUniqueWithoutWorkspaceInput | AgentUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: AgentCreateManyWorkspaceInputEnvelope
    set?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    disconnect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    delete?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    connect?: AgentWhereUniqueInput | AgentWhereUniqueInput[]
    update?: AgentUpdateWithWhereUniqueWithoutWorkspaceInput | AgentUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: AgentUpdateManyWithWhereWithoutWorkspaceInput | AgentUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: AgentScalarWhereInput | AgentScalarWhereInput[]
  }

  export type ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput = {
    create?: XOR<ContactFieldCreateWithoutWorkspacesInput, ContactFieldUncheckedCreateWithoutWorkspacesInput> | ContactFieldCreateWithoutWorkspacesInput[] | ContactFieldUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: ContactFieldCreateOrConnectWithoutWorkspacesInput | ContactFieldCreateOrConnectWithoutWorkspacesInput[]
    upsert?: ContactFieldUpsertWithWhereUniqueWithoutWorkspacesInput | ContactFieldUpsertWithWhereUniqueWithoutWorkspacesInput[]
    createMany?: ContactFieldCreateManyWorkspacesInputEnvelope
    set?: ContactFieldWhereUniqueInput | ContactFieldWhereUniqueInput[]
    disconnect?: ContactFieldWhereUniqueInput | ContactFieldWhereUniqueInput[]
    delete?: ContactFieldWhereUniqueInput | ContactFieldWhereUniqueInput[]
    connect?: ContactFieldWhereUniqueInput | ContactFieldWhereUniqueInput[]
    update?: ContactFieldUpdateWithWhereUniqueWithoutWorkspacesInput | ContactFieldUpdateWithWhereUniqueWithoutWorkspacesInput[]
    updateMany?: ContactFieldUpdateManyWithWhereWithoutWorkspacesInput | ContactFieldUpdateManyWithWhereWithoutWorkspacesInput[]
    deleteMany?: ContactFieldScalarWhereInput | ContactFieldScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ConversationCreateWithoutWorkspaceInput, ConversationUncheckedCreateWithoutWorkspaceInput> | ConversationCreateWithoutWorkspaceInput[] | ConversationUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutWorkspaceInput | ConversationCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutWorkspaceInput | ConversationUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ConversationCreateManyWorkspaceInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutWorkspaceInput | ConversationUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutWorkspaceInput | ConversationUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<DisparaJaConnectionCreateWithoutWorkspaceInput, DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput> | DisparaJaConnectionCreateWithoutWorkspaceInput[] | DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: DisparaJaConnectionCreateOrConnectWithoutWorkspaceInput | DisparaJaConnectionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: DisparaJaConnectionUpsertWithWhereUniqueWithoutWorkspaceInput | DisparaJaConnectionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: DisparaJaConnectionCreateManyWorkspaceInputEnvelope
    set?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    disconnect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    delete?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    connect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    update?: DisparaJaConnectionUpdateWithWhereUniqueWithoutWorkspaceInput | DisparaJaConnectionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: DisparaJaConnectionUpdateManyWithWhereWithoutWorkspaceInput | DisparaJaConnectionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: DisparaJaConnectionScalarWhereInput | DisparaJaConnectionScalarWhereInput[]
  }

  export type DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput = {
    create?: XOR<DisparaJaLogCreateWithoutWorkspacesInput, DisparaJaLogUncheckedCreateWithoutWorkspacesInput> | DisparaJaLogCreateWithoutWorkspacesInput[] | DisparaJaLogUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: DisparaJaLogCreateOrConnectWithoutWorkspacesInput | DisparaJaLogCreateOrConnectWithoutWorkspacesInput[]
    upsert?: DisparaJaLogUpsertWithWhereUniqueWithoutWorkspacesInput | DisparaJaLogUpsertWithWhereUniqueWithoutWorkspacesInput[]
    createMany?: DisparaJaLogCreateManyWorkspacesInputEnvelope
    set?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    disconnect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    delete?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    connect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    update?: DisparaJaLogUpdateWithWhereUniqueWithoutWorkspacesInput | DisparaJaLogUpdateWithWhereUniqueWithoutWorkspacesInput[]
    updateMany?: DisparaJaLogUpdateManyWithWhereWithoutWorkspacesInput | DisparaJaLogUpdateManyWithWhereWithoutWorkspacesInput[]
    deleteMany?: DisparaJaLogScalarWhereInput | DisparaJaLogScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput> | FileCreateWithoutWorkspaceInput[] | FileUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: FileCreateOrConnectWithoutWorkspaceInput | FileCreateOrConnectWithoutWorkspaceInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutWorkspaceInput | FileUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: FileCreateManyWorkspaceInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutWorkspaceInput | FileUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: FileUpdateManyWithWhereWithoutWorkspaceInput | FileUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput = {
    create?: XOR<IntegrationCreateWithoutWorkspacesInput, IntegrationUncheckedCreateWithoutWorkspacesInput> | IntegrationCreateWithoutWorkspacesInput[] | IntegrationUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutWorkspacesInput | IntegrationCreateOrConnectWithoutWorkspacesInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutWorkspacesInput | IntegrationUpsertWithWhereUniqueWithoutWorkspacesInput[]
    createMany?: IntegrationCreateManyWorkspacesInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutWorkspacesInput | IntegrationUpdateWithWhereUniqueWithoutWorkspacesInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutWorkspacesInput | IntegrationUpdateManyWithWhereWithoutWorkspacesInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<LeadCreateWithoutWorkspaceInput, LeadUncheckedCreateWithoutWorkspaceInput> | LeadCreateWithoutWorkspaceInput[] | LeadUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutWorkspaceInput | LeadCreateOrConnectWithoutWorkspaceInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutWorkspaceInput | LeadUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: LeadCreateManyWorkspaceInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutWorkspaceInput | LeadUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutWorkspaceInput | LeadUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput = {
    create?: XOR<SystemConfigCreateWithoutWorkspacesInput, SystemConfigUncheckedCreateWithoutWorkspacesInput> | SystemConfigCreateWithoutWorkspacesInput[] | SystemConfigUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: SystemConfigCreateOrConnectWithoutWorkspacesInput | SystemConfigCreateOrConnectWithoutWorkspacesInput[]
    upsert?: SystemConfigUpsertWithWhereUniqueWithoutWorkspacesInput | SystemConfigUpsertWithWhereUniqueWithoutWorkspacesInput[]
    createMany?: SystemConfigCreateManyWorkspacesInputEnvelope
    set?: SystemConfigWhereUniqueInput | SystemConfigWhereUniqueInput[]
    disconnect?: SystemConfigWhereUniqueInput | SystemConfigWhereUniqueInput[]
    delete?: SystemConfigWhereUniqueInput | SystemConfigWhereUniqueInput[]
    connect?: SystemConfigWhereUniqueInput | SystemConfigWhereUniqueInput[]
    update?: SystemConfigUpdateWithWhereUniqueWithoutWorkspacesInput | SystemConfigUpdateWithWhereUniqueWithoutWorkspacesInput[]
    updateMany?: SystemConfigUpdateManyWithWhereWithoutWorkspacesInput | SystemConfigUpdateManyWithWhereWithoutWorkspacesInput[]
    deleteMany?: SystemConfigScalarWhereInput | SystemConfigScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<usersCreateWithoutWorkspaceInput, usersUncheckedCreateWithoutWorkspaceInput> | usersCreateWithoutWorkspaceInput[] | usersUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: usersCreateOrConnectWithoutWorkspaceInput | usersCreateOrConnectWithoutWorkspaceInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutWorkspaceInput | usersUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: usersCreateManyWorkspaceInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutWorkspaceInput | usersUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: usersUpdateManyWithWhereWithoutWorkspaceInput | usersUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput = {
    create?: XOR<VectorStoreCreateWithoutWorkspacesInput, VectorStoreUncheckedCreateWithoutWorkspacesInput> | VectorStoreCreateWithoutWorkspacesInput[] | VectorStoreUncheckedCreateWithoutWorkspacesInput[]
    connectOrCreate?: VectorStoreCreateOrConnectWithoutWorkspacesInput | VectorStoreCreateOrConnectWithoutWorkspacesInput[]
    upsert?: VectorStoreUpsertWithWhereUniqueWithoutWorkspacesInput | VectorStoreUpsertWithWhereUniqueWithoutWorkspacesInput[]
    createMany?: VectorStoreCreateManyWorkspacesInputEnvelope
    set?: VectorStoreWhereUniqueInput | VectorStoreWhereUniqueInput[]
    disconnect?: VectorStoreWhereUniqueInput | VectorStoreWhereUniqueInput[]
    delete?: VectorStoreWhereUniqueInput | VectorStoreWhereUniqueInput[]
    connect?: VectorStoreWhereUniqueInput | VectorStoreWhereUniqueInput[]
    update?: VectorStoreUpdateWithWhereUniqueWithoutWorkspacesInput | VectorStoreUpdateWithWhereUniqueWithoutWorkspacesInput[]
    updateMany?: VectorStoreUpdateManyWithWhereWithoutWorkspacesInput | VectorStoreUpdateManyWithWhereWithoutWorkspacesInput[]
    deleteMany?: VectorStoreScalarWhereInput | VectorStoreScalarWhereInput[]
  }

  export type WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WhatsAppCloudConnectionCreateWithoutWorkspaceInput, WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput> | WhatsAppCloudConnectionCreateWithoutWorkspaceInput[] | WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WhatsAppCloudConnectionCreateOrConnectWithoutWorkspaceInput | WhatsAppCloudConnectionCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WhatsAppCloudConnectionUpsertWithWhereUniqueWithoutWorkspaceInput | WhatsAppCloudConnectionUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WhatsAppCloudConnectionCreateManyWorkspaceInputEnvelope
    set?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    disconnect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    delete?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    connect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    update?: WhatsAppCloudConnectionUpdateWithWhereUniqueWithoutWorkspaceInput | WhatsAppCloudConnectionUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WhatsAppCloudConnectionUpdateManyWithWhereWithoutWorkspaceInput | WhatsAppCloudConnectionUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WhatsAppCloudConnectionScalarWhereInput | WhatsAppCloudConnectionScalarWhereInput[]
  }

  export type AccessTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutUserInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type WorkspaceCreateNestedOneWithoutUsersInput = {
    create?: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUsersInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type VerificationTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput> | VerificationTokenCreateWithoutUserInput[] | VerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutUserInput | VerificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: VerificationTokenCreateManyUserInputEnvelope
    connect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
  }

  export type AccessTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type VerificationTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput> | VerificationTokenCreateWithoutUserInput[] | VerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutUserInput | VerificationTokenCreateOrConnectWithoutUserInput[]
    createMany?: VerificationTokenCreateManyUserInputEnvelope
    connect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccessTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    upsert?: AccessTokenUpsertWithWhereUniqueWithoutUserInput | AccessTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    set?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    disconnect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    delete?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    update?: AccessTokenUpdateWithWhereUniqueWithoutUserInput | AccessTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccessTokenUpdateManyWithWhereWithoutUserInput | AccessTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutUserInput | IntegrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutUserInput | IntegrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutUserInput | IntegrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUsersInput
    upsert?: WorkspaceUpsertWithoutUsersInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutUsersInput, WorkspaceUpdateWithoutUsersInput>, WorkspaceUncheckedUpdateWithoutUsersInput>
  }

  export type VerificationTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput> | VerificationTokenCreateWithoutUserInput[] | VerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutUserInput | VerificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: VerificationTokenUpsertWithWhereUniqueWithoutUserInput | VerificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationTokenCreateManyUserInputEnvelope
    set?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    disconnect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    delete?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    connect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    update?: VerificationTokenUpdateWithWhereUniqueWithoutUserInput | VerificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationTokenUpdateManyWithWhereWithoutUserInput | VerificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationTokenScalarWhereInput | VerificationTokenScalarWhereInput[]
  }

  export type AccessTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput> | AccessTokenCreateWithoutUserInput[] | AccessTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccessTokenCreateOrConnectWithoutUserInput | AccessTokenCreateOrConnectWithoutUserInput[]
    upsert?: AccessTokenUpsertWithWhereUniqueWithoutUserInput | AccessTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccessTokenCreateManyUserInputEnvelope
    set?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    disconnect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    delete?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    connect?: AccessTokenWhereUniqueInput | AccessTokenWhereUniqueInput[]
    update?: AccessTokenUpdateWithWhereUniqueWithoutUserInput | AccessTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccessTokenUpdateManyWithWhereWithoutUserInput | AccessTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput> | IntegrationCreateWithoutUserInput[] | IntegrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutUserInput | IntegrationCreateOrConnectWithoutUserInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutUserInput | IntegrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: IntegrationCreateManyUserInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutUserInput | IntegrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutUserInput | IntegrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type VerificationTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput> | VerificationTokenCreateWithoutUserInput[] | VerificationTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: VerificationTokenCreateOrConnectWithoutUserInput | VerificationTokenCreateOrConnectWithoutUserInput[]
    upsert?: VerificationTokenUpsertWithWhereUniqueWithoutUserInput | VerificationTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: VerificationTokenCreateManyUserInputEnvelope
    set?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    disconnect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    delete?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    connect?: VerificationTokenWhereUniqueInput | VerificationTokenWhereUniqueInput[]
    update?: VerificationTokenUpdateWithWhereUniqueWithoutUserInput | VerificationTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: VerificationTokenUpdateManyWithWhereWithoutUserInput | VerificationTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: VerificationTokenScalarWhereInput | VerificationTokenScalarWhereInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkspaceCreateNestedOneWithoutSystem_configsInput = {
    create?: XOR<WorkspaceCreateWithoutSystem_configsInput, WorkspaceUncheckedCreateWithoutSystem_configsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSystem_configsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutSystem_configsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutSystem_configsInput, WorkspaceUncheckedCreateWithoutSystem_configsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutSystem_configsInput
    upsert?: WorkspaceUpsertWithoutSystem_configsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutSystem_configsInput, WorkspaceUpdateWithoutSystem_configsInput>, WorkspaceUncheckedUpdateWithoutSystem_configsInput>
  }

  export type usersCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<usersCreateWithoutIntegrationsInput, usersUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutIntegrationsInput
    connect?: usersWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<WorkspaceCreateWithoutIntegrationsInput, WorkspaceUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutIntegrationsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<usersCreateWithoutIntegrationsInput, usersUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutIntegrationsInput
    upsert?: usersUpsertWithoutIntegrationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutIntegrationsInput, usersUpdateWithoutIntegrationsInput>, usersUncheckedUpdateWithoutIntegrationsInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutIntegrationsInput, WorkspaceUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutIntegrationsInput
    upsert?: WorkspaceUpsertWithoutIntegrationsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutIntegrationsInput, WorkspaceUpdateWithoutIntegrationsInput>, WorkspaceUncheckedUpdateWithoutIntegrationsInput>
  }

  export type WorkspaceCreateNestedOneWithoutAgentsInput = {
    create?: XOR<WorkspaceCreateWithoutAgentsInput, WorkspaceUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAgentsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type DisparaJaConnectionCreateNestedManyWithoutAgentInput = {
    create?: XOR<DisparaJaConnectionCreateWithoutAgentInput, DisparaJaConnectionUncheckedCreateWithoutAgentInput> | DisparaJaConnectionCreateWithoutAgentInput[] | DisparaJaConnectionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: DisparaJaConnectionCreateOrConnectWithoutAgentInput | DisparaJaConnectionCreateOrConnectWithoutAgentInput[]
    createMany?: DisparaJaConnectionCreateManyAgentInputEnvelope
    connect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
  }

  export type WhatsAppCloudConnectionCreateNestedManyWithoutAgentInput = {
    create?: XOR<WhatsAppCloudConnectionCreateWithoutAgentInput, WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput> | WhatsAppCloudConnectionCreateWithoutAgentInput[] | WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: WhatsAppCloudConnectionCreateOrConnectWithoutAgentInput | WhatsAppCloudConnectionCreateOrConnectWithoutAgentInput[]
    createMany?: WhatsAppCloudConnectionCreateManyAgentInputEnvelope
    connect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
  }

  export type DisparaJaConnectionUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<DisparaJaConnectionCreateWithoutAgentInput, DisparaJaConnectionUncheckedCreateWithoutAgentInput> | DisparaJaConnectionCreateWithoutAgentInput[] | DisparaJaConnectionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: DisparaJaConnectionCreateOrConnectWithoutAgentInput | DisparaJaConnectionCreateOrConnectWithoutAgentInput[]
    createMany?: DisparaJaConnectionCreateManyAgentInputEnvelope
    connect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
  }

  export type WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<WhatsAppCloudConnectionCreateWithoutAgentInput, WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput> | WhatsAppCloudConnectionCreateWithoutAgentInput[] | WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: WhatsAppCloudConnectionCreateOrConnectWithoutAgentInput | WhatsAppCloudConnectionCreateOrConnectWithoutAgentInput[]
    createMany?: WhatsAppCloudConnectionCreateManyAgentInputEnvelope
    connect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkspaceUpdateOneRequiredWithoutAgentsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutAgentsInput, WorkspaceUncheckedCreateWithoutAgentsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutAgentsInput
    upsert?: WorkspaceUpsertWithoutAgentsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutAgentsInput, WorkspaceUpdateWithoutAgentsInput>, WorkspaceUncheckedUpdateWithoutAgentsInput>
  }

  export type DisparaJaConnectionUpdateManyWithoutAgentNestedInput = {
    create?: XOR<DisparaJaConnectionCreateWithoutAgentInput, DisparaJaConnectionUncheckedCreateWithoutAgentInput> | DisparaJaConnectionCreateWithoutAgentInput[] | DisparaJaConnectionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: DisparaJaConnectionCreateOrConnectWithoutAgentInput | DisparaJaConnectionCreateOrConnectWithoutAgentInput[]
    upsert?: DisparaJaConnectionUpsertWithWhereUniqueWithoutAgentInput | DisparaJaConnectionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: DisparaJaConnectionCreateManyAgentInputEnvelope
    set?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    disconnect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    delete?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    connect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    update?: DisparaJaConnectionUpdateWithWhereUniqueWithoutAgentInput | DisparaJaConnectionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: DisparaJaConnectionUpdateManyWithWhereWithoutAgentInput | DisparaJaConnectionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: DisparaJaConnectionScalarWhereInput | DisparaJaConnectionScalarWhereInput[]
  }

  export type WhatsAppCloudConnectionUpdateManyWithoutAgentNestedInput = {
    create?: XOR<WhatsAppCloudConnectionCreateWithoutAgentInput, WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput> | WhatsAppCloudConnectionCreateWithoutAgentInput[] | WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: WhatsAppCloudConnectionCreateOrConnectWithoutAgentInput | WhatsAppCloudConnectionCreateOrConnectWithoutAgentInput[]
    upsert?: WhatsAppCloudConnectionUpsertWithWhereUniqueWithoutAgentInput | WhatsAppCloudConnectionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: WhatsAppCloudConnectionCreateManyAgentInputEnvelope
    set?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    disconnect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    delete?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    connect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    update?: WhatsAppCloudConnectionUpdateWithWhereUniqueWithoutAgentInput | WhatsAppCloudConnectionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: WhatsAppCloudConnectionUpdateManyWithWhereWithoutAgentInput | WhatsAppCloudConnectionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: WhatsAppCloudConnectionScalarWhereInput | WhatsAppCloudConnectionScalarWhereInput[]
  }

  export type DisparaJaConnectionUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<DisparaJaConnectionCreateWithoutAgentInput, DisparaJaConnectionUncheckedCreateWithoutAgentInput> | DisparaJaConnectionCreateWithoutAgentInput[] | DisparaJaConnectionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: DisparaJaConnectionCreateOrConnectWithoutAgentInput | DisparaJaConnectionCreateOrConnectWithoutAgentInput[]
    upsert?: DisparaJaConnectionUpsertWithWhereUniqueWithoutAgentInput | DisparaJaConnectionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: DisparaJaConnectionCreateManyAgentInputEnvelope
    set?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    disconnect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    delete?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    connect?: DisparaJaConnectionWhereUniqueInput | DisparaJaConnectionWhereUniqueInput[]
    update?: DisparaJaConnectionUpdateWithWhereUniqueWithoutAgentInput | DisparaJaConnectionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: DisparaJaConnectionUpdateManyWithWhereWithoutAgentInput | DisparaJaConnectionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: DisparaJaConnectionScalarWhereInput | DisparaJaConnectionScalarWhereInput[]
  }

  export type WhatsAppCloudConnectionUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<WhatsAppCloudConnectionCreateWithoutAgentInput, WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput> | WhatsAppCloudConnectionCreateWithoutAgentInput[] | WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: WhatsAppCloudConnectionCreateOrConnectWithoutAgentInput | WhatsAppCloudConnectionCreateOrConnectWithoutAgentInput[]
    upsert?: WhatsAppCloudConnectionUpsertWithWhereUniqueWithoutAgentInput | WhatsAppCloudConnectionUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: WhatsAppCloudConnectionCreateManyAgentInputEnvelope
    set?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    disconnect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    delete?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    connect?: WhatsAppCloudConnectionWhereUniqueInput | WhatsAppCloudConnectionWhereUniqueInput[]
    update?: WhatsAppCloudConnectionUpdateWithWhereUniqueWithoutAgentInput | WhatsAppCloudConnectionUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: WhatsAppCloudConnectionUpdateManyWithWhereWithoutAgentInput | WhatsAppCloudConnectionUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: WhatsAppCloudConnectionScalarWhereInput | WhatsAppCloudConnectionScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutFilesInput = {
    create?: XOR<WorkspaceCreateWithoutFilesInput, WorkspaceUncheckedCreateWithoutFilesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFilesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkspaceUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutFilesInput, WorkspaceUncheckedCreateWithoutFilesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFilesInput
    upsert?: WorkspaceUpsertWithoutFilesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutFilesInput, WorkspaceUpdateWithoutFilesInput>, WorkspaceUncheckedUpdateWithoutFilesInput>
  }

  export type WorkspaceCreateNestedOneWithoutVector_storesInput = {
    create?: XOR<WorkspaceCreateWithoutVector_storesInput, WorkspaceUncheckedCreateWithoutVector_storesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutVector_storesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutVector_storesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutVector_storesInput, WorkspaceUncheckedCreateWithoutVector_storesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutVector_storesInput
    upsert?: WorkspaceUpsertWithoutVector_storesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutVector_storesInput, WorkspaceUpdateWithoutVector_storesInput>, WorkspaceUncheckedUpdateWithoutVector_storesInput>
  }

  export type ContactFieldCreateoptionsInput = {
    set: string[]
  }

  export type WorkspaceCreateNestedOneWithoutContact_fieldsInput = {
    create?: XOR<WorkspaceCreateWithoutContact_fieldsInput, WorkspaceUncheckedCreateWithoutContact_fieldsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutContact_fieldsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ContactFieldUpdateoptionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type WorkspaceUpdateOneRequiredWithoutContact_fieldsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutContact_fieldsInput, WorkspaceUncheckedCreateWithoutContact_fieldsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutContact_fieldsInput
    upsert?: WorkspaceUpsertWithoutContact_fieldsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutContact_fieldsInput, WorkspaceUpdateWithoutContact_fieldsInput>, WorkspaceUncheckedUpdateWithoutContact_fieldsInput>
  }

  export type AgentCreateNestedOneWithoutDisparaJaConnectionsInput = {
    create?: XOR<AgentCreateWithoutDisparaJaConnectionsInput, AgentUncheckedCreateWithoutDisparaJaConnectionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutDisparaJaConnectionsInput
    connect?: AgentWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutDisparaJaConnectionsInput = {
    create?: XOR<WorkspaceCreateWithoutDisparaJaConnectionsInput, WorkspaceUncheckedCreateWithoutDisparaJaConnectionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDisparaJaConnectionsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type DisparaJaLogCreateNestedManyWithoutConnectionInput = {
    create?: XOR<DisparaJaLogCreateWithoutConnectionInput, DisparaJaLogUncheckedCreateWithoutConnectionInput> | DisparaJaLogCreateWithoutConnectionInput[] | DisparaJaLogUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: DisparaJaLogCreateOrConnectWithoutConnectionInput | DisparaJaLogCreateOrConnectWithoutConnectionInput[]
    createMany?: DisparaJaLogCreateManyConnectionInputEnvelope
    connect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
  }

  export type DisparaJaLogUncheckedCreateNestedManyWithoutConnectionInput = {
    create?: XOR<DisparaJaLogCreateWithoutConnectionInput, DisparaJaLogUncheckedCreateWithoutConnectionInput> | DisparaJaLogCreateWithoutConnectionInput[] | DisparaJaLogUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: DisparaJaLogCreateOrConnectWithoutConnectionInput | DisparaJaLogCreateOrConnectWithoutConnectionInput[]
    createMany?: DisparaJaLogCreateManyConnectionInputEnvelope
    connect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
  }

  export type AgentUpdateOneRequiredWithoutDisparaJaConnectionsNestedInput = {
    create?: XOR<AgentCreateWithoutDisparaJaConnectionsInput, AgentUncheckedCreateWithoutDisparaJaConnectionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutDisparaJaConnectionsInput
    upsert?: AgentUpsertWithoutDisparaJaConnectionsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutDisparaJaConnectionsInput, AgentUpdateWithoutDisparaJaConnectionsInput>, AgentUncheckedUpdateWithoutDisparaJaConnectionsInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutDisparaJaConnectionsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutDisparaJaConnectionsInput, WorkspaceUncheckedCreateWithoutDisparaJaConnectionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDisparaJaConnectionsInput
    upsert?: WorkspaceUpsertWithoutDisparaJaConnectionsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutDisparaJaConnectionsInput, WorkspaceUpdateWithoutDisparaJaConnectionsInput>, WorkspaceUncheckedUpdateWithoutDisparaJaConnectionsInput>
  }

  export type DisparaJaLogUpdateManyWithoutConnectionNestedInput = {
    create?: XOR<DisparaJaLogCreateWithoutConnectionInput, DisparaJaLogUncheckedCreateWithoutConnectionInput> | DisparaJaLogCreateWithoutConnectionInput[] | DisparaJaLogUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: DisparaJaLogCreateOrConnectWithoutConnectionInput | DisparaJaLogCreateOrConnectWithoutConnectionInput[]
    upsert?: DisparaJaLogUpsertWithWhereUniqueWithoutConnectionInput | DisparaJaLogUpsertWithWhereUniqueWithoutConnectionInput[]
    createMany?: DisparaJaLogCreateManyConnectionInputEnvelope
    set?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    disconnect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    delete?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    connect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    update?: DisparaJaLogUpdateWithWhereUniqueWithoutConnectionInput | DisparaJaLogUpdateWithWhereUniqueWithoutConnectionInput[]
    updateMany?: DisparaJaLogUpdateManyWithWhereWithoutConnectionInput | DisparaJaLogUpdateManyWithWhereWithoutConnectionInput[]
    deleteMany?: DisparaJaLogScalarWhereInput | DisparaJaLogScalarWhereInput[]
  }

  export type DisparaJaLogUncheckedUpdateManyWithoutConnectionNestedInput = {
    create?: XOR<DisparaJaLogCreateWithoutConnectionInput, DisparaJaLogUncheckedCreateWithoutConnectionInput> | DisparaJaLogCreateWithoutConnectionInput[] | DisparaJaLogUncheckedCreateWithoutConnectionInput[]
    connectOrCreate?: DisparaJaLogCreateOrConnectWithoutConnectionInput | DisparaJaLogCreateOrConnectWithoutConnectionInput[]
    upsert?: DisparaJaLogUpsertWithWhereUniqueWithoutConnectionInput | DisparaJaLogUpsertWithWhereUniqueWithoutConnectionInput[]
    createMany?: DisparaJaLogCreateManyConnectionInputEnvelope
    set?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    disconnect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    delete?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    connect?: DisparaJaLogWhereUniqueInput | DisparaJaLogWhereUniqueInput[]
    update?: DisparaJaLogUpdateWithWhereUniqueWithoutConnectionInput | DisparaJaLogUpdateWithWhereUniqueWithoutConnectionInput[]
    updateMany?: DisparaJaLogUpdateManyWithWhereWithoutConnectionInput | DisparaJaLogUpdateManyWithWhereWithoutConnectionInput[]
    deleteMany?: DisparaJaLogScalarWhereInput | DisparaJaLogScalarWhereInput[]
  }

  export type DisparaJaConnectionCreateNestedOneWithoutLogsInput = {
    create?: XOR<DisparaJaConnectionCreateWithoutLogsInput, DisparaJaConnectionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: DisparaJaConnectionCreateOrConnectWithoutLogsInput
    connect?: DisparaJaConnectionWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutDispara_ja_logsInput = {
    create?: XOR<WorkspaceCreateWithoutDispara_ja_logsInput, WorkspaceUncheckedCreateWithoutDispara_ja_logsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDispara_ja_logsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type DisparaJaConnectionUpdateOneWithoutLogsNestedInput = {
    create?: XOR<DisparaJaConnectionCreateWithoutLogsInput, DisparaJaConnectionUncheckedCreateWithoutLogsInput>
    connectOrCreate?: DisparaJaConnectionCreateOrConnectWithoutLogsInput
    upsert?: DisparaJaConnectionUpsertWithoutLogsInput
    disconnect?: DisparaJaConnectionWhereInput | boolean
    delete?: DisparaJaConnectionWhereInput | boolean
    connect?: DisparaJaConnectionWhereUniqueInput
    update?: XOR<XOR<DisparaJaConnectionUpdateToOneWithWhereWithoutLogsInput, DisparaJaConnectionUpdateWithoutLogsInput>, DisparaJaConnectionUncheckedUpdateWithoutLogsInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutDispara_ja_logsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutDispara_ja_logsInput, WorkspaceUncheckedCreateWithoutDispara_ja_logsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutDispara_ja_logsInput
    upsert?: WorkspaceUpsertWithoutDispara_ja_logsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutDispara_ja_logsInput, WorkspaceUpdateWithoutDispara_ja_logsInput>, WorkspaceUncheckedUpdateWithoutDispara_ja_logsInput>
  }

  export type ConversationCreateNestedManyWithoutLeadInput = {
    create?: XOR<ConversationCreateWithoutLeadInput, ConversationUncheckedCreateWithoutLeadInput> | ConversationCreateWithoutLeadInput[] | ConversationUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutLeadInput | ConversationCreateOrConnectWithoutLeadInput[]
    createMany?: ConversationCreateManyLeadInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type WorkspaceCreateNestedOneWithoutLeadsInput = {
    create?: XOR<WorkspaceCreateWithoutLeadsInput, WorkspaceUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLeadsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type ConversationUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<ConversationCreateWithoutLeadInput, ConversationUncheckedCreateWithoutLeadInput> | ConversationCreateWithoutLeadInput[] | ConversationUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutLeadInput | ConversationCreateOrConnectWithoutLeadInput[]
    createMany?: ConversationCreateManyLeadInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ConversationCreateWithoutLeadInput, ConversationUncheckedCreateWithoutLeadInput> | ConversationCreateWithoutLeadInput[] | ConversationUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutLeadInput | ConversationCreateOrConnectWithoutLeadInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutLeadInput | ConversationUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ConversationCreateManyLeadInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutLeadInput | ConversationUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutLeadInput | ConversationUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type WorkspaceUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutLeadsInput, WorkspaceUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutLeadsInput
    upsert?: WorkspaceUpsertWithoutLeadsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutLeadsInput, WorkspaceUpdateWithoutLeadsInput>, WorkspaceUncheckedUpdateWithoutLeadsInput>
  }

  export type ConversationUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<ConversationCreateWithoutLeadInput, ConversationUncheckedCreateWithoutLeadInput> | ConversationCreateWithoutLeadInput[] | ConversationUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutLeadInput | ConversationCreateOrConnectWithoutLeadInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutLeadInput | ConversationUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: ConversationCreateManyLeadInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutLeadInput | ConversationUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutLeadInput | ConversationUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type LeadCreateNestedOneWithoutConversationsInput = {
    create?: XOR<LeadCreateWithoutConversationsInput, LeadUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutConversationsInput
    connect?: LeadWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutConversationsInput = {
    create?: XOR<WorkspaceCreateWithoutConversationsInput, WorkspaceUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutConversationsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type LeadUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<LeadCreateWithoutConversationsInput, LeadUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutConversationsInput
    upsert?: LeadUpsertWithoutConversationsInput
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutConversationsInput, LeadUpdateWithoutConversationsInput>, LeadUncheckedUpdateWithoutConversationsInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutConversationsInput, WorkspaceUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutConversationsInput
    upsert?: WorkspaceUpsertWithoutConversationsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutConversationsInput, WorkspaceUpdateWithoutConversationsInput>, WorkspaceUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type AgentCreateNestedOneWithoutWhatsappCloudConnectionsInput = {
    create?: XOR<AgentCreateWithoutWhatsappCloudConnectionsInput, AgentUncheckedCreateWithoutWhatsappCloudConnectionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutWhatsappCloudConnectionsInput
    connect?: AgentWhereUniqueInput
  }

  export type WorkspaceCreateNestedOneWithoutWhatsappCloudConnectionsInput = {
    create?: XOR<WorkspaceCreateWithoutWhatsappCloudConnectionsInput, WorkspaceUncheckedCreateWithoutWhatsappCloudConnectionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutWhatsappCloudConnectionsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type AgentUpdateOneRequiredWithoutWhatsappCloudConnectionsNestedInput = {
    create?: XOR<AgentCreateWithoutWhatsappCloudConnectionsInput, AgentUncheckedCreateWithoutWhatsappCloudConnectionsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutWhatsappCloudConnectionsInput
    upsert?: AgentUpsertWithoutWhatsappCloudConnectionsInput
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutWhatsappCloudConnectionsInput, AgentUpdateWithoutWhatsappCloudConnectionsInput>, AgentUncheckedUpdateWithoutWhatsappCloudConnectionsInput>
  }

  export type WorkspaceUpdateOneRequiredWithoutWhatsappCloudConnectionsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutWhatsappCloudConnectionsInput, WorkspaceUncheckedCreateWithoutWhatsappCloudConnectionsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutWhatsappCloudConnectionsInput
    upsert?: WorkspaceUpsertWithoutWhatsappCloudConnectionsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutWhatsappCloudConnectionsInput, WorkspaceUpdateWithoutWhatsappCloudConnectionsInput>, WorkspaceUncheckedUpdateWithoutWhatsappCloudConnectionsInput>
  }

  export type usersCreateNestedOneWithoutVerificationTokensInput = {
    create?: XOR<usersCreateWithoutVerificationTokensInput, usersUncheckedCreateWithoutVerificationTokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutVerificationTokensInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutVerificationTokensNestedInput = {
    create?: XOR<usersCreateWithoutVerificationTokensInput, usersUncheckedCreateWithoutVerificationTokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutVerificationTokensInput
    upsert?: usersUpsertWithoutVerificationTokensInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutVerificationTokensInput, usersUpdateWithoutVerificationTokensInput>, usersUncheckedUpdateWithoutVerificationTokensInput>
  }

  export type usersCreateNestedOneWithoutAccessTokensInput = {
    create?: XOR<usersCreateWithoutAccessTokensInput, usersUncheckedCreateWithoutAccessTokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutAccessTokensInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutAccessTokensNestedInput = {
    create?: XOR<usersCreateWithoutAccessTokensInput, usersUncheckedCreateWithoutAccessTokensInput>
    connectOrCreate?: usersCreateOrConnectWithoutAccessTokensInput
    upsert?: usersUpsertWithoutAccessTokensInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutAccessTokensInput, usersUpdateWithoutAccessTokensInput>, usersUncheckedUpdateWithoutAccessTokensInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type AgentCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentFunction?: string | null
    agentSkills?: string | null
    assistantId?: string | null
    companyDescription?: string | null
    companyName?: string | null
    companySector?: string | null
    companyWebsite?: string | null
    frequencyPenalty?: number | null
    imageUrl?: string | null
    initialMessage?: string | null
    internalName?: string | null
    language?: string | null
    maxMessages?: number | null
    maxTokens?: number | null
    model?: string | null
    personalityObjective?: string | null
    presencePenalty?: number | null
    productInfo?: string | null
    responseFormat?: string | null
    restrictions?: string | null
    temperature?: number | null
    timezone?: string | null
    vectorStoreId?: string | null
    voiceTone?: string | null
    openaiApiKey?: string | null
    userId: string
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutAgentInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentFunction?: string | null
    agentSkills?: string | null
    assistantId?: string | null
    companyDescription?: string | null
    companyName?: string | null
    companySector?: string | null
    companyWebsite?: string | null
    frequencyPenalty?: number | null
    imageUrl?: string | null
    initialMessage?: string | null
    internalName?: string | null
    language?: string | null
    maxMessages?: number | null
    maxTokens?: number | null
    model?: string | null
    personalityObjective?: string | null
    presencePenalty?: number | null
    productInfo?: string | null
    responseFormat?: string | null
    restrictions?: string | null
    temperature?: number | null
    timezone?: string | null
    vectorStoreId?: string | null
    voiceTone?: string | null
    openaiApiKey?: string | null
    userId: string
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutAgentInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutWorkspaceInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutWorkspaceInput, AgentUncheckedCreateWithoutWorkspaceInput>
  }

  export type AgentCreateManyWorkspaceInputEnvelope = {
    data: AgentCreateManyWorkspaceInput | AgentCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type ContactFieldCreateWithoutWorkspacesInput = {
    id?: string
    name: string
    type: string
    required?: boolean
    options?: ContactFieldCreateoptionsInput | string[]
    placeholder?: string | null
    default_value?: string | null
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFieldUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    name: string
    type: string
    required?: boolean
    options?: ContactFieldCreateoptionsInput | string[]
    placeholder?: string | null
    default_value?: string | null
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactFieldCreateOrConnectWithoutWorkspacesInput = {
    where: ContactFieldWhereUniqueInput
    create: XOR<ContactFieldCreateWithoutWorkspacesInput, ContactFieldUncheckedCreateWithoutWorkspacesInput>
  }

  export type ContactFieldCreateManyWorkspacesInputEnvelope = {
    data: ContactFieldCreateManyWorkspacesInput | ContactFieldCreateManyWorkspacesInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutWorkspaceInput = {
    id?: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lead: LeadCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    leadId: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutWorkspaceInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutWorkspaceInput, ConversationUncheckedCreateWithoutWorkspaceInput>
  }

  export type ConversationCreateManyWorkspaceInputEnvelope = {
    data: ConversationCreateManyWorkspaceInput | ConversationCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type DisparaJaConnectionCreateWithoutWorkspaceInput = {
    id?: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutDisparaJaConnectionsInput
    logs?: DisparaJaLogCreateNestedManyWithoutConnectionInput
  }

  export type DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    agentId: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: DisparaJaLogUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type DisparaJaConnectionCreateOrConnectWithoutWorkspaceInput = {
    where: DisparaJaConnectionWhereUniqueInput
    create: XOR<DisparaJaConnectionCreateWithoutWorkspaceInput, DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput>
  }

  export type DisparaJaConnectionCreateManyWorkspaceInputEnvelope = {
    data: DisparaJaConnectionCreateManyWorkspaceInput | DisparaJaConnectionCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type DisparaJaLogCreateWithoutWorkspacesInput = {
    id?: string
    type: string
    message: string
    timestamp?: Date | string
    connection?: DisparaJaConnectionCreateNestedOneWithoutLogsInput
  }

  export type DisparaJaLogUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    connectionId?: string | null
    type: string
    message: string
    timestamp?: Date | string
  }

  export type DisparaJaLogCreateOrConnectWithoutWorkspacesInput = {
    where: DisparaJaLogWhereUniqueInput
    create: XOR<DisparaJaLogCreateWithoutWorkspacesInput, DisparaJaLogUncheckedCreateWithoutWorkspacesInput>
  }

  export type DisparaJaLogCreateManyWorkspacesInputEnvelope = {
    data: DisparaJaLogCreateManyWorkspacesInput | DisparaJaLogCreateManyWorkspacesInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutWorkspaceInput = {
    id?: string
    fileId: string
    filename: string
    purpose: string
    size: number
    type?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    fileId: string
    filename: string
    purpose: string
    size: number
    type?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileCreateOrConnectWithoutWorkspaceInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput>
  }

  export type FileCreateManyWorkspaceInputEnvelope = {
    data: FileCreateManyWorkspaceInput | FileCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutWorkspacesInput = {
    id?: string
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: usersCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    userId: string
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateOrConnectWithoutWorkspacesInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutWorkspacesInput, IntegrationUncheckedCreateWithoutWorkspacesInput>
  }

  export type IntegrationCreateManyWorkspacesInputEnvelope = {
    data: IntegrationCreateManyWorkspacesInput | IntegrationCreateManyWorkspacesInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutWorkspaceInput = {
    id?: string
    name?: string | null
    phone: string
    photo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    name?: string | null
    phone: string
    photo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    conversations?: ConversationUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutWorkspaceInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutWorkspaceInput, LeadUncheckedCreateWithoutWorkspaceInput>
  }

  export type LeadCreateManyWorkspaceInputEnvelope = {
    data: LeadCreateManyWorkspaceInput | LeadCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type SystemConfigCreateWithoutWorkspacesInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigCreateOrConnectWithoutWorkspacesInput = {
    where: SystemConfigWhereUniqueInput
    create: XOR<SystemConfigCreateWithoutWorkspacesInput, SystemConfigUncheckedCreateWithoutWorkspacesInput>
  }

  export type SystemConfigCreateManyWorkspacesInputEnvelope = {
    data: SystemConfigCreateManyWorkspacesInput | SystemConfigCreateManyWorkspacesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenCreateNestedManyWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutWorkspaceInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutWorkspaceInput, usersUncheckedCreateWithoutWorkspaceInput>
  }

  export type usersCreateManyWorkspaceInputEnvelope = {
    data: usersCreateManyWorkspaceInput | usersCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type VectorStoreCreateWithoutWorkspacesInput = {
    id?: string
    name: string
    description?: string | null
    openaiId: string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VectorStoreUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    name: string
    description?: string | null
    openaiId: string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VectorStoreCreateOrConnectWithoutWorkspacesInput = {
    where: VectorStoreWhereUniqueInput
    create: XOR<VectorStoreCreateWithoutWorkspacesInput, VectorStoreUncheckedCreateWithoutWorkspacesInput>
  }

  export type VectorStoreCreateManyWorkspacesInputEnvelope = {
    data: VectorStoreCreateManyWorkspacesInput | VectorStoreCreateManyWorkspacesInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppCloudConnectionCreateWithoutWorkspaceInput = {
    id?: string
    phoneNumberId: string
    accessToken: string
    status?: string
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifyToken?: string
    agent: AgentCreateNestedOneWithoutWhatsappCloudConnectionsInput
  }

  export type WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    agentId: string
    phoneNumberId: string
    accessToken: string
    status?: string
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifyToken?: string
  }

  export type WhatsAppCloudConnectionCreateOrConnectWithoutWorkspaceInput = {
    where: WhatsAppCloudConnectionWhereUniqueInput
    create: XOR<WhatsAppCloudConnectionCreateWithoutWorkspaceInput, WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput>
  }

  export type WhatsAppCloudConnectionCreateManyWorkspaceInputEnvelope = {
    data: WhatsAppCloudConnectionCreateManyWorkspaceInput | WhatsAppCloudConnectionCreateManyWorkspaceInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: AgentWhereUniqueInput
    update: XOR<AgentUpdateWithoutWorkspaceInput, AgentUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<AgentCreateWithoutWorkspaceInput, AgentUncheckedCreateWithoutWorkspaceInput>
  }

  export type AgentUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: AgentWhereUniqueInput
    data: XOR<AgentUpdateWithoutWorkspaceInput, AgentUncheckedUpdateWithoutWorkspaceInput>
  }

  export type AgentUpdateManyWithWhereWithoutWorkspaceInput = {
    where: AgentScalarWhereInput
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type AgentScalarWhereInput = {
    AND?: AgentScalarWhereInput | AgentScalarWhereInput[]
    OR?: AgentScalarWhereInput[]
    NOT?: AgentScalarWhereInput | AgentScalarWhereInput[]
    id?: StringFilter<"Agent"> | string
    name?: StringFilter<"Agent"> | string
    description?: StringNullableFilter<"Agent"> | string | null
    systemPrompt?: StringNullableFilter<"Agent"> | string | null
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    agentFunction?: StringNullableFilter<"Agent"> | string | null
    agentSkills?: StringNullableFilter<"Agent"> | string | null
    assistantId?: StringNullableFilter<"Agent"> | string | null
    companyDescription?: StringNullableFilter<"Agent"> | string | null
    companyName?: StringNullableFilter<"Agent"> | string | null
    companySector?: StringNullableFilter<"Agent"> | string | null
    companyWebsite?: StringNullableFilter<"Agent"> | string | null
    frequencyPenalty?: FloatNullableFilter<"Agent"> | number | null
    imageUrl?: StringNullableFilter<"Agent"> | string | null
    initialMessage?: StringNullableFilter<"Agent"> | string | null
    internalName?: StringNullableFilter<"Agent"> | string | null
    language?: StringNullableFilter<"Agent"> | string | null
    maxMessages?: IntNullableFilter<"Agent"> | number | null
    maxTokens?: IntNullableFilter<"Agent"> | number | null
    model?: StringNullableFilter<"Agent"> | string | null
    personalityObjective?: StringNullableFilter<"Agent"> | string | null
    presencePenalty?: FloatNullableFilter<"Agent"> | number | null
    productInfo?: StringNullableFilter<"Agent"> | string | null
    responseFormat?: StringNullableFilter<"Agent"> | string | null
    restrictions?: StringNullableFilter<"Agent"> | string | null
    temperature?: FloatNullableFilter<"Agent"> | number | null
    timezone?: StringNullableFilter<"Agent"> | string | null
    vectorStoreId?: StringNullableFilter<"Agent"> | string | null
    voiceTone?: StringNullableFilter<"Agent"> | string | null
    openaiApiKey?: StringNullableFilter<"Agent"> | string | null
    userId?: StringFilter<"Agent"> | string
    workspaceId?: StringFilter<"Agent"> | string
  }

  export type ContactFieldUpsertWithWhereUniqueWithoutWorkspacesInput = {
    where: ContactFieldWhereUniqueInput
    update: XOR<ContactFieldUpdateWithoutWorkspacesInput, ContactFieldUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<ContactFieldCreateWithoutWorkspacesInput, ContactFieldUncheckedCreateWithoutWorkspacesInput>
  }

  export type ContactFieldUpdateWithWhereUniqueWithoutWorkspacesInput = {
    where: ContactFieldWhereUniqueInput
    data: XOR<ContactFieldUpdateWithoutWorkspacesInput, ContactFieldUncheckedUpdateWithoutWorkspacesInput>
  }

  export type ContactFieldUpdateManyWithWhereWithoutWorkspacesInput = {
    where: ContactFieldScalarWhereInput
    data: XOR<ContactFieldUpdateManyMutationInput, ContactFieldUncheckedUpdateManyWithoutWorkspacesInput>
  }

  export type ContactFieldScalarWhereInput = {
    AND?: ContactFieldScalarWhereInput | ContactFieldScalarWhereInput[]
    OR?: ContactFieldScalarWhereInput[]
    NOT?: ContactFieldScalarWhereInput | ContactFieldScalarWhereInput[]
    id?: StringFilter<"ContactField"> | string
    name?: StringFilter<"ContactField"> | string
    type?: StringFilter<"ContactField"> | string
    required?: BoolFilter<"ContactField"> | boolean
    options?: StringNullableListFilter<"ContactField">
    placeholder?: StringNullableFilter<"ContactField"> | string | null
    default_value?: StringNullableFilter<"ContactField"> | string | null
    description?: StringNullableFilter<"ContactField"> | string | null
    order?: IntFilter<"ContactField"> | number
    createdAt?: DateTimeFilter<"ContactField"> | Date | string
    updatedAt?: DateTimeFilter<"ContactField"> | Date | string
    workspaceId?: StringFilter<"ContactField"> | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutWorkspaceInput, ConversationUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ConversationCreateWithoutWorkspaceInput, ConversationUncheckedCreateWithoutWorkspaceInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutWorkspaceInput, ConversationUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ConversationUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: UuidFilter<"Conversation"> | string
    leadId?: UuidFilter<"Conversation"> | string
    threadId?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    workspaceId?: StringFilter<"Conversation"> | string
  }

  export type DisparaJaConnectionUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: DisparaJaConnectionWhereUniqueInput
    update: XOR<DisparaJaConnectionUpdateWithoutWorkspaceInput, DisparaJaConnectionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<DisparaJaConnectionCreateWithoutWorkspaceInput, DisparaJaConnectionUncheckedCreateWithoutWorkspaceInput>
  }

  export type DisparaJaConnectionUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: DisparaJaConnectionWhereUniqueInput
    data: XOR<DisparaJaConnectionUpdateWithoutWorkspaceInput, DisparaJaConnectionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type DisparaJaConnectionUpdateManyWithWhereWithoutWorkspaceInput = {
    where: DisparaJaConnectionScalarWhereInput
    data: XOR<DisparaJaConnectionUpdateManyMutationInput, DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type DisparaJaConnectionScalarWhereInput = {
    AND?: DisparaJaConnectionScalarWhereInput | DisparaJaConnectionScalarWhereInput[]
    OR?: DisparaJaConnectionScalarWhereInput[]
    NOT?: DisparaJaConnectionScalarWhereInput | DisparaJaConnectionScalarWhereInput[]
    id?: StringFilter<"DisparaJaConnection"> | string
    agentId?: StringFilter<"DisparaJaConnection"> | string
    provider?: StringFilter<"DisparaJaConnection"> | string
    secret?: StringFilter<"DisparaJaConnection"> | string
    sid?: StringFilter<"DisparaJaConnection"> | string
    token?: StringNullableFilter<"DisparaJaConnection"> | string | null
    phoneNumber?: StringFilter<"DisparaJaConnection"> | string
    unique?: StringFilter<"DisparaJaConnection"> | string
    webhookUrl?: StringFilter<"DisparaJaConnection"> | string
    status?: StringFilter<"DisparaJaConnection"> | string
    createdAt?: DateTimeFilter<"DisparaJaConnection"> | Date | string
    updatedAt?: DateTimeFilter<"DisparaJaConnection"> | Date | string
    workspaceId?: StringFilter<"DisparaJaConnection"> | string
  }

  export type DisparaJaLogUpsertWithWhereUniqueWithoutWorkspacesInput = {
    where: DisparaJaLogWhereUniqueInput
    update: XOR<DisparaJaLogUpdateWithoutWorkspacesInput, DisparaJaLogUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<DisparaJaLogCreateWithoutWorkspacesInput, DisparaJaLogUncheckedCreateWithoutWorkspacesInput>
  }

  export type DisparaJaLogUpdateWithWhereUniqueWithoutWorkspacesInput = {
    where: DisparaJaLogWhereUniqueInput
    data: XOR<DisparaJaLogUpdateWithoutWorkspacesInput, DisparaJaLogUncheckedUpdateWithoutWorkspacesInput>
  }

  export type DisparaJaLogUpdateManyWithWhereWithoutWorkspacesInput = {
    where: DisparaJaLogScalarWhereInput
    data: XOR<DisparaJaLogUpdateManyMutationInput, DisparaJaLogUncheckedUpdateManyWithoutWorkspacesInput>
  }

  export type DisparaJaLogScalarWhereInput = {
    AND?: DisparaJaLogScalarWhereInput | DisparaJaLogScalarWhereInput[]
    OR?: DisparaJaLogScalarWhereInput[]
    NOT?: DisparaJaLogScalarWhereInput | DisparaJaLogScalarWhereInput[]
    id?: StringFilter<"DisparaJaLog"> | string
    connectionId?: StringNullableFilter<"DisparaJaLog"> | string | null
    type?: StringFilter<"DisparaJaLog"> | string
    message?: StringFilter<"DisparaJaLog"> | string
    timestamp?: DateTimeFilter<"DisparaJaLog"> | Date | string
    workspaceId?: StringFilter<"DisparaJaLog"> | string
  }

  export type FileUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutWorkspaceInput, FileUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<FileCreateWithoutWorkspaceInput, FileUncheckedCreateWithoutWorkspaceInput>
  }

  export type FileUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutWorkspaceInput, FileUncheckedUpdateWithoutWorkspaceInput>
  }

  export type FileUpdateManyWithWhereWithoutWorkspaceInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    fileId?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    purpose?: StringFilter<"File"> | string
    size?: IntFilter<"File"> | number
    type?: StringNullableFilter<"File"> | string | null
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    workspaceId?: StringFilter<"File"> | string
  }

  export type IntegrationUpsertWithWhereUniqueWithoutWorkspacesInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutWorkspacesInput, IntegrationUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<IntegrationCreateWithoutWorkspacesInput, IntegrationUncheckedCreateWithoutWorkspacesInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutWorkspacesInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutWorkspacesInput, IntegrationUncheckedUpdateWithoutWorkspacesInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutWorkspacesInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutWorkspacesInput>
  }

  export type IntegrationScalarWhereInput = {
    AND?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    OR?: IntegrationScalarWhereInput[]
    NOT?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    id?: StringFilter<"Integration"> | string
    userId?: StringFilter<"Integration"> | string
    provider?: StringFilter<"Integration"> | string
    credentials?: JsonFilter<"Integration">
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    workspaceId?: StringFilter<"Integration"> | string
  }

  export type LeadUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutWorkspaceInput, LeadUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<LeadCreateWithoutWorkspaceInput, LeadUncheckedCreateWithoutWorkspaceInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutWorkspaceInput, LeadUncheckedUpdateWithoutWorkspaceInput>
  }

  export type LeadUpdateManyWithWhereWithoutWorkspaceInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: UuidFilter<"Lead"> | string
    name?: StringNullableFilter<"Lead"> | string | null
    phone?: StringFilter<"Lead"> | string
    photo?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    workspaceId?: StringFilter<"Lead"> | string
  }

  export type SystemConfigUpsertWithWhereUniqueWithoutWorkspacesInput = {
    where: SystemConfigWhereUniqueInput
    update: XOR<SystemConfigUpdateWithoutWorkspacesInput, SystemConfigUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<SystemConfigCreateWithoutWorkspacesInput, SystemConfigUncheckedCreateWithoutWorkspacesInput>
  }

  export type SystemConfigUpdateWithWhereUniqueWithoutWorkspacesInput = {
    where: SystemConfigWhereUniqueInput
    data: XOR<SystemConfigUpdateWithoutWorkspacesInput, SystemConfigUncheckedUpdateWithoutWorkspacesInput>
  }

  export type SystemConfigUpdateManyWithWhereWithoutWorkspacesInput = {
    where: SystemConfigScalarWhereInput
    data: XOR<SystemConfigUpdateManyMutationInput, SystemConfigUncheckedUpdateManyWithoutWorkspacesInput>
  }

  export type SystemConfigScalarWhereInput = {
    AND?: SystemConfigScalarWhereInput | SystemConfigScalarWhereInput[]
    OR?: SystemConfigScalarWhereInput[]
    NOT?: SystemConfigScalarWhereInput | SystemConfigScalarWhereInput[]
    id?: StringFilter<"SystemConfig"> | string
    key?: StringFilter<"SystemConfig"> | string
    value?: StringFilter<"SystemConfig"> | string
    description?: StringNullableFilter<"SystemConfig"> | string | null
    createdAt?: DateTimeFilter<"SystemConfig"> | Date | string
    updatedAt?: DateTimeFilter<"SystemConfig"> | Date | string
    workspaceId?: StringFilter<"SystemConfig"> | string
  }

  export type usersUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutWorkspaceInput, usersUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<usersCreateWithoutWorkspaceInput, usersUncheckedCreateWithoutWorkspaceInput>
  }

  export type usersUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutWorkspaceInput, usersUncheckedUpdateWithoutWorkspaceInput>
  }

  export type usersUpdateManyWithWhereWithoutWorkspaceInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    name?: StringNullableFilter<"users"> | string | null
    password?: StringFilter<"users"> | string
    role?: StringFilter<"users"> | string
    workspaceId?: StringFilter<"users"> | string
    emailVerified?: DateTimeNullableFilter<"users"> | Date | string | null
    verifyToken?: StringNullableFilter<"users"> | string | null
    resetToken?: StringNullableFilter<"users"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"users"> | Date | string | null
    lastLogin?: DateTimeNullableFilter<"users"> | Date | string | null
    status?: StringFilter<"users"> | string
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
  }

  export type VectorStoreUpsertWithWhereUniqueWithoutWorkspacesInput = {
    where: VectorStoreWhereUniqueInput
    update: XOR<VectorStoreUpdateWithoutWorkspacesInput, VectorStoreUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<VectorStoreCreateWithoutWorkspacesInput, VectorStoreUncheckedCreateWithoutWorkspacesInput>
  }

  export type VectorStoreUpdateWithWhereUniqueWithoutWorkspacesInput = {
    where: VectorStoreWhereUniqueInput
    data: XOR<VectorStoreUpdateWithoutWorkspacesInput, VectorStoreUncheckedUpdateWithoutWorkspacesInput>
  }

  export type VectorStoreUpdateManyWithWhereWithoutWorkspacesInput = {
    where: VectorStoreScalarWhereInput
    data: XOR<VectorStoreUpdateManyMutationInput, VectorStoreUncheckedUpdateManyWithoutWorkspacesInput>
  }

  export type VectorStoreScalarWhereInput = {
    AND?: VectorStoreScalarWhereInput | VectorStoreScalarWhereInput[]
    OR?: VectorStoreScalarWhereInput[]
    NOT?: VectorStoreScalarWhereInput | VectorStoreScalarWhereInput[]
    id?: StringFilter<"VectorStore"> | string
    name?: StringFilter<"VectorStore"> | string
    description?: StringNullableFilter<"VectorStore"> | string | null
    openaiId?: StringFilter<"VectorStore"> | string
    files?: JsonNullableFilter<"VectorStore">
    createdAt?: DateTimeFilter<"VectorStore"> | Date | string
    updatedAt?: DateTimeFilter<"VectorStore"> | Date | string
    workspaceId?: StringFilter<"VectorStore"> | string
  }

  export type WhatsAppCloudConnectionUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WhatsAppCloudConnectionWhereUniqueInput
    update: XOR<WhatsAppCloudConnectionUpdateWithoutWorkspaceInput, WhatsAppCloudConnectionUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WhatsAppCloudConnectionCreateWithoutWorkspaceInput, WhatsAppCloudConnectionUncheckedCreateWithoutWorkspaceInput>
  }

  export type WhatsAppCloudConnectionUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WhatsAppCloudConnectionWhereUniqueInput
    data: XOR<WhatsAppCloudConnectionUpdateWithoutWorkspaceInput, WhatsAppCloudConnectionUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WhatsAppCloudConnectionUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WhatsAppCloudConnectionScalarWhereInput
    data: XOR<WhatsAppCloudConnectionUpdateManyMutationInput, WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WhatsAppCloudConnectionScalarWhereInput = {
    AND?: WhatsAppCloudConnectionScalarWhereInput | WhatsAppCloudConnectionScalarWhereInput[]
    OR?: WhatsAppCloudConnectionScalarWhereInput[]
    NOT?: WhatsAppCloudConnectionScalarWhereInput | WhatsAppCloudConnectionScalarWhereInput[]
    id?: StringFilter<"WhatsAppCloudConnection"> | string
    agentId?: StringFilter<"WhatsAppCloudConnection"> | string
    phoneNumberId?: StringFilter<"WhatsAppCloudConnection"> | string
    accessToken?: StringFilter<"WhatsAppCloudConnection"> | string
    status?: StringFilter<"WhatsAppCloudConnection"> | string
    webhookUrl?: StringNullableFilter<"WhatsAppCloudConnection"> | string | null
    workspaceId?: StringFilter<"WhatsAppCloudConnection"> | string
    createdAt?: DateTimeFilter<"WhatsAppCloudConnection"> | Date | string
    updatedAt?: DateTimeFilter<"WhatsAppCloudConnection"> | Date | string
    verifyToken?: StringFilter<"WhatsAppCloudConnection"> | string
  }

  export type AccessTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type AccessTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type AccessTokenCreateOrConnectWithoutUserInput = {
    where: AccessTokenWhereUniqueInput
    create: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput>
  }

  export type AccessTokenCreateManyUserInputEnvelope = {
    data: AccessTokenCreateManyUserInput | AccessTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutUserInput = {
    id?: string
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaces: WorkspaceCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationUncheckedCreateWithoutUserInput = {
    id?: string
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type IntegrationCreateOrConnectWithoutUserInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput>
  }

  export type IntegrationCreateManyUserInputEnvelope = {
    data: IntegrationCreateManyUserInput | IntegrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutUsersInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
  }

  export type VerificationTokenCreateWithoutUserInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type VerificationTokenUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type VerificationTokenCreateOrConnectWithoutUserInput = {
    where: VerificationTokenWhereUniqueInput
    create: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type VerificationTokenCreateManyUserInputEnvelope = {
    data: VerificationTokenCreateManyUserInput | VerificationTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AccessTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: AccessTokenWhereUniqueInput
    update: XOR<AccessTokenUpdateWithoutUserInput, AccessTokenUncheckedUpdateWithoutUserInput>
    create: XOR<AccessTokenCreateWithoutUserInput, AccessTokenUncheckedCreateWithoutUserInput>
  }

  export type AccessTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: AccessTokenWhereUniqueInput
    data: XOR<AccessTokenUpdateWithoutUserInput, AccessTokenUncheckedUpdateWithoutUserInput>
  }

  export type AccessTokenUpdateManyWithWhereWithoutUserInput = {
    where: AccessTokenScalarWhereInput
    data: XOR<AccessTokenUpdateManyMutationInput, AccessTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type AccessTokenScalarWhereInput = {
    AND?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
    OR?: AccessTokenScalarWhereInput[]
    NOT?: AccessTokenScalarWhereInput | AccessTokenScalarWhereInput[]
    id?: StringFilter<"AccessToken"> | string
    userId?: StringFilter<"AccessToken"> | string
    token?: StringFilter<"AccessToken"> | string
    expires?: DateTimeFilter<"AccessToken"> | Date | string
    createdAt?: DateTimeFilter<"AccessToken"> | Date | string
  }

  export type IntegrationUpsertWithWhereUniqueWithoutUserInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutUserInput, IntegrationUncheckedUpdateWithoutUserInput>
    create: XOR<IntegrationCreateWithoutUserInput, IntegrationUncheckedCreateWithoutUserInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutUserInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutUserInput, IntegrationUncheckedUpdateWithoutUserInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutUserInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceUpsertWithoutUsersInput = {
    update: XOR<WorkspaceUpdateWithoutUsersInput, WorkspaceUncheckedUpdateWithoutUsersInput>
    create: XOR<WorkspaceCreateWithoutUsersInput, WorkspaceUncheckedCreateWithoutUsersInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutUsersInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutUsersInput, WorkspaceUncheckedUpdateWithoutUsersInput>
  }

  export type WorkspaceUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type VerificationTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: VerificationTokenWhereUniqueInput
    update: XOR<VerificationTokenUpdateWithoutUserInput, VerificationTokenUncheckedUpdateWithoutUserInput>
    create: XOR<VerificationTokenCreateWithoutUserInput, VerificationTokenUncheckedCreateWithoutUserInput>
  }

  export type VerificationTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: VerificationTokenWhereUniqueInput
    data: XOR<VerificationTokenUpdateWithoutUserInput, VerificationTokenUncheckedUpdateWithoutUserInput>
  }

  export type VerificationTokenUpdateManyWithWhereWithoutUserInput = {
    where: VerificationTokenScalarWhereInput
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type VerificationTokenScalarWhereInput = {
    AND?: VerificationTokenScalarWhereInput | VerificationTokenScalarWhereInput[]
    OR?: VerificationTokenScalarWhereInput[]
    NOT?: VerificationTokenScalarWhereInput | VerificationTokenScalarWhereInput[]
    id?: StringFilter<"VerificationToken"> | string
    userId?: StringFilter<"VerificationToken"> | string
    email?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
    createdAt?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type WorkspaceCreateWithoutSystem_configsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutSystem_configsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutSystem_configsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutSystem_configsInput, WorkspaceUncheckedCreateWithoutSystem_configsInput>
  }

  export type WorkspaceUpsertWithoutSystem_configsInput = {
    update: XOR<WorkspaceUpdateWithoutSystem_configsInput, WorkspaceUncheckedUpdateWithoutSystem_configsInput>
    create: XOR<WorkspaceCreateWithoutSystem_configsInput, WorkspaceUncheckedCreateWithoutSystem_configsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutSystem_configsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutSystem_configsInput, WorkspaceUncheckedUpdateWithoutSystem_configsInput>
  }

  export type WorkspaceUpdateWithoutSystem_configsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutSystem_configsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type usersCreateWithoutIntegrationsInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenCreateNestedManyWithoutUserInput
    workspace: WorkspaceCreateNestedOneWithoutUsersInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    workspaceId: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutIntegrationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutIntegrationsInput, usersUncheckedCreateWithoutIntegrationsInput>
  }

  export type WorkspaceCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutIntegrationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutIntegrationsInput, WorkspaceUncheckedCreateWithoutIntegrationsInput>
  }

  export type usersUpsertWithoutIntegrationsInput = {
    update: XOR<usersUpdateWithoutIntegrationsInput, usersUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<usersCreateWithoutIntegrationsInput, usersUncheckedCreateWithoutIntegrationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutIntegrationsInput, usersUncheckedUpdateWithoutIntegrationsInput>
  }

  export type usersUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUpdateManyWithoutUserNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutUsersNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkspaceUpsertWithoutIntegrationsInput = {
    update: XOR<WorkspaceUpdateWithoutIntegrationsInput, WorkspaceUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<WorkspaceCreateWithoutIntegrationsInput, WorkspaceUncheckedCreateWithoutIntegrationsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutIntegrationsInput, WorkspaceUncheckedUpdateWithoutIntegrationsInput>
  }

  export type WorkspaceUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutAgentsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutAgentsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutAgentsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutAgentsInput, WorkspaceUncheckedCreateWithoutAgentsInput>
  }

  export type DisparaJaConnectionCreateWithoutAgentInput = {
    id?: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutDisparaJaConnectionsInput
    logs?: DisparaJaLogCreateNestedManyWithoutConnectionInput
  }

  export type DisparaJaConnectionUncheckedCreateWithoutAgentInput = {
    id?: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
    logs?: DisparaJaLogUncheckedCreateNestedManyWithoutConnectionInput
  }

  export type DisparaJaConnectionCreateOrConnectWithoutAgentInput = {
    where: DisparaJaConnectionWhereUniqueInput
    create: XOR<DisparaJaConnectionCreateWithoutAgentInput, DisparaJaConnectionUncheckedCreateWithoutAgentInput>
  }

  export type DisparaJaConnectionCreateManyAgentInputEnvelope = {
    data: DisparaJaConnectionCreateManyAgentInput | DisparaJaConnectionCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type WhatsAppCloudConnectionCreateWithoutAgentInput = {
    id?: string
    phoneNumberId: string
    accessToken: string
    status?: string
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifyToken?: string
    workspace: WorkspaceCreateNestedOneWithoutWhatsappCloudConnectionsInput
  }

  export type WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput = {
    id?: string
    phoneNumberId: string
    accessToken: string
    status?: string
    webhookUrl?: string | null
    workspaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    verifyToken?: string
  }

  export type WhatsAppCloudConnectionCreateOrConnectWithoutAgentInput = {
    where: WhatsAppCloudConnectionWhereUniqueInput
    create: XOR<WhatsAppCloudConnectionCreateWithoutAgentInput, WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput>
  }

  export type WhatsAppCloudConnectionCreateManyAgentInputEnvelope = {
    data: WhatsAppCloudConnectionCreateManyAgentInput | WhatsAppCloudConnectionCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceUpsertWithoutAgentsInput = {
    update: XOR<WorkspaceUpdateWithoutAgentsInput, WorkspaceUncheckedUpdateWithoutAgentsInput>
    create: XOR<WorkspaceCreateWithoutAgentsInput, WorkspaceUncheckedCreateWithoutAgentsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutAgentsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutAgentsInput, WorkspaceUncheckedUpdateWithoutAgentsInput>
  }

  export type WorkspaceUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutAgentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type DisparaJaConnectionUpsertWithWhereUniqueWithoutAgentInput = {
    where: DisparaJaConnectionWhereUniqueInput
    update: XOR<DisparaJaConnectionUpdateWithoutAgentInput, DisparaJaConnectionUncheckedUpdateWithoutAgentInput>
    create: XOR<DisparaJaConnectionCreateWithoutAgentInput, DisparaJaConnectionUncheckedCreateWithoutAgentInput>
  }

  export type DisparaJaConnectionUpdateWithWhereUniqueWithoutAgentInput = {
    where: DisparaJaConnectionWhereUniqueInput
    data: XOR<DisparaJaConnectionUpdateWithoutAgentInput, DisparaJaConnectionUncheckedUpdateWithoutAgentInput>
  }

  export type DisparaJaConnectionUpdateManyWithWhereWithoutAgentInput = {
    where: DisparaJaConnectionScalarWhereInput
    data: XOR<DisparaJaConnectionUpdateManyMutationInput, DisparaJaConnectionUncheckedUpdateManyWithoutAgentInput>
  }

  export type WhatsAppCloudConnectionUpsertWithWhereUniqueWithoutAgentInput = {
    where: WhatsAppCloudConnectionWhereUniqueInput
    update: XOR<WhatsAppCloudConnectionUpdateWithoutAgentInput, WhatsAppCloudConnectionUncheckedUpdateWithoutAgentInput>
    create: XOR<WhatsAppCloudConnectionCreateWithoutAgentInput, WhatsAppCloudConnectionUncheckedCreateWithoutAgentInput>
  }

  export type WhatsAppCloudConnectionUpdateWithWhereUniqueWithoutAgentInput = {
    where: WhatsAppCloudConnectionWhereUniqueInput
    data: XOR<WhatsAppCloudConnectionUpdateWithoutAgentInput, WhatsAppCloudConnectionUncheckedUpdateWithoutAgentInput>
  }

  export type WhatsAppCloudConnectionUpdateManyWithWhereWithoutAgentInput = {
    where: WhatsAppCloudConnectionScalarWhereInput
    data: XOR<WhatsAppCloudConnectionUpdateManyMutationInput, WhatsAppCloudConnectionUncheckedUpdateManyWithoutAgentInput>
  }

  export type WorkspaceCreateWithoutFilesInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutFilesInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutFilesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutFilesInput, WorkspaceUncheckedCreateWithoutFilesInput>
  }

  export type WorkspaceUpsertWithoutFilesInput = {
    update: XOR<WorkspaceUpdateWithoutFilesInput, WorkspaceUncheckedUpdateWithoutFilesInput>
    create: XOR<WorkspaceCreateWithoutFilesInput, WorkspaceUncheckedCreateWithoutFilesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutFilesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutFilesInput, WorkspaceUncheckedUpdateWithoutFilesInput>
  }

  export type WorkspaceUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutVector_storesInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutVector_storesInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutVector_storesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutVector_storesInput, WorkspaceUncheckedCreateWithoutVector_storesInput>
  }

  export type WorkspaceUpsertWithoutVector_storesInput = {
    update: XOR<WorkspaceUpdateWithoutVector_storesInput, WorkspaceUncheckedUpdateWithoutVector_storesInput>
    create: XOR<WorkspaceCreateWithoutVector_storesInput, WorkspaceUncheckedCreateWithoutVector_storesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutVector_storesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutVector_storesInput, WorkspaceUncheckedUpdateWithoutVector_storesInput>
  }

  export type WorkspaceUpdateWithoutVector_storesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutVector_storesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateWithoutContact_fieldsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutContact_fieldsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutContact_fieldsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutContact_fieldsInput, WorkspaceUncheckedCreateWithoutContact_fieldsInput>
  }

  export type WorkspaceUpsertWithoutContact_fieldsInput = {
    update: XOR<WorkspaceUpdateWithoutContact_fieldsInput, WorkspaceUncheckedUpdateWithoutContact_fieldsInput>
    create: XOR<WorkspaceCreateWithoutContact_fieldsInput, WorkspaceUncheckedCreateWithoutContact_fieldsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutContact_fieldsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutContact_fieldsInput, WorkspaceUncheckedUpdateWithoutContact_fieldsInput>
  }

  export type WorkspaceUpdateWithoutContact_fieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutContact_fieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type AgentCreateWithoutDisparaJaConnectionsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentFunction?: string | null
    agentSkills?: string | null
    assistantId?: string | null
    companyDescription?: string | null
    companyName?: string | null
    companySector?: string | null
    companyWebsite?: string | null
    frequencyPenalty?: number | null
    imageUrl?: string | null
    initialMessage?: string | null
    internalName?: string | null
    language?: string | null
    maxMessages?: number | null
    maxTokens?: number | null
    model?: string | null
    personalityObjective?: string | null
    presencePenalty?: number | null
    productInfo?: string | null
    responseFormat?: string | null
    restrictions?: string | null
    temperature?: number | null
    timezone?: string | null
    vectorStoreId?: string | null
    voiceTone?: string | null
    openaiApiKey?: string | null
    userId: string
    workspace: WorkspaceCreateNestedOneWithoutAgentsInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutDisparaJaConnectionsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentFunction?: string | null
    agentSkills?: string | null
    assistantId?: string | null
    companyDescription?: string | null
    companyName?: string | null
    companySector?: string | null
    companyWebsite?: string | null
    frequencyPenalty?: number | null
    imageUrl?: string | null
    initialMessage?: string | null
    internalName?: string | null
    language?: string | null
    maxMessages?: number | null
    maxTokens?: number | null
    model?: string | null
    personalityObjective?: string | null
    presencePenalty?: number | null
    productInfo?: string | null
    responseFormat?: string | null
    restrictions?: string | null
    temperature?: number | null
    timezone?: string | null
    vectorStoreId?: string | null
    voiceTone?: string | null
    openaiApiKey?: string | null
    userId: string
    workspaceId: string
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutDisparaJaConnectionsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutDisparaJaConnectionsInput, AgentUncheckedCreateWithoutDisparaJaConnectionsInput>
  }

  export type WorkspaceCreateWithoutDisparaJaConnectionsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutDisparaJaConnectionsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutDisparaJaConnectionsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutDisparaJaConnectionsInput, WorkspaceUncheckedCreateWithoutDisparaJaConnectionsInput>
  }

  export type DisparaJaLogCreateWithoutConnectionInput = {
    id?: string
    type: string
    message: string
    timestamp?: Date | string
    workspaces: WorkspaceCreateNestedOneWithoutDispara_ja_logsInput
  }

  export type DisparaJaLogUncheckedCreateWithoutConnectionInput = {
    id?: string
    type: string
    message: string
    timestamp?: Date | string
    workspaceId: string
  }

  export type DisparaJaLogCreateOrConnectWithoutConnectionInput = {
    where: DisparaJaLogWhereUniqueInput
    create: XOR<DisparaJaLogCreateWithoutConnectionInput, DisparaJaLogUncheckedCreateWithoutConnectionInput>
  }

  export type DisparaJaLogCreateManyConnectionInputEnvelope = {
    data: DisparaJaLogCreateManyConnectionInput | DisparaJaLogCreateManyConnectionInput[]
    skipDuplicates?: boolean
  }

  export type AgentUpsertWithoutDisparaJaConnectionsInput = {
    update: XOR<AgentUpdateWithoutDisparaJaConnectionsInput, AgentUncheckedUpdateWithoutDisparaJaConnectionsInput>
    create: XOR<AgentCreateWithoutDisparaJaConnectionsInput, AgentUncheckedCreateWithoutDisparaJaConnectionsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutDisparaJaConnectionsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutDisparaJaConnectionsInput, AgentUncheckedUpdateWithoutDisparaJaConnectionsInput>
  }

  export type AgentUpdateWithoutDisparaJaConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAgentsNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutDisparaJaConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type WorkspaceUpsertWithoutDisparaJaConnectionsInput = {
    update: XOR<WorkspaceUpdateWithoutDisparaJaConnectionsInput, WorkspaceUncheckedUpdateWithoutDisparaJaConnectionsInput>
    create: XOR<WorkspaceCreateWithoutDisparaJaConnectionsInput, WorkspaceUncheckedCreateWithoutDisparaJaConnectionsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutDisparaJaConnectionsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutDisparaJaConnectionsInput, WorkspaceUncheckedUpdateWithoutDisparaJaConnectionsInput>
  }

  export type WorkspaceUpdateWithoutDisparaJaConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutDisparaJaConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type DisparaJaLogUpsertWithWhereUniqueWithoutConnectionInput = {
    where: DisparaJaLogWhereUniqueInput
    update: XOR<DisparaJaLogUpdateWithoutConnectionInput, DisparaJaLogUncheckedUpdateWithoutConnectionInput>
    create: XOR<DisparaJaLogCreateWithoutConnectionInput, DisparaJaLogUncheckedCreateWithoutConnectionInput>
  }

  export type DisparaJaLogUpdateWithWhereUniqueWithoutConnectionInput = {
    where: DisparaJaLogWhereUniqueInput
    data: XOR<DisparaJaLogUpdateWithoutConnectionInput, DisparaJaLogUncheckedUpdateWithoutConnectionInput>
  }

  export type DisparaJaLogUpdateManyWithWhereWithoutConnectionInput = {
    where: DisparaJaLogScalarWhereInput
    data: XOR<DisparaJaLogUpdateManyMutationInput, DisparaJaLogUncheckedUpdateManyWithoutConnectionInput>
  }

  export type DisparaJaConnectionCreateWithoutLogsInput = {
    id?: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    agent: AgentCreateNestedOneWithoutDisparaJaConnectionsInput
    workspace: WorkspaceCreateNestedOneWithoutDisparaJaConnectionsInput
  }

  export type DisparaJaConnectionUncheckedCreateWithoutLogsInput = {
    id?: string
    agentId: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type DisparaJaConnectionCreateOrConnectWithoutLogsInput = {
    where: DisparaJaConnectionWhereUniqueInput
    create: XOR<DisparaJaConnectionCreateWithoutLogsInput, DisparaJaConnectionUncheckedCreateWithoutLogsInput>
  }

  export type WorkspaceCreateWithoutDispara_ja_logsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutDispara_ja_logsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutDispara_ja_logsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutDispara_ja_logsInput, WorkspaceUncheckedCreateWithoutDispara_ja_logsInput>
  }

  export type DisparaJaConnectionUpsertWithoutLogsInput = {
    update: XOR<DisparaJaConnectionUpdateWithoutLogsInput, DisparaJaConnectionUncheckedUpdateWithoutLogsInput>
    create: XOR<DisparaJaConnectionCreateWithoutLogsInput, DisparaJaConnectionUncheckedCreateWithoutLogsInput>
    where?: DisparaJaConnectionWhereInput
  }

  export type DisparaJaConnectionUpdateToOneWithWhereWithoutLogsInput = {
    where?: DisparaJaConnectionWhereInput
    data: XOR<DisparaJaConnectionUpdateWithoutLogsInput, DisparaJaConnectionUncheckedUpdateWithoutLogsInput>
  }

  export type DisparaJaConnectionUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutDisparaJaConnectionsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutDisparaJaConnectionsNestedInput
  }

  export type DisparaJaConnectionUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkspaceUpsertWithoutDispara_ja_logsInput = {
    update: XOR<WorkspaceUpdateWithoutDispara_ja_logsInput, WorkspaceUncheckedUpdateWithoutDispara_ja_logsInput>
    create: XOR<WorkspaceCreateWithoutDispara_ja_logsInput, WorkspaceUncheckedCreateWithoutDispara_ja_logsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutDispara_ja_logsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutDispara_ja_logsInput, WorkspaceUncheckedUpdateWithoutDispara_ja_logsInput>
  }

  export type WorkspaceUpdateWithoutDispara_ja_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutDispara_ja_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type ConversationCreateWithoutLeadInput = {
    id?: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutConversationsInput
    messages?: MessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutLeadInput = {
    id?: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutLeadInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutLeadInput, ConversationUncheckedCreateWithoutLeadInput>
  }

  export type ConversationCreateManyLeadInputEnvelope = {
    data: ConversationCreateManyLeadInput | ConversationCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type WorkspaceCreateWithoutLeadsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutLeadsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutLeadsInput, WorkspaceUncheckedCreateWithoutLeadsInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutLeadInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutLeadInput, ConversationUncheckedUpdateWithoutLeadInput>
    create: XOR<ConversationCreateWithoutLeadInput, ConversationUncheckedCreateWithoutLeadInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutLeadInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutLeadInput, ConversationUncheckedUpdateWithoutLeadInput>
  }

  export type ConversationUpdateManyWithWhereWithoutLeadInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutLeadInput>
  }

  export type WorkspaceUpsertWithoutLeadsInput = {
    update: XOR<WorkspaceUpdateWithoutLeadsInput, WorkspaceUncheckedUpdateWithoutLeadsInput>
    create: XOR<WorkspaceCreateWithoutLeadsInput, WorkspaceUncheckedCreateWithoutLeadsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutLeadsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutLeadsInput, WorkspaceUncheckedUpdateWithoutLeadsInput>
  }

  export type WorkspaceUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type LeadCreateWithoutConversationsInput = {
    id?: string
    name?: string | null
    phone: string
    photo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspace: WorkspaceCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutConversationsInput = {
    id?: string
    name?: string | null
    phone: string
    photo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type LeadCreateOrConnectWithoutConversationsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutConversationsInput, LeadUncheckedCreateWithoutConversationsInput>
  }

  export type WorkspaceCreateWithoutConversationsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutConversationsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutConversationsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutConversationsInput, WorkspaceUncheckedCreateWithoutConversationsInput>
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    content: string
    sender?: string
    read?: boolean
    createdAt?: Date | string
    mediaUrl?: string | null
    updatedAt?: Date | string
    type?: string
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    content: string
    sender?: string
    read?: boolean
    createdAt?: Date | string
    mediaUrl?: string | null
    updatedAt?: Date | string
    type?: string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type LeadUpsertWithoutConversationsInput = {
    update: XOR<LeadUpdateWithoutConversationsInput, LeadUncheckedUpdateWithoutConversationsInput>
    create: XOR<LeadCreateWithoutConversationsInput, LeadUncheckedCreateWithoutConversationsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutConversationsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutConversationsInput, LeadUncheckedUpdateWithoutConversationsInput>
  }

  export type LeadUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkspaceUpsertWithoutConversationsInput = {
    update: XOR<WorkspaceUpdateWithoutConversationsInput, WorkspaceUncheckedUpdateWithoutConversationsInput>
    create: XOR<WorkspaceCreateWithoutConversationsInput, WorkspaceUncheckedCreateWithoutConversationsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutConversationsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutConversationsInput, WorkspaceUncheckedUpdateWithoutConversationsInput>
  }

  export type WorkspaceUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: UuidFilter<"Message"> | string
    conversationId?: UuidFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    sender?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    mediaUrl?: StringNullableFilter<"Message"> | string | null
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    type?: StringFilter<"Message"> | string
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lead: LeadCreateNestedOneWithoutConversationsInput
    workspace: WorkspaceCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    leadId: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneRequiredWithoutConversationsNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type AgentCreateWithoutWhatsappCloudConnectionsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentFunction?: string | null
    agentSkills?: string | null
    assistantId?: string | null
    companyDescription?: string | null
    companyName?: string | null
    companySector?: string | null
    companyWebsite?: string | null
    frequencyPenalty?: number | null
    imageUrl?: string | null
    initialMessage?: string | null
    internalName?: string | null
    language?: string | null
    maxMessages?: number | null
    maxTokens?: number | null
    model?: string | null
    personalityObjective?: string | null
    presencePenalty?: number | null
    productInfo?: string | null
    responseFormat?: string | null
    restrictions?: string | null
    temperature?: number | null
    timezone?: string | null
    vectorStoreId?: string | null
    voiceTone?: string | null
    openaiApiKey?: string | null
    userId: string
    workspace: WorkspaceCreateNestedOneWithoutAgentsInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutWhatsappCloudConnectionsInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentFunction?: string | null
    agentSkills?: string | null
    assistantId?: string | null
    companyDescription?: string | null
    companyName?: string | null
    companySector?: string | null
    companyWebsite?: string | null
    frequencyPenalty?: number | null
    imageUrl?: string | null
    initialMessage?: string | null
    internalName?: string | null
    language?: string | null
    maxMessages?: number | null
    maxTokens?: number | null
    model?: string | null
    personalityObjective?: string | null
    presencePenalty?: number | null
    productInfo?: string | null
    responseFormat?: string | null
    restrictions?: string | null
    temperature?: number | null
    timezone?: string | null
    vectorStoreId?: string | null
    voiceTone?: string | null
    openaiApiKey?: string | null
    userId: string
    workspaceId: string
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutWhatsappCloudConnectionsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutWhatsappCloudConnectionsInput, AgentUncheckedCreateWithoutWhatsappCloudConnectionsInput>
  }

  export type WorkspaceCreateWithoutWhatsappCloudConnectionsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogCreateNestedManyWithoutWorkspacesInput
    files?: FileCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationCreateNestedManyWithoutWorkspacesInput
    leads?: LeadCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigCreateNestedManyWithoutWorkspacesInput
    users?: usersCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreCreateNestedManyWithoutWorkspacesInput
  }

  export type WorkspaceUncheckedCreateWithoutWhatsappCloudConnectionsInput = {
    id?: string
    name: string
    subdomain?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agents?: AgentUncheckedCreateNestedManyWithoutWorkspaceInput
    contact_fields?: ContactFieldUncheckedCreateNestedManyWithoutWorkspacesInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutWorkspaceInput
    disparaJaConnections?: DisparaJaConnectionUncheckedCreateNestedManyWithoutWorkspaceInput
    dispara_ja_logs?: DisparaJaLogUncheckedCreateNestedManyWithoutWorkspacesInput
    files?: FileUncheckedCreateNestedManyWithoutWorkspaceInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutWorkspacesInput
    leads?: LeadUncheckedCreateNestedManyWithoutWorkspaceInput
    system_configs?: SystemConfigUncheckedCreateNestedManyWithoutWorkspacesInput
    users?: usersUncheckedCreateNestedManyWithoutWorkspaceInput
    vector_stores?: VectorStoreUncheckedCreateNestedManyWithoutWorkspacesInput
  }

  export type WorkspaceCreateOrConnectWithoutWhatsappCloudConnectionsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutWhatsappCloudConnectionsInput, WorkspaceUncheckedCreateWithoutWhatsappCloudConnectionsInput>
  }

  export type AgentUpsertWithoutWhatsappCloudConnectionsInput = {
    update: XOR<AgentUpdateWithoutWhatsappCloudConnectionsInput, AgentUncheckedUpdateWithoutWhatsappCloudConnectionsInput>
    create: XOR<AgentCreateWithoutWhatsappCloudConnectionsInput, AgentUncheckedCreateWithoutWhatsappCloudConnectionsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutWhatsappCloudConnectionsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutWhatsappCloudConnectionsInput, AgentUncheckedUpdateWithoutWhatsappCloudConnectionsInput>
  }

  export type AgentUpdateWithoutWhatsappCloudConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutAgentsNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutWhatsappCloudConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type WorkspaceUpsertWithoutWhatsappCloudConnectionsInput = {
    update: XOR<WorkspaceUpdateWithoutWhatsappCloudConnectionsInput, WorkspaceUncheckedUpdateWithoutWhatsappCloudConnectionsInput>
    create: XOR<WorkspaceCreateWithoutWhatsappCloudConnectionsInput, WorkspaceUncheckedCreateWithoutWhatsappCloudConnectionsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutWhatsappCloudConnectionsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutWhatsappCloudConnectionsInput, WorkspaceUncheckedUpdateWithoutWhatsappCloudConnectionsInput>
  }

  export type WorkspaceUpdateWithoutWhatsappCloudConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUpdateManyWithoutWorkspacesNestedInput
    files?: FileUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUpdateManyWithoutWorkspacesNestedInput
    users?: usersUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUpdateManyWithoutWorkspacesNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutWhatsappCloudConnectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    subdomain?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agents?: AgentUncheckedUpdateManyWithoutWorkspaceNestedInput
    contact_fields?: ContactFieldUncheckedUpdateManyWithoutWorkspacesNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutWorkspaceNestedInput
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceNestedInput
    dispara_ja_logs?: DisparaJaLogUncheckedUpdateManyWithoutWorkspacesNestedInput
    files?: FileUncheckedUpdateManyWithoutWorkspaceNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutWorkspacesNestedInput
    leads?: LeadUncheckedUpdateManyWithoutWorkspaceNestedInput
    system_configs?: SystemConfigUncheckedUpdateManyWithoutWorkspacesNestedInput
    users?: usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    vector_stores?: VectorStoreUncheckedUpdateManyWithoutWorkspacesNestedInput
  }

  export type usersCreateWithoutVerificationTokensInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenCreateNestedManyWithoutUserInput
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    workspace: WorkspaceCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutVerificationTokensInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    workspaceId: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accessTokens?: AccessTokenUncheckedCreateNestedManyWithoutUserInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutVerificationTokensInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutVerificationTokensInput, usersUncheckedCreateWithoutVerificationTokensInput>
  }

  export type usersUpsertWithoutVerificationTokensInput = {
    update: XOR<usersUpdateWithoutVerificationTokensInput, usersUncheckedUpdateWithoutVerificationTokensInput>
    create: XOR<usersCreateWithoutVerificationTokensInput, usersUncheckedCreateWithoutVerificationTokensInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutVerificationTokensInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutVerificationTokensInput, usersUncheckedUpdateWithoutVerificationTokensInput>
  }

  export type usersUpdateWithoutVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutVerificationTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersCreateWithoutAccessTokensInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    integrations?: IntegrationCreateNestedManyWithoutUserInput
    workspace: WorkspaceCreateNestedOneWithoutUsersInput
    verificationTokens?: VerificationTokenCreateNestedManyWithoutUserInput
  }

  export type usersUncheckedCreateWithoutAccessTokensInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    workspaceId: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    integrations?: IntegrationUncheckedCreateNestedManyWithoutUserInput
    verificationTokens?: VerificationTokenUncheckedCreateNestedManyWithoutUserInput
  }

  export type usersCreateOrConnectWithoutAccessTokensInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutAccessTokensInput, usersUncheckedCreateWithoutAccessTokensInput>
  }

  export type usersUpsertWithoutAccessTokensInput = {
    update: XOR<usersUpdateWithoutAccessTokensInput, usersUncheckedUpdateWithoutAccessTokensInput>
    create: XOR<usersCreateWithoutAccessTokensInput, usersUncheckedCreateWithoutAccessTokensInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutAccessTokensInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutAccessTokensInput, usersUncheckedUpdateWithoutAccessTokensInput>
  }

  export type usersUpdateWithoutAccessTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    workspace?: WorkspaceUpdateOneRequiredWithoutUsersNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutAccessTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AgentCreateManyWorkspaceInput = {
    id?: string
    name: string
    description?: string | null
    systemPrompt?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    agentFunction?: string | null
    agentSkills?: string | null
    assistantId?: string | null
    companyDescription?: string | null
    companyName?: string | null
    companySector?: string | null
    companyWebsite?: string | null
    frequencyPenalty?: number | null
    imageUrl?: string | null
    initialMessage?: string | null
    internalName?: string | null
    language?: string | null
    maxMessages?: number | null
    maxTokens?: number | null
    model?: string | null
    personalityObjective?: string | null
    presencePenalty?: number | null
    productInfo?: string | null
    responseFormat?: string | null
    restrictions?: string | null
    temperature?: number | null
    timezone?: string | null
    vectorStoreId?: string | null
    voiceTone?: string | null
    openaiApiKey?: string | null
    userId: string
  }

  export type ContactFieldCreateManyWorkspacesInput = {
    id?: string
    name: string
    type: string
    required?: boolean
    options?: ContactFieldCreateoptionsInput | string[]
    placeholder?: string | null
    default_value?: string | null
    description?: string | null
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyWorkspaceInput = {
    id?: string
    leadId: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisparaJaConnectionCreateManyWorkspaceInput = {
    id?: string
    agentId: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DisparaJaLogCreateManyWorkspacesInput = {
    id?: string
    connectionId?: string | null
    type: string
    message: string
    timestamp?: Date | string
  }

  export type FileCreateManyWorkspaceInput = {
    id?: string
    fileId: string
    filename: string
    purpose: string
    size: number
    type?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateManyWorkspacesInput = {
    id?: string
    userId: string
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateManyWorkspaceInput = {
    id?: string
    name?: string | null
    phone: string
    photo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemConfigCreateManyWorkspacesInput = {
    id?: string
    key: string
    value: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersCreateManyWorkspaceInput = {
    id?: string
    email: string
    name?: string | null
    password: string
    role?: string
    emailVerified?: Date | string | null
    verifyToken?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    lastLogin?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VectorStoreCreateManyWorkspacesInput = {
    id?: string
    name: string
    description?: string | null
    openaiId: string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhatsAppCloudConnectionCreateManyWorkspaceInput = {
    id?: string
    agentId: string
    phoneNumberId: string
    accessToken: string
    status?: string
    webhookUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    verifyToken?: string
  }

  export type AgentUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    disparaJaConnections?: DisparaJaConnectionUpdateManyWithoutAgentNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    disparaJaConnections?: DisparaJaConnectionUncheckedUpdateManyWithoutAgentNestedInput
    whatsappCloudConnections?: WhatsAppCloudConnectionUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    systemPrompt?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agentFunction?: NullableStringFieldUpdateOperationsInput | string | null
    agentSkills?: NullableStringFieldUpdateOperationsInput | string | null
    assistantId?: NullableStringFieldUpdateOperationsInput | string | null
    companyDescription?: NullableStringFieldUpdateOperationsInput | string | null
    companyName?: NullableStringFieldUpdateOperationsInput | string | null
    companySector?: NullableStringFieldUpdateOperationsInput | string | null
    companyWebsite?: NullableStringFieldUpdateOperationsInput | string | null
    frequencyPenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    initialMessage?: NullableStringFieldUpdateOperationsInput | string | null
    internalName?: NullableStringFieldUpdateOperationsInput | string | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    maxMessages?: NullableIntFieldUpdateOperationsInput | number | null
    maxTokens?: NullableIntFieldUpdateOperationsInput | number | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    personalityObjective?: NullableStringFieldUpdateOperationsInput | string | null
    presencePenalty?: NullableFloatFieldUpdateOperationsInput | number | null
    productInfo?: NullableStringFieldUpdateOperationsInput | string | null
    responseFormat?: NullableStringFieldUpdateOperationsInput | string | null
    restrictions?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    vectorStoreId?: NullableStringFieldUpdateOperationsInput | string | null
    voiceTone?: NullableStringFieldUpdateOperationsInput | string | null
    openaiApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ContactFieldUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: ContactFieldUpdateoptionsInput | string[]
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFieldUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: ContactFieldUpdateoptionsInput | string[]
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactFieldUncheckedUpdateManyWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    options?: ContactFieldUpdateoptionsInput | string[]
    placeholder?: NullableStringFieldUpdateOperationsInput | string | null
    default_value?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lead?: LeadUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    leadId?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisparaJaConnectionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: AgentUpdateOneRequiredWithoutDisparaJaConnectionsNestedInput
    logs?: DisparaJaLogUpdateManyWithoutConnectionNestedInput
  }

  export type DisparaJaConnectionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: DisparaJaLogUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type DisparaJaConnectionUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisparaJaLogUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    connection?: DisparaJaConnectionUpdateOneWithoutLogsNestedInput
  }

  export type DisparaJaLogUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisparaJaLogUncheckedUpdateManyWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    connectionId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: usersUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversations?: ConversationUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemConfigUncheckedUpdateManyWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accessTokens?: AccessTokenUncheckedUpdateManyWithoutUserNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutUserNestedInput
    verificationTokens?: VerificationTokenUncheckedUpdateManyWithoutUserNestedInput
  }

  export type usersUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    verifyToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VectorStoreUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openaiId?: StringFieldUpdateOperationsInput | string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VectorStoreUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openaiId?: StringFieldUpdateOperationsInput | string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VectorStoreUncheckedUpdateManyWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    openaiId?: StringFieldUpdateOperationsInput | string
    files?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhatsAppCloudConnectionUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyToken?: StringFieldUpdateOperationsInput | string
    agent?: AgentUpdateOneRequiredWithoutWhatsappCloudConnectionsNestedInput
  }

  export type WhatsAppCloudConnectionUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyToken?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppCloudConnectionUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    agentId?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyToken?: StringFieldUpdateOperationsInput | string
  }

  export type AccessTokenCreateManyUserInput = {
    id?: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type IntegrationCreateManyUserInput = {
    id?: string
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type VerificationTokenCreateManyUserInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
    createdAt?: Date | string
  }

  export type AccessTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type IntegrationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type VerificationTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DisparaJaConnectionCreateManyAgentInput = {
    id?: string
    provider?: string
    secret: string
    sid: string
    token?: string | null
    phoneNumber: string
    unique: string
    webhookUrl: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type WhatsAppCloudConnectionCreateManyAgentInput = {
    id?: string
    phoneNumberId: string
    accessToken: string
    status?: string
    webhookUrl?: string | null
    workspaceId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    verifyToken?: string
  }

  export type DisparaJaConnectionUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutDisparaJaConnectionsNestedInput
    logs?: DisparaJaLogUpdateManyWithoutConnectionNestedInput
  }

  export type DisparaJaConnectionUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    logs?: DisparaJaLogUncheckedUpdateManyWithoutConnectionNestedInput
  }

  export type DisparaJaConnectionUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    secret?: StringFieldUpdateOperationsInput | string
    sid?: StringFieldUpdateOperationsInput | string
    token?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    unique?: StringFieldUpdateOperationsInput | string
    webhookUrl?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppCloudConnectionUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyToken?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutWhatsappCloudConnectionsNestedInput
  }

  export type WhatsAppCloudConnectionUncheckedUpdateWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyToken?: StringFieldUpdateOperationsInput | string
  }

  export type WhatsAppCloudConnectionUncheckedUpdateManyWithoutAgentInput = {
    id?: StringFieldUpdateOperationsInput | string
    phoneNumberId?: StringFieldUpdateOperationsInput | string
    accessToken?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    webhookUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyToken?: StringFieldUpdateOperationsInput | string
  }

  export type DisparaJaLogCreateManyConnectionInput = {
    id?: string
    type: string
    message: string
    timestamp?: Date | string
    workspaceId: string
  }

  export type DisparaJaLogUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaces?: WorkspaceUpdateOneRequiredWithoutDispara_ja_logsNestedInput
  }

  export type DisparaJaLogUncheckedUpdateWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type DisparaJaLogUncheckedUpdateManyWithoutConnectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationCreateManyLeadInput = {
    id?: string
    threadId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workspaceId: string
  }

  export type ConversationUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkspaceUpdateOneRequiredWithoutConversationsNestedInput
    messages?: MessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    content: string
    sender?: string
    read?: boolean
    createdAt?: Date | string
    mediaUrl?: string | null
    updatedAt?: Date | string
    type?: string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    sender?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mediaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}